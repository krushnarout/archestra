// This file is auto-generated by @hey-api/openapi-ts

/**
 * AccessMode defines the access mode of a volume.
 */
export type AccessMode = {
  BlockVolume?: TypeBlock;
  MountVolume?: TypeMount;
  Scope?: Scope;
  Sharing?: SharingMode;
};

/**
 * Address represents an IP address.
 */
export type Address = {
  Addr?: string;
  PrefixLength?: number;
};

/**
 * ArtifactVolume is a volume based on a artifact. The artifact blobs will
 * be bind mounted directly as files and must always be read only.
 */
export type ArtifactVolume = {
  /**
   * Destination is the absolute path of the mount in the container.
   * If path is a file in the container, then the artifact must consist of a single blob.
   * Otherwise if it is a directory or does not exists all artifact blobs will be mounted
   * into this path as files. As name the "org.opencontainers.image.title" will be used if
   * available otherwise the digest is used as name.
   */
  destination?: string;
  /**
   * Digest can be used to filter a single blob from a multi blob artifact by the given digest.
   * When this option is set the file name in the container defaults to the digest even when
   * the title annotation exist.
   * Optional. Conflicts with Title.
   */
  digest?: string;
  /**
   * Source is the name or digest of the artifact that should be mounted
   */
  source?: string;
  /**
   * Title can be used for multi blob artifacts to only mount the one specific blob that
   * matches the "org.opencontainers.image.title" annotation.
   * Optional. Conflicts with Digest.
   */
  title?: string;
};

export type AttestationProperties = {
  For?: Digest;
};

/**
 * AuthConfig contains authorization information for connecting to a Registry
 */
export type AuthConfig = {
  auth?: string;
  /**
   * Email is an optional value associated with the username.
   * This field is deprecated and will be removed in a later
   * version of docker.
   */
  email?: string;
  /**
   * IdentityToken is used to authenticate the user and get
   * an access token for the registry.
   */
  identitytoken?: string;
  password?: string;
  /**
   * RegistryToken is a bearer token to be sent to a registry
   */
  registrytoken?: string;
  serveraddress?: string;
  username?: string;
};

/**
 * AuthReport describes the response for authentication check
 */
export type AuthReport = {
  IdentityToken?: string;
  Status?: string;
};

/**
 * AuthenticateOKBody authenticate o k body
 */
export type AuthenticateOkBody = {
  /**
   * An opaque token used to authenticate a user after a successful login
   */
  IdentityToken: string;
  /**
   * The status of the authentication
   */
  Status: string;
};

/**
 * AutoUserNsOptions defines how to automatically create a user namespace.
 */
export type AutoUserNsOptions = {
  /**
   * AdditionalGIDMappings specified additional GID mappings to include in
   * the generated user namespace.
   */
  AdditionalGIDMappings?: Array<IdMap>;
  /**
   * AdditionalUIDMappings specified additional UID mappings to include in
   * the generated user namespace.
   */
  AdditionalUIDMappings?: Array<IdMap>;
  /**
   * GroupFile to use if the container uses a volume.
   */
  GroupFile?: string;
  /**
   * InitialSize defines the minimum size for the user namespace.
   * The created user namespace will have at least this size.
   */
  InitialSize?: number;
  /**
   * PasswdFile to use if the container uses a volume.
   */
  PasswdFile?: string;
  /**
   * Size defines the size for the user namespace.  If it is set to a
   * value bigger than 0, the user namespace will have exactly this size.
   * If it is not set, some heuristics will be used to find its size.
   */
  Size?: number;
};

/**
 * Availability specifies the availability of the volume.
 */
export type Availability = string;

/**
 * BindOptions defines options specific to mounts of type "bind".
 */
export type BindOptions = {
  CreateMountpoint?: boolean;
  NonRecursive?: boolean;
  Propagation?: Propagation;
  /**
   * ReadOnlyForceRecursive raises an error if the mount cannot be made recursively read-only.
   */
  ReadOnlyForceRecursive?: boolean;
  /**
   * ReadOnlyNonRecursive makes the mount non-recursively read-only, but still leaves the mount recursive
   * (unless NonRecursive is set to true in conjunction).
   */
  ReadOnlyNonRecursive?: boolean;
};

export type CpuUsage = {
  idlePercent?: number;
  systemPercent?: number;
  userPercent?: number;
};

/**
 * CapacityRange describes the minimum and maximum capacity a volume should be
 * created with
 */
export type CapacityRange = {
  /**
   * LimitBytes specifies that a volume must not be bigger than this. The
   * value of 0 indicates an unspecified maximum
   */
  LimitBytes?: number;
  /**
   * RequiredBytes specifies that a volume must be at least this big. The
   * value of 0 indicates an unspecified minimum.
   */
  RequiredBytes?: number;
};

/**
 * CgroupSpec represents the cgroup to use for the container.
 */
export type CgroupSpec = string;

/**
 * CgroupnsMode represents the cgroup namespace mode of the container
 */
export type CgroupnsMode = string;

/**
 * ChangeType Kind of change
 * Can be one of:
 *
 * `0`: Modified ("C")
 * `1`: Added ("A")
 * `2`: Deleted ("D")
 */
export type ChangeType = number;

/**
 * ClusterOptions specifies options for a Cluster volume.
 */
export type ClusterOptions = {
  [key: string]: unknown;
};

/**
 * ClusterVolume contains options and information specific to, and only present
 * on, Swarm CSI cluster volumes.
 */
export type ClusterVolume = {
  CreatedAt?: string;
  /**
   * ID is the Swarm ID of the volume. Because cluster volumes are Swarm
   * objects, they have an ID, unlike non-cluster volumes, which only have a
   * Name. This ID can be used to refer to the cluster volume.
   */
  ID?: string;
  Info?: Info;
  /**
   * PublishStatus contains the status of the volume as it pertains to its
   * publishing on Nodes.
   */
  PublishStatus?: Array<PublishStatus>;
  Spec?: ClusterVolumeSpec;
  UpdatedAt?: string;
  Version?: Version;
};

/**
 * ClusterVolumeSpec contains the spec used to create this volume.
 */
export type ClusterVolumeSpec = {
  AccessMode?: AccessMode;
  AccessibilityRequirements?: TopologyRequirement;
  Availability?: Availability;
  CapacityRange?: CapacityRange;
  /**
   * Group defines the volume group of this volume. Volumes belonging to the
   * same group can be referred to by group name when creating Services.
   * Referring to a volume by group instructs swarm to treat volumes in that
   * group interchangeably for the purpose of scheduling. Volumes with an
   * empty string for a group technically all belong to the same, emptystring
   * group.
   */
  Group?: string;
  /**
   * Secrets defines Swarm Secrets that are passed to the CSI storage plugin
   * when operating on this volume.
   */
  Secrets?: Array<Secret>;
};

/**
 * ComponentVersion describes the version information for a specific component.
 */
export type ComponentVersion = {
  Details?: {
    [key: string]: string;
  };
  Name?: string;
  Version?: string;
};

/**
 * Config contains the configuration data about a container.
 * It should hold only portable information about the container.
 * Here, "portable" means "independent from the host we are running on".
 * Non-portable information *should* appear in HostConfig.
 * All fields added to this struct must be marked `omitempty` to keep getting
 * predictable hashes from the old `v1Compatibility` configuration.
 */
export type Config = {
  ArgsEscaped?: boolean;
  AttachStderr?: boolean;
  AttachStdin?: boolean;
  AttachStdout?: boolean;
  Cmd?: StrSlice;
  Domainname?: string;
  Entrypoint?: StrSlice;
  Env?: Array<string>;
  ExposedPorts?: PortSet;
  Healthcheck?: HealthcheckConfig;
  Hostname?: string;
  Image?: string;
  Labels?: {
    [key: string]: string;
  };
  /**
   * Mac Address of the container.
   *
   * Deprecated: this field is deprecated since API v1.44. Use EndpointSettings.MacAddress instead.
   */
  MacAddress?: string;
  NetworkDisabled?: boolean;
  OnBuild?: Array<string>;
  OpenStdin?: boolean;
  Shell?: StrSlice;
  StdinOnce?: boolean;
  StopSignal?: string;
  StopTimeout?: number;
  Tty?: boolean;
  User?: string;
  Volumes?: {
    [key: string]: {
      [key: string]: unknown;
    };
  };
  WorkingDir?: string;
};

/**
 * ConfigReference specifies the source which provides a network's configuration
 */
export type ConfigReference = {
  Network?: string;
};

/**
 * ConmonInfo describes the conmon executable being used
 */
export type ConmonInfo = {
  package?: string;
  path?: string;
  version?: string;
};

/**
 * ConnectOptions represents the data to be used to connect a container to the
 * network.
 */
export type ConnectOptions = {
  Container?: string;
  EndpointConfig?: EndpointSettings;
};

/**
 * Consistency represents the consistency requirements of a mount.
 */
export type Consistency = string;

export type Container = {
  Command?: string;
  Config?: Config;
  Created?: number;
  DefaultReadOnlyNonRecursive?: boolean;
  HostConfig?: HostConfig;
  Id?: string;
  Image?: string;
  ImageID?: string;
  ImageManifestDescriptor?: Descriptor;
  Labels?: {
    [key: string]: string;
  };
  Mounts?: Array<MountPoint>;
  Name?: string;
  Names?: Array<string>;
  NetworkSettings?: NetworkSettingsSummary;
  NetworkingConfig?: NetworkingConfig;
  Platform?: Platform;
  Ports?: Array<Port>;
  SizeRootFs?: number;
  SizeRw?: number;
  State?: string;
  Status?: string;
};

/**
 * ContainerBasicConfig contains the basic parts of a container.
 */
export type ContainerBasicConfig = {
  /**
   * Annotations are key-value options passed into the container runtime
   * that can be used to trigger special behavior.
   * Optional.
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * Command is the container's command.
   * If not given and Image is specified, this will be populated by the
   * image's configuration.
   * Optional.
   */
  command?: Array<string>;
  /**
   * ConmonPidFile is a path at which a PID file for Conmon will be
   * placed.
   * If not given, a default location will be used.
   * Optional.
   */
  conmon_pid_file?: string;
  /**
   * ContainerCreateCommand is the command that was used to create this
   * container.
   * This will be shown in the output of Inspect() on the container, and
   * may also be used by some tools that wish to recreate the container
   * (e.g. `podman generate systemd --new`).
   * Optional.
   */
  containerCreateCommand?: Array<string>;
  /**
   * DependencyContainers is an array of containers this container
   * depends on. Dependency containers must be started before this
   * container. Dependencies can be specified by name or full/partial ID.
   * Optional.
   */
  dependencyContainers?: Array<string>;
  /**
   * Entrypoint is the container's entrypoint.
   * If not given and Image is specified, this will be populated by the
   * image's configuration.
   * Optional.
   */
  entrypoint?: Array<string>;
  /**
   * Env is a set of environment variables that will be set in the
   * container.
   * Optional.
   */
  env?: {
    [key: string]: string;
  };
  /**
   * EnvHost indicates that the host environment should be added to container
   * Optional.
   */
  env_host?: boolean;
  /**
   * EnvMerge takes the specified environment variables from image and preprocess them before injecting them into the
   * container.
   * Optional.
   */
  envmerge?: Array<string>;
  /**
   * GroupEntry specifies an arbitrary string to append to the container's /etc/group file.
   * Optional.
   */
  group_entry?: string;
  /**
   * Hostname is the container's hostname. If not set, the hostname will
   * not be modified (if UtsNS is not private) or will be set to the
   * container ID (if UtsNS is private).
   * Conflicts with UtsNS if UtsNS is not set to private.
   * Optional.
   */
  hostname?: string;
  /**
   * HostUsers is a list of host usernames or UIDs to add to the container
   * etc/passwd file
   */
  hostusers?: Array<string>;
  /**
   * EnvHTTPProxy indicates that the http host proxy environment variables
   * should be added to container
   * Optional.
   */
  httpproxy?: boolean;
  /**
   * InitContainerType describes if this container is an init container
   * and if so, what type: always or once.
   * Optional.
   */
  init_container_type?: string;
  /**
   * Labels are key-value pairs that are used to add metadata to
   * containers.
   * Optional.
   */
  labels?: {
    [key: string]: string;
  };
  log_configuration?: LogConfigLibpod;
  /**
   * Passwd is a container run option that determines if we are validating users/groups before running the container
   */
  manage_password?: boolean;
  /**
   * Name is the name the container will be given.
   * If no name is provided, one will be randomly generated.
   * Optional.
   */
  name?: string;
  /**
   * OCIRuntime is the name of the OCI runtime that will be used to create
   * the container.
   * If not specified, the default will be used.
   * Optional.
   */
  oci_runtime?: string;
  /**
   * PasswdEntry specifies an arbitrary string to append to the container's /etc/passwd file.
   * Optional.
   */
  passwd_entry?: string;
  personality?: LinuxPersonality;
  pidns?: Namespace;
  /**
   * Pod is the ID of the pod the container will join.
   * Optional.
   */
  pod?: string;
  /**
   * Remove indicates if the container should be removed once it has been started
   * and exits.
   * Optional.
   */
  remove?: boolean;
  /**
   * RemoveImage indicates that the container should remove the image it
   * was created from after it exits.
   * Only allowed if Remove is set to true and Image, not Rootfs, is in
   * use.
   * Optional.
   */
  removeImage?: boolean;
  /**
   * RestartPolicy is the container's restart policy - an action which
   * will be taken when the container exits.
   * If not given, the default policy, which does nothing, will be used.
   * Optional.
   */
  restart_policy?: string;
  /**
   * RestartRetries is the number of attempts that will be made to restart
   * the container.
   * Only available when RestartPolicy is set to "on-failure".
   * Optional.
   */
  restart_tries?: number;
  /**
   * Determine how to handle the NOTIFY_SOCKET - do we participate or pass it through
   * "container" - let the OCI runtime deal with it, advertise conmon's MAINPID
   * "conmon-only" - advertise conmon's MAINPID, send READY when started, don't pass to OCI
   * "ignore" - unset NOTIFY_SOCKET
   * Optional.
   */
  sdnotifyMode?: string;
  /**
   * EnvSecrets are secrets that will be set as environment variables
   * Optional.
   */
  secret_env?: {
    [key: string]: string;
  };
  /**
   * Stdin is whether the container will keep its STDIN open.
   * Optional.
   */
  stdin?: boolean;
  stop_signal?: Signal;
  /**
   * StopTimeout is a timeout between the container's stop signal being
   * sent and SIGKILL being sent.
   * If not provided, the default will be used.
   * If 0 is used, stop signal will not be sent, and SIGKILL will be sent
   * instead.
   * Optional.
   */
  stop_timeout?: number;
  /**
   * Sysctl sets kernel parameters for the container
   */
  sysctl?: {
    [key: string]: string;
  };
  /**
   * Systemd is whether the container will be started in systemd mode.
   * Valid options are "true", "false", and "always".
   * "true" enables this mode only if the binary run in the container is
   * sbin/init or systemd. "always" unconditionally enables systemd mode.
   * "false" unconditionally disables systemd mode.
   * If enabled, mounts and stop signal will be modified.
   * If set to "always" or set to "true" and conditionally triggered,
   * conflicts with StopSignal.
   * If not specified, "false" will be assumed.
   * Optional.
   */
  systemd?: string;
  /**
   * Terminal is whether the container will create a PTY.
   * Optional.
   */
  terminal?: boolean;
  /**
   * Timeout is a maximum time in seconds the container will run before
   * main process is sent SIGKILL.
   * If 0 is used, signal will not be sent. Container can run indefinitely
   * if they do not stop after the default termination signal.
   * Optional.
   */
  timeout?: number;
  /**
   * Timezone is the timezone inside the container.
   * Local means it has the same timezone as the host machine
   * Optional.
   */
  timezone?: string;
  /**
   * UnsetEnv unsets the specified default environment variables from the image or from built-in or containers.conf
   * Optional.
   */
  unsetenv?: Array<string>;
  /**
   * UnsetEnvAll unsetall default environment variables from the image or from built-in or containers.conf
   * UnsetEnvAll unsets all default environment variables from the image or from built-in
   * Optional.
   */
  unsetenvall?: boolean;
  utsns?: Namespace;
};

/**
 * ContainerCgroupConfig contains configuration information about a container's
 * cgroups.
 */
export type ContainerCgroupConfig = {
  /**
   * CgroupParent is the container's Cgroup parent.
   * If not set, the default for the current cgroup driver will be used.
   * Optional.
   */
  cgroup_parent?: string;
  cgroupns?: Namespace;
  /**
   * CgroupsMode sets a policy for how cgroups will be created for the
   * container, including the ability to disable creation entirely.
   * Optional.
   */
  cgroups_mode?: string;
};

/**
 * ContainerCreateResponse is the response struct for creating a container
 */
export type ContainerCreateResponse = {
  /**
   * ID of the container created
   */
  Id: string;
  /**
   * Warnings during container creation
   */
  Warnings: Array<string>;
};

/**
 * ContainerHealthCheckConfig describes a container healthcheck with attributes
 * like command, retries, interval, start period, and timeout.
 */
export type ContainerHealthCheckConfig = {
  health_check_on_failure_action?: HealthCheckOnFailureAction;
  /**
   * HealthLogDestination defines the destination where the log is stored.
   * TODO (6.0): In next major release convert it to pointer and use omitempty
   */
  healthLogDestination?: string;
  /**
   * HealthMaxLogCount is maximum number of attempts in the HealthCheck log file.
   * ('0' value means an infinite number of attempts in the log file).
   * TODO (6.0): In next major release convert it to pointer and use omitempty
   */
  healthMaxLogCount?: number;
  /**
   * HealthMaxLogSize is the maximum length in characters of stored HealthCheck log
   * ("0" value means an infinite log length).
   * TODO (6.0): In next major release convert it to pointer and use omitempty
   */
  healthMaxLogSize?: number;
  healthconfig?: Schema2HealthConfig;
  startupHealthConfig?: StartupHealthCheck;
};

/**
 * ContainerNetworkConfig contains information on a container's network
 * configuration.
 */
export type ContainerNetworkConfig = {
  /**
   * Map of networks names or ids that the container should join.
   * You can request additional settings for each network, you can
   * set network aliases, static ips, static mac address  and the
   * network interface name for this container on the specific network.
   * If the map is empty and the bridge network mode is set the container
   * will be joined to the default network.
   * Optional.
   */
  Networks?: {
    [key: string]: PerNetworkOptions;
  };
  /**
   * BaseHostsFile is the base file to create the `/etc/hosts` file inside the container.
   * This must either be an absolute path to a file on the host system, or one of the
   * special flags `image` or `none`.
   * If it is empty it defaults to the base_hosts_file configuration in containers.conf.
   * Optional.
   */
  base_hosts_file?: string;
  /**
   * CNINetworks is a list of CNI networks to join the container to.
   * If this list is empty, the default CNI network will be joined
   * instead. If at least one entry is present, we will not join the
   * default network (unless it is part of this list).
   * Only available if NetNS is set to bridge.
   * Optional.
   * Deprecated: as of podman 4.0 use "Networks" instead.
   */
  cni_networks?: Array<string>;
  /**
   * DNSOptions is a set of DNS options that will be used in the
   * container's resolv.conf, replacing the host's DNS options which are
   * used by default.
   * Conflicts with UseImageResolvConf.
   * Optional.
   */
  dns_option?: Array<string>;
  /**
   * DNSSearch is a set of DNS search domains that will be used in the
   * container's resolv.conf, replacing the host's DNS search domains
   * which are used by default.
   * Conflicts with UseImageResolvConf.
   * Optional.
   */
  dns_search?: Array<string>;
  /**
   * DNSServers is a set of DNS servers that will be used in the
   * container's resolv.conf, replacing the host's DNS Servers which are
   * used by default.
   * Conflicts with UseImageResolvConf.
   * Optional.
   */
  dns_server?: Array<string>;
  /**
   * Expose is a number of ports that will be forwarded to the container
   * if PublishExposedPorts is set.
   * Expose is a map of uint16 (port number) to a string representing
   * protocol i.e map[uint16]string. Allowed protocols are "tcp", "udp", and "sctp", or some
   * combination of the three separated by commas.
   * If protocol is set to "" we will assume TCP.
   * Only available if NetNS is set to Bridge or Slirp, and
   * PublishExposedPorts is set.
   * Optional.
   */
  expose?: unknown;
  /**
   * HostAdd is a set of hosts which will be added to the container's
   * etc/hosts file.
   * Conflicts with UseImageHosts.
   * Optional.
   */
  hostadd?: Array<string>;
  netns?: Namespace;
  /**
   * NetworkOptions are additional options for each network
   * Optional.
   */
  network_options?: {
    [key: string]: Array<string>;
  };
  /**
   * PortBindings is a set of ports to map into the container.
   * Only available if NetNS is set to bridge, slirp, or pasta.
   * Optional.
   */
  portmappings?: Array<PortMapping>;
  /**
   * PublishExposedPorts will publish ports specified in the image to
   * random unused ports (guaranteed to be above 1024) on the host.
   * This is based on ports set in Expose below, and any ports specified
   * by the Image (if one is given).
   * Only available if NetNS is set to Bridge or Slirp.
   * Optional.
   */
  publish_image_ports?: boolean;
  /**
   * UseImageHostname indicates that /etc/hostname should not be managed by
   * Podman, and instead sourced from the image.
   * Optional.
   */
  use_image_hostname?: boolean;
  /**
   * UseImageHosts indicates that /etc/hosts should not be managed by
   * Podman, and instead sourced from the image.
   * Conflicts with HostAdd.
   * Optional.
   */
  use_image_hosts?: boolean;
  /**
   * UseImageResolvConf indicates that resolv.conf should not be managed
   * by Podman, but instead sourced from the image.
   * Conflicts with DNSServer, DNSSearch, DNSOption.
   * Optional.
   */
  use_image_resolve_conf?: boolean;
};

/**
 * Statistics for an individual container network interface
 */
export type ContainerNetworkStats = {
  RxBytes?: number;
  RxDropped?: number;
  RxErrors?: number;
  RxPackets?: number;
  TxBytes?: number;
  TxDropped?: number;
  TxErrors?: number;
  TxPackets?: number;
};

/**
 * ContainerResourceConfig contains information on container resource limits.
 */
export type ContainerResourceConfig = {
  intelRdt?: LinuxIntelRdt;
  /**
   * OOMScoreAdj adjusts the score used by the OOM killer to determine
   * processes to kill for the container's process.
   * Optional.
   */
  oom_score_adj?: number;
  /**
   * Rlimits are POSIX rlimits to apply to the container.
   * Optional.
   */
  r_limits?: Array<PosixRlimit>;
  resource_limits?: LinuxResources;
  /**
   * IO read rate limit per cgroup per device, bytes per second
   */
  throttleReadBpsDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * IO read rate limit per cgroup per device, IO per second
   */
  throttleReadIOPSDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * IO write rate limit per cgroup per device, bytes per second
   */
  throttleWriteBpsDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * IO write rate limit per cgroup per device, IO per second
   */
  throttleWriteIOPSDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * CgroupConf are key-value options passed into the container runtime
   * that are used to configure cgroup v2.
   * Optional.
   */
  unified?: {
    [key: string]: string;
  };
  /**
   * Weight per cgroup per device, can override BlkioWeight
   */
  weightDevice?: {
    [key: string]: LinuxWeightDevice;
  };
};

/**
 * ContainerSecurityConfig is a container's security features, including
 * SELinux, Apparmor, and Seccomp.
 */
export type ContainerSecurityConfig = {
  /**
   * ApparmorProfile is the name of the Apparmor profile the container
   * will use.
   * Optional.
   */
  apparmor_profile?: string;
  /**
   * CapAdd are capabilities which will be added to the container.
   * Conflicts with Privileged.
   * Optional.
   */
  cap_add?: Array<string>;
  /**
   * CapDrop are capabilities which will be removed from the container.
   * Conflicts with Privileged.
   * Optional.
   */
  cap_drop?: Array<string>;
  /**
   * Groups are a list of supplemental groups the container's user will
   * be granted access to.
   * Optional.
   */
  groups?: Array<string>;
  idmappings?: IdMappingOptions;
  /**
   * LabelNested indicates whether or not the container is allowed to
   * run fully nested containers including SELinux labelling.
   * Optional.
   */
  label_nested?: boolean;
  /**
   * Mask is the path we want to mask in the container. This masks the paths
   * given in addition to the default list.
   * Optional
   */
  mask?: Array<string>;
  /**
   * NoNewPrivileges is whether the container will set the no new
   * privileges flag on create, which disables gaining additional
   * privileges (e.g. via setuid) in the container.
   * Optional.
   */
  no_new_privileges?: boolean;
  /**
   * Privileged is whether the container is privileged.
   * Privileged does the following:
   * Adds all devices on the system to the container.
   * Adds all capabilities to the container.
   * Disables Seccomp, SELinux, and Apparmor confinement.
   * (Though SELinux can be manually re-enabled).
   * TODO: this conflicts with things.
   * TODO: this does more.
   * Optional.
   */
  privileged?: boolean;
  /**
   * ProcOpts are the options used for the proc mount.
   */
  procfs_opts?: Array<string>;
  /**
   * ReadOnlyFilesystem indicates that everything will be mounted
   * as read-only.
   * Optional.
   */
  read_only_filesystem?: boolean;
  /**
   * ReadWriteTmpfs indicates that when running with a ReadOnlyFilesystem
   * mount temporary file systems.
   * Optional.
   */
  read_write_tmpfs?: boolean;
  /**
   * SeccompPolicy determines which seccomp profile gets applied
   * the container. valid values: empty,default,image
   */
  seccomp_policy?: string;
  /**
   * SeccompProfilePath is the path to a JSON file containing the
   * container's Seccomp profile.
   * If not specified, no Seccomp profile will be used.
   * Optional.
   */
  seccomp_profile_path?: string;
  /**
   * SelinuxProcessLabel is the process label the container will use.
   * If SELinux is enabled and this is not specified, a label will be
   * automatically generated if not specified.
   * Optional.
   */
  selinux_opts?: Array<string>;
  /**
   * Umask is the umask the init process of the container will be run with.
   */
  umask?: string;
  /**
   * Unmask a path in the container. Some paths are masked by default,
   * preventing them from being accessed within the container; this undoes
   * that masking. If ALL is passed, all paths will be unmasked.
   * Optional.
   */
  unmask?: Array<string>;
  /**
   * User is the user the container will be run as.
   * Can be given as a UID or a username; if a username, it will be
   * resolved within the container, using the container's /etc/passwd.
   * If unset, the container will be run as root.
   * Optional.
   */
  user?: string;
  userns?: Namespace;
};

/**
 * ContainerSize holds the size of the container's root filesystem and top
 * read-write layer.
 */
export type ContainerSize = {
  rootFsSize?: number;
  rwSize?: number;
};

/**
 * ContainerStats contains the statistics information for a running container
 */
export type ContainerStats = {
  AvgCPU?: number;
  BlockInput?: number;
  BlockOutput?: number;
  CPU?: number;
  CPUNano?: number;
  CPUSystemNano?: number;
  ContainerID?: string;
  Duration?: number;
  MemLimit?: number;
  MemPerc?: number;
  MemUsage?: number;
  Name?: string;
  /**
   * Map of interface name to network statistics for that interface.
   */
  Network?: {
    [key: string]: ContainerNetworkStats;
  };
  PIDs?: number;
  PerCPU?: Array<number>;
  SystemNano?: number;
  UpTime?: Duration;
};

/**
 * ContainerStorageConfig contains information on the storage configuration of a
 * container.
 */
export type ContainerStorageConfig = {
  /**
   * ArtifactVolumes volumes based on an existing artifact.
   */
  artifact_volumes?: Array<ArtifactVolume>;
  /**
   * ChrootDirs is an additional set of directories that need to be
   * treated as root directories. Standard bind mounts will be mounted
   * into paths relative to these directories.
   * Optional.
   */
  chroot_directories?: Array<string>;
  /**
   * Create the working directory if it doesn't exist.
   * If unset, it doesn't create it.
   * Optional.
   */
  create_working_dir?: boolean;
  /**
   * DeviceCgroupRule are device cgroup rules that allow containers
   * to use additional types of devices.
   */
  device_cgroup_rule?: Array<LinuxDeviceCgroup>;
  /**
   * Devices are devices that will be added to the container.
   * Optional.
   */
  devices?: Array<LinuxDevice>;
  /**
   * DevicesFrom specifies that this container will mount the device(s) from other container(s).
   * Optional.
   */
  devices_from?: Array<string>;
  /**
   * HostDeviceList is used to recreate the mounted device on inherited containers
   */
  host_device_list?: Array<LinuxDevice>;
  /**
   * Image is the image the container will be based on. The image will be
   * used as the container's root filesystem, and its environment vars,
   * volumes, and other configuration will be applied to the container.
   * Conflicts with Rootfs.
   * At least one of Image or Rootfs must be specified.
   */
  image?: string;
  /**
   * ImageArch is the user-specified image architecture.
   * Used to select a different variant from a manifest list.
   * Optional.
   */
  image_arch?: string;
  /**
   * ImageOS is the user-specified OS of the image.
   * Used to select a different variant from a manifest list.
   * Optional.
   */
  image_os?: string;
  /**
   * ImageVariant is the user-specified image variant.
   * Used to select a different variant from a manifest list.
   * Optional.
   */
  image_variant?: string;
  /**
   * ImageVolumeMode indicates how image volumes will be created.
   * Supported modes are "ignore" (do not create), "tmpfs" (create as
   * tmpfs), and "anonymous" (create as anonymous volumes).
   * The default if unset is anonymous.
   * Optional.
   */
  image_volume_mode?: string;
  /**
   * Image volumes bind-mount a container-image mount into the container.
   * Optional.
   */
  image_volumes?: Array<ImageVolume>;
  /**
   * Init specifies that an init binary will be mounted into the
   * container, and will be used as PID1.
   * Optional.
   */
  init?: boolean;
  /**
   * InitPath specifies the path to the init binary that will be added if
   * Init is specified above. If not specified, the default set in the
   * Libpod config will be used. Ignored if Init above is not set.
   * Optional.
   */
  init_path?: string;
  ipcns?: Namespace;
  /**
   * Mounts are mounts that will be added to the container.
   * These will supersede Image Volumes and VolumesFrom volumes where
   * there are conflicts.
   * Optional.
   */
  mounts?: Array<Mount>;
  /**
   * Overlay volumes are named volumes that will be added to the container.
   * Optional.
   */
  overlay_volumes?: Array<OverlayVolume>;
  /**
   * RawImageName is the user-specified and unprocessed input referring
   * to a local or a remote image.
   * Optional, but strongly encouraged to be set if Image is set.
   */
  raw_image_name?: string;
  /**
   * Rootfs is the path to a directory that will be used as the
   * container's root filesystem. No modification will be made to the
   * directory, it will be directly mounted into the container as root.
   * Conflicts with Image.
   * At least one of Image or Rootfs must be specified.
   */
  rootfs?: string;
  /**
   * RootfsMapping specifies if there are UID/GID mappings to apply to the rootfs.
   * Optional.
   */
  rootfs_mapping?: string;
  /**
   * RootfsOverlay tells if rootfs is actually an overlay on top of base path.
   * Optional.
   */
  rootfs_overlay?: boolean;
  /**
   * RootfsPropagation is the rootfs propagation mode for the container.
   * If not set, the default of rslave will be used.
   * Optional.
   */
  rootfs_propagation?: string;
  /**
   * Secrets are the secrets that will be added to the container
   * Optional.
   */
  secrets?: Array<Secret>;
  /**
   * ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes.
   * Conflicts with ShmSize if IpcNS is not private.
   * Optional.
   */
  shm_size?: number;
  /**
   * ShmSizeSystemd is the size of systemd-specific tmpfs mounts
   * specifically /run, /run/lock, /var/log/journal and /tmp.
   * Optional
   */
  shm_size_systemd?: number;
  /**
   * StorageOpts is the container's storage options
   * Optional.
   */
  storage_opts?: {
    [key: string]: string;
  };
  /**
   * Volatile specifies whether the container storage can be optimized
   * at the cost of not syncing all the dirty files in memory.
   * Optional.
   */
  volatile?: boolean;
  /**
   * Volumes are named volumes that will be added to the container.
   * These will supersede Image Volumes and VolumesFrom volumes where
   * there are conflicts.
   * Optional.
   */
  volumes?: Array<NamedVolume>;
  /**
   * VolumesFrom is a set of containers whose volumes will be added to
   * this container. The name or ID of the container must be provided, and
   * may optionally be followed by a : and then one or more
   * comma-separated options. Valid options are 'ro', 'rw', and 'z'.
   * Options will be used for all volumes sourced from the container.
   * Optional.
   */
  volumes_from?: Array<string>;
  /**
   * WorkDir is the container's working directory.
   * If unset, the default, /, will be used.
   * Optional.
   */
  work_dir?: string;
};

/**
 * ContainerStore describes the quantity of containers in the
 * store by status
 */
export type ContainerStore = {
  number?: number;
  paused?: number;
  running?: number;
  stopped?: number;
};

export type ContainerTopOkBody = {
  /**
   * Each process running in the container, where each process
   * is an array of values corresponding to the titles.
   */
  Processes?: Array<Array<string>>;
  /**
   * The ps column titles
   */
  Titles?: Array<string>;
};

export type ContainersPruneReport = {
  ContainersDeleted?: Array<string>;
  SpaceReclaimed?: number;
};

export type ContainersPruneReportLibpod = {
  /**
   * Error which occurred during prune operation (if any).
   * This field is optional and may be omitted if no error occurred.
   */
  Err?: string | null;
  Id?: string;
  Size?: number;
};

/**
 * CreateContainerConfig used when compatible endpoint creates a container
 */
export type CreateContainerConfig = {
  ArgsEscaped?: boolean;
  AttachStderr?: boolean;
  AttachStdin?: boolean;
  AttachStdout?: boolean;
  Cmd?: StrSlice;
  Domainname?: string;
  Entrypoint?: StrSlice;
  Env?: Array<string>;
  EnvMerge?: Array<string>;
  ExposedPorts?: PortSet;
  Healthcheck?: HealthcheckConfig;
  HostConfig?: HostConfig;
  Hostname?: string;
  Image?: string;
  Labels?: {
    [key: string]: string;
  };
  /**
   * Mac Address of the container.
   *
   * Deprecated: this field is deprecated since API v1.44. Use EndpointSettings.MacAddress instead.
   */
  MacAddress?: string;
  Name?: string;
  NetworkDisabled?: boolean;
  NetworkingConfig?: NetworkingConfig;
  OnBuild?: Array<string>;
  OpenStdin?: boolean;
  Shell?: StrSlice;
  StdinOnce?: boolean;
  StopSignal?: string;
  StopTimeout?: number;
  Tty?: boolean;
  UnsetEnv?: Array<string>;
  UnsetEnvAll?: boolean;
  User?: string;
  Volumes?: {
    [key: string]: {
      [key: string]: unknown;
    };
  };
  WorkingDir?: string;
};

/**
 * CreateOptions holds options to create a network.
 */
export type CreateOptions = {
  Attachable?: boolean;
  ConfigFrom?: ConfigReference;
  ConfigOnly?: boolean;
  /**
   * Name of the volume driver to use.
   */
  Driver?: string;
  EnableIPv4?: boolean;
  EnableIPv6?: boolean;
  IPAM?: Ipam;
  Ingress?: boolean;
  Internal?: boolean;
  /**
   * User-defined key/value metadata.
   */
  Labels?: {
    [key: string]: string;
  };
  Options?: {
    [key: string]: string;
  };
  Scope?: string;
};

/**
 * CreateRequest is the request message sent to the server for network create call.
 */
export type CreateRequest = {
  Attachable?: boolean;
  /**
   * Deprecated: CheckDuplicate is deprecated since API v1.44, but it defaults to true when sent by the client
   * package to older daemons.
   */
  CheckDuplicate?: boolean;
  ConfigFrom?: ConfigReference;
  ConfigOnly?: boolean;
  Driver?: string;
  EnableIPv4?: boolean;
  EnableIPv6?: boolean;
  IPAM?: Ipam;
  Ingress?: boolean;
  Internal?: boolean;
  Labels?: {
    [key: string]: string;
  };
  Name?: string;
  Options?: {
    [key: string]: string;
  };
  Scope?: string;
};

/**
 * CreateResponse ContainerCreateResponse
 * OK response to ContainerCreate operation
 */
export type CreateResponse = {
  /**
   * The ID of the created container
   */
  Id: string;
  /**
   * Warnings encountered when creating the container
   */
  Warnings: Array<string>;
};

/**
 * NetworkInfo contains the DNS information.
 */
export type DnsNetworkInfo = {
  package?: string;
  path?: string;
  version?: string;
};

/**
 * DeleteResponse delete response
 */
export type DeleteResponse = {
  /**
   * The image ID of an image that was deleted
   */
  Deleted?: string;
  /**
   * The image ID of an image that was untagged
   */
  Untagged?: string;
};

/**
 * Descriptor describes the disposition of targeted content.
 * This structure provides `application/vnd.oci.descriptor.v1+json` mediatype
 * when marshalled to JSON.
 */
export type Descriptor = {
  /**
   * Annotations contains arbitrary metadata relating to the targeted content.
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * ArtifactType is the IANA media type of this artifact.
   */
  artifactType?: string;
  /**
   * Data is an embedding of the targeted content. This is encoded as a base64
   * string when marshalled to JSON (automatically, by encoding/json). If
   * present, Data can be used directly to avoid fetching the targeted content.
   */
  data?: Array<number>;
  digest?: Digest;
  /**
   * MediaType is the media type of the object this schema refers to.
   */
  mediaType?: string;
  platform?: Platform;
  /**
   * Size specifies the size in bytes of the blob.
   */
  size?: number;
  /**
   * URLs specifies a list of URLs from which this object MAY be downloaded
   */
  urls?: Array<string>;
};

/**
 * DeviceMapping represents the device mapping between the host and the container.
 */
export type DeviceMapping = {
  CgroupPermissions?: string;
  PathInContainer?: string;
  PathOnHost?: string;
};

/**
 * DeviceRequest represents a request for devices from a device driver.
 * Used by GPU device drivers.
 */
export type DeviceRequest = {
  Capabilities?: Array<Array<string>>;
  Count?: number;
  DeviceIDs?: Array<string>;
  Driver?: string;
  Options?: {
    [key: string]: string;
  };
};

/**
 * Digest allows simple protection of hex formatted digest strings, prefixed
 * by their algorithm. Strings of type Digest have some guarantee of being in
 * the correct format and it provides quick access to the components of a
 * digest string.
 * The following is an example of the contents of Digest types:
 *
 * sha256:7173b809ca12ec5dee4506cd86be934c4596dd234ee82c0662eac04a8c2c71dc
 *
 * This allows to abstract the digest behind this type and work only in those
 * terms.
 */
export type Digest = string;

/**
 * DisconnectOptions represents the data to be used to disconnect a container
 * from the network.
 */
export type DisconnectOptions = {
  Container?: string;
  Force?: boolean;
};

/**
 * DistributionInfo describes the host distribution for libpod
 */
export type DistributionInfo = {
  codename?: string;
  distribution?: string;
  variant?: string;
  version?: string;
};

/**
 * Driver represents a volume driver.
 */
export type Driver = {
  Name?: string;
  Options?: {
    [key: string]: string;
  };
};

/**
 * DriverData Information about the storage driver used to store the container's and
 * image's filesystem.
 */
export type DriverData = {
  /**
   * Low-level storage metadata, provided as key/value pairs.
   *
   * This information is driver-specific, and depends on the storage-driver
   * in use, and should be used for informational purposes only.
   */
  Data: {
    [key: string]: string;
  };
  /**
   * Name of the storage driver.
   */
  Name: string;
};

/**
 * A Duration represents the elapsed time between two instants
 * as an int64 nanosecond count. The representation limits the
 * largest representable duration to approximately 290 years.
 */
export type Duration = number;

/**
 * EndpointIPAMConfig represents IPAM configurations for the endpoint
 */
export type EndpointIpamConfig = {
  IPv4Address?: string;
  IPv6Address?: string;
  LinkLocalIPs?: Array<string>;
};

/**
 * EndpointResource contains network resources allocated and used for a
 * container in a network.
 */
export type EndpointResource = {
  EndpointID?: string;
  IPv4Address?: string;
  IPv6Address?: string;
  MacAddress?: string;
  Name?: string;
};

/**
 * EndpointSettings stores the network endpoint details
 */
export type EndpointSettings = {
  Aliases?: Array<string>;
  /**
   * DNSNames holds all the (non fully qualified) DNS names associated to this endpoint. First entry is used to
   * generate PTR records.
   */
  DNSNames?: Array<string>;
  DriverOpts?: {
    [key: string]: string;
  };
  EndpointID?: string;
  Gateway?: string;
  GlobalIPv6Address?: string;
  GlobalIPv6PrefixLen?: number;
  /**
   * GwPriority determines which endpoint will provide the default gateway
   * for the container. The endpoint with the highest priority will be used.
   * If multiple endpoints have the same priority, they are lexicographically
   * sorted based on their network name, and the one that sorts first is picked.
   */
  GwPriority?: number;
  IPAMConfig?: EndpointIpamConfig;
  IPAddress?: string;
  IPPrefixLen?: number;
  IPv6Gateway?: string;
  Links?: Array<string>;
  /**
   * MacAddress may be used to specify a MAC address when the container is created.
   * Once the container is running, it becomes operational data (it may contain a
   * generated address).
   */
  MacAddress?: string;
  /**
   * Operational data
   */
  NetworkID?: string;
};

/**
 * ErrorModel is used in remote connections with podman
 */
export type ErrorModel = {
  /**
   * API root cause formatted for automated parsing
   */
  cause?: string;
  /**
   * human error message, formatted for a human to read
   */
  message?: string;
  /**
   * HTTP response code
   */
  response?: number;
};

/**
 * ErrorResponse Represents an error.
 */
export type ErrorResponse = {
  /**
   * The error message.
   */
  message: string;
};

/**
 * A FileMode represents a file's mode and permission bits.
 * The bits have the same definition on all systems, so that
 * information about files can be moved from one system
 * to another portably. Not all bits apply to all systems.
 * The only required bit is [ModeDir] for directories.
 */
export type FileMode = number;

/**
 * FilesystemChange Change in the container's filesystem.
 */
export type FilesystemChange = {
  Kind: ChangeType;
  /**
   * Path to file or directory that has changed.
   */
  Path: string;
};

/**
 * A HardwareAddr represents a physical hardware address.
 */
export type HardwareAddr = Array<number>;

/**
 * Health stores information about the container's healthcheck results
 */
export type Health = {
  FailingStreak?: number;
  Log?: Array<HealthcheckResult>;
  Status?: string;
};

/**
 * HealthCheckLog describes the results of a single healthcheck
 */
export type HealthCheckLog = {
  /**
   * End time as a string
   */
  End?: string;
  /**
   * Exitcode is 0 or 1
   */
  ExitCode?: number;
  /**
   * Output is the stdout/stderr from the healthcheck command
   */
  Output?: string;
  /**
   * Start time as string
   */
  Start?: string;
};

/**
 * HealthCheckOnFailureAction defines how Podman reacts when a container's health
 * status turns unhealthy.
 */
export type HealthCheckOnFailureAction = number;

/**
 * HealthCheckResults describes the results/logs from a healthcheck
 */
export type HealthCheckResults = {
  /**
   * FailingStreak is the number of consecutive failed healthchecks
   */
  FailingStreak?: number;
  /**
   * Log describes healthcheck attempts and results
   */
  Log?: Array<HealthCheckLog>;
  /**
   * Status starting, healthy or unhealthy
   */
  Status?: string;
};

/**
 * HealthcheckConfig holds configuration settings for the HEALTHCHECK feature.
 */
export type HealthcheckConfig = {
  Interval?: Duration;
  /**
   * Retries is the number of consecutive failures needed to consider a container as unhealthy.
   * Zero means inherit.
   */
  Retries?: number;
  StartInterval?: Duration;
  StartPeriod?: Duration;
  /**
   * Test is the test to perform to check that the container is healthy.
   * An empty slice means to inherit the default.
   * The options are:
   * {} : inherit healthcheck
   * {"NONE"} : disable healthcheck
   * {"CMD", args...} : exec arguments directly
   * {"CMD-SHELL", command} : run command with system's default shell
   */
  Test?: Array<string>;
  Timeout?: Duration;
};

/**
 * HealthcheckResult stores information about a single run of a healthcheck probe
 */
export type HealthcheckResult = {
  End?: string;
  ExitCode?: number;
  Output?: string;
  Start?: string;
};

/**
 * History describes the history of a layer.
 */
export type History = {
  /**
   * Author is the author of the build point.
   */
  author?: string;
  /**
   * Comment is a custom message set when creating the layer.
   */
  comment?: string;
  /**
   * Created is the combined date and time at which the layer was created, formatted as defined by RFC 3339, section 5.6.
   */
  created?: string;
  /**
   * CreatedBy is the command which created the layer.
   */
  created_by?: string;
  /**
   * EmptyLayer is used to mark if the history item created a filesystem diff.
   */
  empty_layer?: boolean;
};

/**
 * HistoryResponse provides details on image layers
 */
export type HistoryResponse = {
  Comment?: string;
  Created?: number;
  CreatedBy?: string;
  Id?: string;
  Size?: number;
  Tags?: Array<string>;
};

/**
 * HistoryResponseItem individual image layer information in response to ImageHistory operation
 */
export type HistoryResponseItem = {
  /**
   * comment
   */
  Comment: string;
  /**
   * created
   */
  Created: number;
  /**
   * created by
   */
  CreatedBy: string;
  /**
   * Id
   */
  Id: string;
  /**
   * size
   */
  Size: number;
  /**
   * tags
   */
  Tags: Array<string>;
};

/**
 * HostConfig the non-portable Config structure of a container.
 * Here, "non-portable" means "dependent of the host we are running on".
 * Portable information *should* appear in Config.
 */
export type HostConfig = {
  Annotations?: {
    [key: string]: string;
  };
  AutoRemove?: boolean;
  /**
   * Applicable to all platforms
   */
  Binds?: Array<string>;
  BlkioDeviceReadBps?: Array<ThrottleDevice>;
  BlkioDeviceReadIOps?: Array<ThrottleDevice>;
  BlkioDeviceWriteBps?: Array<ThrottleDevice>;
  BlkioDeviceWriteIOps?: Array<ThrottleDevice>;
  BlkioWeight?: number;
  BlkioWeightDevice?: Array<WeightDevice>;
  CapAdd?: StrSlice;
  CapDrop?: StrSlice;
  Cgroup?: CgroupSpec;
  /**
   * Applicable to UNIX platforms
   */
  CgroupParent?: string;
  CgroupnsMode?: CgroupnsMode;
  ConsoleSize?: Array<number>;
  ContainerIDFile?: string;
  /**
   * Applicable to Windows
   */
  CpuCount?: number;
  CpuPercent?: number;
  CpuPeriod?: number;
  CpuQuota?: number;
  CpuRealtimePeriod?: number;
  CpuRealtimeRuntime?: number;
  /**
   * Applicable to all platforms
   */
  CpuShares?: number;
  CpusetCpus?: string;
  CpusetMems?: string;
  DeviceCgroupRules?: Array<string>;
  DeviceRequests?: Array<DeviceRequest>;
  Devices?: Array<DeviceMapping>;
  Dns?: Array<string>;
  DnsOptions?: Array<string>;
  DnsSearch?: Array<string>;
  ExtraHosts?: Array<string>;
  GroupAdd?: Array<string>;
  IOMaximumBandwidth?: number;
  IOMaximumIOps?: number;
  /**
   * Run a custom init inside the container, if null, use the daemon's configured settings
   */
  Init?: boolean;
  IpcMode?: IpcMode;
  Isolation?: Isolation;
  /**
   * KernelMemory specifies the kernel memory limit (in bytes) for the container.
   * Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
   */
  KernelMemory?: number;
  KernelMemoryTCP?: number;
  Links?: Array<string>;
  LogConfig?: LogConfig;
  /**
   * MaskedPaths is the list of paths to be masked inside the container (this overrides the default set of paths)
   */
  MaskedPaths?: Array<string>;
  Memory?: number;
  MemoryReservation?: number;
  MemorySwap?: number;
  MemorySwappiness?: number;
  /**
   * Mounts specs used by the container
   */
  Mounts?: Array<Mount>;
  NanoCpus?: number;
  NetworkMode?: NetworkMode;
  OomKillDisable?: boolean;
  OomScoreAdj?: number;
  PidMode?: PidMode;
  PidsLimit?: number;
  PortBindings?: PortMap;
  Privileged?: boolean;
  PublishAllPorts?: boolean;
  /**
   * ReadonlyPaths is the list of paths to be set as read-only inside the container (this overrides the default set of paths)
   */
  ReadonlyPaths?: Array<string>;
  ReadonlyRootfs?: boolean;
  RestartPolicy?: RestartPolicy;
  Runtime?: string;
  SecurityOpt?: Array<string>;
  ShmSize?: number;
  StorageOpt?: {
    [key: string]: string;
  };
  Sysctls?: {
    [key: string]: string;
  };
  Tmpfs?: {
    [key: string]: string;
  };
  UTSMode?: UtsMode;
  Ulimits?: Array<Ulimit>;
  UsernsMode?: UsernsMode;
  VolumeDriver?: string;
  VolumesFrom?: Array<string>;
};

/**
 * HostInfo describes the libpod host
 */
export type HostInfo = {
  arch?: string;
  buildahVersion?: string;
  cgroupControllers?: Array<string>;
  cgroupManager?: string;
  cgroupVersion?: string;
  conmon?: ConmonInfo;
  cpuUtilization?: CpuUsage;
  cpus?: number;
  databaseBackend?: string;
  distribution?: DistributionInfo;
  eventLogger?: string;
  freeLocks?: number;
  hostname?: string;
  idMappings?: IdMappings;
  kernel?: string;
  linkmode?: string;
  logDriver?: string;
  memFree?: number;
  memTotal?: number;
  networkBackend?: string;
  networkBackendInfo?: NetworkInfo;
  ociRuntime?: OciRuntimeInfo;
  os?: string;
  pasta?: PastaInfo;
  remoteSocket?: RemoteSocket;
  /**
   * RootlessNetworkCmd returns the default rootless network command (slirp4netns or pasta)
   */
  rootlessNetworkCmd?: string;
  runtimeInfo?: {
    [key: string]: unknown;
  };
  security?: SecurityInfo;
  /**
   * ServiceIsRemote is true when the podman/libpod service is remote to the client
   */
  serviceIsRemote?: boolean;
  slirp4netns?: SlirpInfo;
  swapFree?: number;
  swapTotal?: number;
  uptime?: string;
  variant?: string;
};

/**
 * IDMap contains a single entry for user namespace range remapping. An array
 * of IDMap entries represents the structure that will be provided to the Linux
 * kernel for creating a user namespace.
 */
export type IdMap = {
  container_id?: number;
  host_id?: number;
  size?: number;
};

/**
 * IDMappingOptions are used for specifying how ID mapping should be set up for
 * a layer or container.
 */
export type IdMappingOptions = {
  AutoUserNs?: boolean;
  AutoUserNsOpts?: AutoUserNsOptions;
  GIDMap?: Array<IdMap>;
  HostGIDMapping?: boolean;
  /**
   * UIDMap and GIDMap are used for setting up a layer's root filesystem
   * for use inside of a user namespace where ID mapping is being used.
   * If HostUIDMapping/HostGIDMapping is true, no mapping of the
   * respective type will be used.  Otherwise, if UIDMap and/or GIDMap
   * contain at least one mapping, one or both will be used.  By default,
   * if neither of those conditions apply, if the layer has a parent
   * layer, the parent layer's mapping will be used, and if it does not
   * have a parent layer, the mapping which was passed to the Store
   * object when it was initialized will be used.
   */
  HostUIDMapping?: boolean;
  UIDMap?: Array<IdMap>;
};

/**
 * IDMappings describe the GID and UID mappings
 */
export type IdMappings = {
  gidmap?: Array<IdMap>;
  uidmap?: Array<IdMap>;
};

export type IdResponse = {
  /**
   * The id of the newly created object.
   */
  Id: string;
};

/**
 * IPAM represents IP Address Management
 */
export type Ipam = {
  Config?: Array<IpamConfig>;
  Driver?: string;
  Options?: {
    [key: string]: string;
  };
};

/**
 * IPAMConfig represents IPAM configurations
 */
export type IpamConfig = {
  AuxiliaryAddresses?: {
    [key: string]: string;
  };
  Gateway?: string;
  IPRange?: string;
  Subnet?: string;
};

/**
 * An IPMask is a bitmask that can be used to manipulate
 * IP addresses for IP addressing and routing.
 * See type [IPNet] and func [ParseCIDR] for details.
 */
export type IpMask = Array<number>;

/**
 * An IPNet represents an IP network.
 */
export type IpNet = {
  IP?: string;
  Mask?: IpMask;
};

/**
 * ImageConfig defines the execution parameters which should be used as a base when running a container using an image.
 */
export type ImageConfig = {
  /**
   * ArgsEscaped
   *
   * Deprecated: This field is present only for legacy compatibility with
   * Docker and should not be used by new image builders.  It is used by Docker
   * for Windows images to indicate that the `Entrypoint` or `Cmd` or both,
   * contains only a single element array, that is a pre-escaped, and combined
   * into a single string `CommandLine`. If `true` the value in `Entrypoint` or
   * `Cmd` should be used as-is to avoid double escaping.
   * https://github.com/opencontainers/image-spec/pull/892
   */
  ArgsEscaped?: boolean;
  /**
   * Cmd defines the default arguments to the entrypoint of the container.
   */
  Cmd?: Array<string>;
  /**
   * Entrypoint defines a list of arguments to use as the command to execute when the container starts.
   */
  Entrypoint?: Array<string>;
  /**
   * Env is a list of environment variables to be used in a container.
   */
  Env?: Array<string>;
  /**
   * ExposedPorts a set of ports to expose from a container running this image.
   */
  ExposedPorts?: {
    [key: string]: {
      [key: string]: unknown;
    };
  };
  /**
   * Labels contains arbitrary metadata for the container.
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * StopSignal contains the system call signal that will be sent to the container to exit.
   */
  StopSignal?: string;
  /**
   * User defines the username or UID which the process in the container should run as.
   */
  User?: string;
  /**
   * Volumes is a set of directories describing where the process is likely write data specific to a container instance.
   */
  Volumes?: {
    [key: string]: {
      [key: string]: unknown;
    };
  };
  /**
   * WorkingDir sets the current working directory of the entrypoint process in the container.
   */
  WorkingDir?: string;
};

/**
 * ImageData holds the inspect information of an image.
 */
export type ImageData = {
  Annotations?: {
    [key: string]: string;
  };
  Architecture?: string;
  Author?: string;
  Comment?: string;
  Config?: ImageConfig;
  Created?: string;
  Digest?: Digest;
  GraphDriver?: DriverData;
  Healthcheck?: Schema2HealthConfig;
  History?: Array<History>;
  Id?: string;
  Labels?: {
    [key: string]: string;
  };
  ManifestType?: string;
  NamesHistory?: Array<string>;
  Os?: string;
  Parent?: string;
  RepoDigests?: Array<string>;
  RepoTags?: Array<string>;
  RootFS?: RootFs;
  Size?: number;
  User?: string;
  Version?: string;
  VirtualSize?: number;
};

export type ImageImportReport = {
  Id?: string;
};

export type ImageInspect = {
  /**
   * Architecture is the hardware CPU architecture that the image runs on.
   */
  Architecture?: string;
  /**
   * Author is the name of the author that was specified when committing the
   * image, or as specified through MAINTAINER (deprecated) in the Dockerfile.
   */
  Author?: string;
  /**
   * Comment is an optional message that can be set when committing or
   * importing the image.
   */
  Comment?: string;
  Config?: Config;
  /**
   * Container is for backwards compat but is basically unused
   */
  Container?: string;
  ContainerConfig?: Config;
  /**
   * Created is the date and time at which the image was created, formatted in
   * RFC 3339 nano-seconds (time.RFC3339Nano).
   *
   * This information is only available if present in the image,
   * and omitted otherwise.
   */
  Created?: string;
  Descriptor?: Descriptor;
  /**
   * DockerVersion is the version of Docker that was used to build the image.
   *
   * Depending on how the image was created, this field may be empty.
   */
  DockerVersion?: string;
  GraphDriver?: DriverData;
  /**
   * ID is the content-addressable ID of an image.
   *
   * This identifier is a content-addressable digest calculated from the
   * image's configuration (which includes the digests of layers used by
   * the image).
   *
   * Note that this digest differs from the `RepoDigests` below, which
   * holds digests of image manifests that reference the image.
   */
  Id?: string;
  /**
   * Manifests is a list of image manifests available in this image. It
   * provides a more detailed view of the platform-specific image manifests or
   * other image-attached data like build attestations.
   *
   * Only available if the daemon provides a multi-platform image store, the client
   * requests manifests AND does not request a specific platform.
   *
   * WARNING: This is experimental and may change at any time without any backward
   * compatibility.
   */
  Manifests?: Array<ManifestSummary>;
  Metadata?: Metadata;
  /**
   * OS is the Operating System the image is built to run on.
   */
  Os?: string;
  /**
   * OsVersion is the version of the Operating System the image is built to
   * run on (especially for Windows).
   */
  OsVersion?: string;
  /**
   * Parent is the ID of the parent image.
   *
   * Depending on how the image was created, this field may be empty and
   * is only set for images that were built/created locally. This field
   * is empty if the image was pulled from an image registry.
   */
  Parent?: string;
  /**
   * RepoDigests is a list of content-addressable digests of locally available
   * image manifests that the image is referenced from. Multiple manifests can
   * refer to the same image.
   *
   * These digests are usually only available if the image was either pulled
   * from a registry, or if the image was pushed to a registry, which is when
   * the manifest is generated and its digest calculated.
   */
  RepoDigests?: Array<string>;
  /**
   * RepoTags is a list of image names/tags in the local image cache that
   * reference this image.
   *
   * Multiple image tags can refer to the same image, and this list may be
   * empty if no tags reference the image, in which case the image is
   * "untagged", in which case it can still be referenced by its ID.
   */
  RepoTags?: Array<string>;
  RootFS?: RootFs;
  /**
   * Size is the total size of the image including all layers it is composed of.
   */
  Size?: number;
  /**
   * Variant is the CPU architecture variant (presently ARM-only).
   */
  Variant?: string;
  /**
   * VirtualSize is the total size of the image including all layers it is
   * composed of.
   *
   * Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
   */
  VirtualSize?: number;
};

export type ImageLoadReport = {
  Names?: Array<string>;
};

export type ImageOptions = {
  Subpath?: string;
};

export type ImageProperties = {
  /**
   * Containers is an array containing the IDs of the containers that are
   * using this image.
   */
  Containers: Array<string>;
  Platform: Platform;
  Size?: {
    /**
     * Unpacked is the size (in bytes) of the locally unpacked
     * (uncompressed) image content that's directly usable by the containers
     * running this image.
     * It's independent of the distributable content - e.g.
     * the image might still have an unpacked data that's still used by
     * some container even when the distributable/compressed content is
     * already gone.
     */
    Unpacked: number;
  };
};

/**
 * ImageStore describes the image store.  Right now only the number
 * of images present
 */
export type ImageStore = {
  number?: number;
};

export type ImageTreeReport = {
  Tree?: string;
};

/**
 * ImageVolume is a volume based on a container image.  The container image is
 * first mounted on the host and is then bind-mounted into the container.  An
 * ImageVolume is always mounted read-only.
 */
export type ImageVolume = {
  /**
   * Destination is the absolute path of the mount in the container.
   */
  Destination?: string;
  /**
   * ReadWrite sets the volume writable.
   */
  ReadWrite?: boolean;
  /**
   * Source is the source of the image volume.  The image can be referred
   * to by name and by ID.
   */
  Source?: string;
  /**
   * SubPath mounts a particular path within the image.
   * If empty, the whole image is mounted.
   */
  subPath?: string;
};

/**
 * Info contains information about the Volume as a whole as provided by
 * the CSI storage plugin.
 */
export type Info = {
  /**
   * AccessibleTopology is the topology this volume is actually accessible
   * from.
   */
  AccessibleTopology?: Array<Topology>;
  /**
   * CapacityBytes is the capacity of the volume in bytes. A value of 0
   * indicates that the capacity is unknown.
   */
  CapacityBytes?: number;
  /**
   * VolumeContext is the context originating from the CSI storage plugin
   * when the Volume is created.
   */
  VolumeContext?: {
    [key: string]: string;
  };
  /**
   * VolumeID is the ID of the Volume as seen by the CSI storage plugin. This
   * is distinct from the Volume's Swarm ID, which is the ID used by all of
   * the Docker Engine to refer to the Volume. If this field is blank, then
   * the Volume has not been successfully created yet.
   */
  VolumeID?: string;
};

/**
 * Inspect is the body of the "get network" http response message.
 */
export type Inspect = {
  Attachable?: boolean;
  ConfigFrom?: ConfigReference;
  ConfigOnly?: boolean;
  Containers?: {
    [key: string]: EndpointResource;
  };
  Created?: string;
  Driver?: string;
  EnableIPv4?: boolean;
  EnableIPv6?: boolean;
  IPAM?: Ipam;
  Id?: string;
  Ingress?: boolean;
  Internal?: boolean;
  Labels?: {
    [key: string]: string;
  };
  Name?: string;
  Options?: {
    [key: string]: string;
  };
  Peers?: Array<PeerInfo>;
  Scope?: string;
  Services?: {
    [key: string]: ServiceInfo;
  };
};

/**
 * InspectAdditionalNetwork holds information about non-default networks the
 * container has been connected to.
 * As with InspectNetworkSettings, many fields are unused and maintained only
 * for compatibility with Docker.
 */
export type InspectAdditionalNetwork = {
  /**
   * AdditionalMacAddresses is a set of additional MAC Addresses beyond
   * the first. CNI may configure more than one interface for a single
   * network, which can cause this.
   */
  AdditionalMACAddresses?: Array<string>;
  /**
   * Aliases are any network aliases the container has in this network.
   */
  Aliases?: Array<string>;
  /**
   * DriverOpts is presently unused and maintained exclusively for
   * compatibility.
   */
  DriverOpts?: {
    [key: string]: string;
  };
  /**
   * EndpointID is unused, maintained exclusively for compatibility.
   */
  EndpointID?: string;
  /**
   * Gateway is the IP address of the gateway this network will use.
   */
  Gateway?: string;
  /**
   * GlobalIPv6Address is the global-scope IPv6 Address for this network.
   */
  GlobalIPv6Address?: string;
  /**
   * GlobalIPv6PrefixLen is the length of the subnet mask of this network.
   */
  GlobalIPv6PrefixLen?: number;
  /**
   * IPAMConfig is presently unused and maintained exclusively for
   * compatibility.
   */
  IPAMConfig?: {
    [key: string]: string;
  };
  /**
   * IPAddress is the IP address for this network.
   */
  IPAddress?: string;
  /**
   * IPPrefixLen is the length of the subnet mask of this network.
   */
  IPPrefixLen?: number;
  /**
   * IPv6Gateway is the IPv6 gateway this network will use.
   */
  IPv6Gateway?: string;
  /**
   * Links is presently unused and maintained exclusively for
   * compatibility.
   */
  Links?: Array<string>;
  /**
   * MacAddress is the MAC address for the interface in this network.
   */
  MacAddress?: string;
  /**
   * Name of the network we're connecting to.
   */
  NetworkID?: string;
  /**
   * SecondaryIPAddresses is a list of extra IP Addresses that the
   * container has been assigned in this network.
   */
  SecondaryIPAddresses?: Array<Address>;
  /**
   * SecondaryIPv6Addresses is a list of extra IPv6 Addresses that the
   * container has been assigned in this network.
   */
  SecondaryIPv6Addresses?: Array<Address>;
};

/**
 * InspectBlkioThrottleDevice holds information about a speed cap for a device
 * node. This cap applies to a specific operation (read, write, etc) on the given
 * node.
 */
export type InspectBlkioThrottleDevice = {
  /**
   * Path is the path to the device this applies to.
   */
  Path?: string;
  /**
   * Rate is the maximum rate. It is in either bytes per second or iops
   * per second, determined by where it is used - documentation will
   * indicate which is appropriate.
   */
  Rate?: number;
};

/**
 * InspectBlkioWeightDevice holds information about the relative weight
 * of an individual device node. Weights are used in the I/O scheduler to give
 * relative priority to some accesses.
 */
export type InspectBlkioWeightDevice = {
  /**
   * Path is the path to the device this applies to.
   */
  Path?: string;
  /**
   * Weight is the relative weight the scheduler will use when scheduling
   * I/O.
   */
  Weight?: number;
};

/**
 * InspectContainerConfig holds further data about how a container was initially
 * configured.
 */
export type InspectContainerConfig = {
  /**
   * Container annotations
   */
  Annotations?: {
    [key: string]: string;
  };
  /**
   * Unused, at present
   */
  AttachStderr?: boolean;
  /**
   * Unused, at present
   */
  AttachStdin?: boolean;
  /**
   * Unused, at present
   */
  AttachStdout?: boolean;
  /**
   * ChrootDirs is an additional set of directories that need to be
   * treated as root directories. Standard bind mounts will be mounted
   * into paths relative to these directories.
   */
  ChrootDirs?: Array<string>;
  /**
   * Container command
   */
  Cmd?: Array<string>;
  /**
   * CreateCommand is the full command plus arguments of the process the
   * container has been created with.
   */
  CreateCommand?: Array<string>;
  /**
   * Container domain name - unused at present
   */
  Domainname?: string;
  /**
   * Container entrypoint
   */
  Entrypoint?: Array<string>;
  /**
   * Container environment variables
   */
  Env?: Array<string>;
  /**
   * ExposedPorts includes ports the container has exposed.
   */
  ExposedPorts?: {
    [key: string]: {
      [key: string]: unknown;
    };
  };
  /**
   * HealthLogDestination defines the destination where the log is stored
   */
  HealthLogDestination?: string;
  Healthcheck?: Schema2HealthConfig;
  /**
   * HealthMaxLogCount is maximum number of attempts in the HealthCheck log file.
   * ('0' value means an infinite number of attempts in the log file)
   */
  HealthcheckMaxLogCount?: number;
  /**
   * HealthMaxLogSize is the maximum length in characters of stored HealthCheck log
   * ("0" value means an infinite log length)
   */
  HealthcheckMaxLogSize?: number;
  /**
   * HealthcheckOnFailureAction defines an action to take once the container turns unhealthy.
   */
  HealthcheckOnFailureAction?: string;
  /**
   * Container hostname
   */
  Hostname?: string;
  /**
   * Container image
   */
  Image?: string;
  /**
   * Container labels
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * On-build arguments - presently unused. More of Buildah's domain.
   */
  OnBuild?: string;
  /**
   * Whether the container leaves STDIN open
   */
  OpenStdin?: boolean;
  /**
   * Passwd determines whether or not podman can add entries to /etc/passwd and /etc/group
   */
  Passwd?: boolean;
  /**
   * Secrets are the secrets mounted in the container
   */
  Secrets?: Array<InspectSecret>;
  StartupHealthCheck?: StartupHealthCheck;
  /**
   * Whether STDIN is only left open once.
   * Presently not supported by Podman, unused.
   */
  StdinOnce?: boolean;
  /**
   * Container stop signal
   */
  StopSignal?: string;
  /**
   * StopTimeout is time before container is stopped when calling stop
   */
  StopTimeout?: number;
  /**
   * SystemdMode is whether the container is running in systemd mode. In
   * systemd mode, the container configuration is customized to optimize
   * running systemd in the container.
   */
  SystemdMode?: boolean;
  /**
   * Timeout is time before container is killed by conmon
   */
  Timeout?: number;
  /**
   * Timezone is the timezone inside the container.
   * Local means it has the same timezone as the host machine
   */
  Timezone?: string;
  /**
   * Whether the container creates a TTY
   */
  Tty?: boolean;
  /**
   * Umask is the umask inside the container.
   */
  Umask?: string;
  /**
   * User the container was launched with
   */
  User?: string;
  /**
   * Unused, at present. I've never seen this field populated.
   */
  Volumes?: {
    [key: string]: {
      [key: string]: unknown;
    };
  };
  /**
   * Container working directory
   */
  WorkingDir?: string;
  /**
   * SdNotifyMode is the sd-notify mode of the container.
   */
  sdNotifyMode?: string;
  /**
   * SdNotifySocket is the NOTIFY_SOCKET in use by/configured for the container.
   */
  sdNotifySocket?: string;
};

/**
 * InspectContainerData provides a detailed record of a container's configuration
 * and state as viewed by Libpod.
 * Large portions of this structure are defined such that the output is
 * compatible with `docker inspect` JSON, but additional fields have been added
 * as required to share information not in the original output.
 */
export type InspectContainerData = {
  AppArmorProfile?: string;
  Args?: Array<string>;
  BoundingCaps?: Array<string>;
  Config?: InspectContainerConfig;
  ConmonPidFile?: string;
  Created?: string;
  Dependencies?: Array<string>;
  Driver?: string;
  EffectiveCaps?: Array<string>;
  ExecIDs?: Array<string>;
  GraphDriver?: DriverData;
  HostConfig?: InspectContainerHostConfig;
  HostnamePath?: string;
  HostsPath?: string;
  Id?: string;
  Image?: string;
  ImageDigest?: string;
  ImageName?: string;
  IsInfra?: boolean;
  IsService?: boolean;
  KubeExitCodePropagation?: string;
  MountLabel?: string;
  Mounts?: Array<InspectMount>;
  Name?: string;
  Namespace?: string;
  NetworkSettings?: InspectNetworkSettings;
  OCIConfigPath?: string;
  OCIRuntime?: string;
  Path?: string;
  PidFile?: string;
  Pod?: string;
  ProcessLabel?: string;
  ResolvConfPath?: string;
  RestartCount?: number;
  Rootfs?: string;
  SizeRootFs?: number;
  SizeRw?: number;
  State?: InspectContainerState;
  StaticDir?: string;
  UseImageHostname?: boolean;
  UseImageHosts?: boolean;
  lockNumber?: number;
};

/**
 * InspectContainerHostConfig holds information used when the container was
 * created.
 * It's very much a Docker-specific struct, retained (mostly) as-is for
 * compatibility. We fill individual fields as best as we can, inferring as much
 * as possible from the spec and container config.
 * Some things cannot be inferred. These will be populated by spec annotations
 * (if available).
 */
export type InspectContainerHostConfig = {
  /**
   * Annotations are provided to the runtime when the container is
   * started.
   */
  Annotations?: {
    [key: string]: string;
  };
  /**
   * AutoRemove is whether the container will be automatically removed on
   * exiting.
   * It is not handled directly within libpod and is stored in an
   * annotation.
   */
  AutoRemove?: boolean;
  /**
   * AutoRemoveImage is whether the container's image will be
   * automatically removed on exiting.
   * It is not handled directly within libpod and is stored in an
   * annotation.
   */
  AutoRemoveImage?: boolean;
  /**
   * Binds contains an array of user-added mounts.
   * Both volume mounts and named volumes are included.
   * Tmpfs mounts are NOT included.
   * In 'docker inspect' this is separated into 'Binds' and 'Mounts' based
   * on how a mount was added. We do not make this distinction and do not
   * include a Mounts field in inspect.
   * Format: <src>:<destination>[:<comma-separated options>]
   */
  Binds?: Array<string>;
  /**
   * BlkioDeviceReadBps is an array of I/O throttle parameters for
   * individual device nodes.
   * This specifically sets read rate cap in bytes per second for device
   * nodes.
   * As with BlkioWeightDevice, we pull the path from /sys/dev, and we
   * don't guarantee the path will be identical to the original (though
   * the node will be).
   */
  BlkioDeviceReadBps?: Array<InspectBlkioThrottleDevice>;
  /**
   * BlkioDeviceReadIOps is an array of I/O throttle parameters for
   * individual device nodes.
   * This specifically sets the read rate cap in iops per second for
   * device nodes.
   * As with BlkioWeightDevice, we pull the path from /sys/dev, and we
   * don't guarantee the path will be identical to the original (though
   * the node will be).
   */
  BlkioDeviceReadIOps?: Array<InspectBlkioThrottleDevice>;
  /**
   * BlkioDeviceWriteBps is an array of I/O throttle parameters for
   * individual device nodes.
   * this specifically sets write rate cap in bytes per second for device
   * nodes.
   * as with BlkioWeightDevice, we pull the path from /sys/dev, and we
   * don't guarantee the path will be identical to the original (though
   * the node will be).
   */
  BlkioDeviceWriteBps?: Array<InspectBlkioThrottleDevice>;
  /**
   * BlkioDeviceWriteIOps is an array of I/O throttle parameters for
   * individual device nodes.
   * This specifically sets the write rate cap in iops per second for
   * device nodes.
   * As with BlkioWeightDevice, we pull the path from /sys/dev, and we
   * don't guarantee the path will be identical to the original (though
   * the node will be).
   */
  BlkioDeviceWriteIOps?: Array<InspectBlkioThrottleDevice>;
  /**
   * BlkioWeight indicates the I/O resources allocated to the container.
   * It is a relative weight in the scheduler for assigning I/O time
   * versus other Cgroups.
   */
  BlkioWeight?: number;
  /**
   * BlkioWeightDevice is an array of I/O resource priorities for
   * individual device nodes.
   * Unfortunately, the spec only stores the device's Major/Minor numbers
   * and not the path, which is used here.
   * Fortunately, the kernel provides an interface for retrieving the path
   * of a given node by major:minor at /sys/dev/. However, the exact path
   * in use may not be what was used in the original CLI invocation -
   * though it is guaranteed that the device node will be the same, and
   * using the given path will be functionally identical.
   */
  BlkioWeightDevice?: Array<InspectBlkioWeightDevice>;
  /**
   * CapAdd is a list of capabilities added to the container.
   * It is not directly stored by Libpod, and instead computed from the
   * capabilities listed in the container's spec, compared against a set
   * of default capabilities.
   */
  CapAdd?: Array<string>;
  /**
   * CapDrop is a list of capabilities removed from the container.
   * It is not directly stored by libpod, and instead computed from the
   * capabilities listed in the container's spec, compared against a set
   * of default capabilities.
   */
  CapDrop?: Array<string>;
  /**
   * Cgroup contains the container's cgroup. It is presently not
   * populated.
   * TODO.
   */
  Cgroup?: string;
  /**
   * CgroupConf is the configuration for cgroup v2.
   */
  CgroupConf?: {
    [key: string]: string;
  };
  /**
   * CgroupManager is the cgroup manager used by the container.
   * At present, allowed values are either "cgroupfs" or "systemd".
   */
  CgroupManager?: string;
  /**
   * CgroupMode is the configuration of the container's cgroup namespace.
   * Populated as follows:
   * private - a cgroup namespace has been created
   * host - No cgroup namespace created
   * container:<id> - Using another container's cgroup namespace
   * ns:<path> - A path to a cgroup namespace has been specified
   */
  CgroupMode?: string;
  /**
   * CgroupParent is the Cgroup parent of the container.
   * Only set if not default.
   */
  CgroupParent?: string;
  /**
   * Cgroups contains the container's Cgroup mode.
   * Allowed values are "default" (container is creating Cgroups) and
   * "disabled" (container is not creating Cgroups).
   * This is Libpod-specific and not included in `docker inspect`.
   */
  Cgroups?: string;
  /**
   * ConsoleSize is an array of 2 integers showing the size of the
   * container's console.
   * It is only set if the container is creating a terminal.
   * TODO.
   */
  ConsoleSize?: Array<number>;
  /**
   * ContainerIDFile is a file created during container creation to hold
   * the ID of the created container.
   * This is not handled within libpod and is stored in an annotation.
   */
  ContainerIDFile?: string;
  /**
   * CpuCount is Windows-only and not presently implemented.
   */
  CpuCount?: number;
  /**
   * CpuPercent is Windows-only and not presently implemented.
   */
  CpuPercent?: number;
  /**
   * CpuPeriod is the length of a CPU period in microseconds.
   * It relates directly to CpuQuota.
   */
  CpuPeriod?: number;
  /**
   * CpuPeriod is the amount of time (in microseconds) that a container
   * can use the CPU in every CpuPeriod.
   */
  CpuQuota?: number;
  /**
   * CpuRealtimePeriod is the length of time (in microseconds) of the CPU
   * realtime period. If set to 0, no time will be allocated to realtime
   * tasks.
   */
  CpuRealtimePeriod?: number;
  /**
   * CpuRealtimeRuntime is the length of time (in microseconds) allocated
   * for realtime tasks within every CpuRealtimePeriod.
   */
  CpuRealtimeRuntime?: number;
  /**
   * CpuShares indicates the CPU resources allocated to the container.
   * It is a relative weight in the scheduler for assigning CPU time
   * versus other Cgroups.
   */
  CpuShares?: number;
  /**
   * CpusetCpus is the set of CPUs that the container will execute on.
   * Formatted as `0-3` or `0,2`. Default (if unset) is all CPUs.
   */
  CpusetCpus?: string;
  /**
   * CpusetMems is the set of memory nodes the container will use.
   * Formatted as `0-3` or `0,2`. Default (if unset) is all memory nodes.
   */
  CpusetMems?: string;
  /**
   * Devices is a list of device nodes that will be added to the
   * container.
   * These are stored in the OCI spec only as type, major, minor while we
   * display the host path. We convert this with /sys/dev, but we cannot
   * guarantee that the host path will be identical - only that the actual
   * device will be.
   */
  Devices?: Array<InspectDevice>;
  /**
   * DiskQuota is the maximum amount of disk space the container may use
   * (in bytes).
   * Presently not populated.
   * TODO.
   */
  DiskQuota?: number;
  /**
   * Dns is a list of DNS nameservers that will be added to the
   * container's resolv.conf
   */
  Dns?: Array<string>;
  /**
   * DnsOptions is a list of DNS options that will be set in the
   * container's resolv.conf
   */
  DnsOptions?: Array<string>;
  /**
   * DnsSearch is a list of DNS search domains that will be set in the
   * container's resolv.conf
   */
  DnsSearch?: Array<string>;
  /**
   * ExtraHosts contains hosts that will be added to the container's
   * etc/hosts.
   */
  ExtraHosts?: Array<string>;
  /**
   * GroupAdd contains groups that the user inside the container will be
   * added to.
   */
  GroupAdd?: Array<string>;
  /**
   * HostsFile is the base file to create the `/etc/hosts` file inside the container.
   */
  HostsFile?: string;
  IDMappings?: InspectIdMappings;
  /**
   * IOMaximumBandwidth is Windows-only and not presently implemented.
   */
  IOMaximumBandwidth?: number;
  /**
   * IOMaximumIOps is Windows-only and not presently implemented.
   */
  IOMaximumIOps?: number;
  /**
   * Init indicates whether the container has an init mounted into it.
   */
  Init?: boolean;
  /**
   * IntelRdtClosID defines the Intel RDT CAT Class Of Service (COS) that
   * all processes of the container should run in.
   */
  IntelRdtClosID?: string;
  /**
   * IpcMode represents the configuration of the container's IPC
   * namespace.
   * Populated as follows:
   * "" (empty string) - Default, an IPC namespace will be created
   * host - No IPC namespace created
   * container:<id> - Using another container's IPC namespace
   * ns:<path> - A path to an IPC namespace has been specified
   */
  IpcMode?: string;
  /**
   * Isolation is presently unused and provided solely for Docker
   * compatibility.
   */
  Isolation?: string;
  /**
   * KernelMemory is the maximum amount of memory the kernel will devote
   * to the container.
   */
  KernelMemory?: number;
  /**
   * Links is unused, and provided purely for Docker compatibility.
   */
  Links?: Array<string>;
  LogConfig?: InspectLogConfig;
  /**
   * Memory indicates the memory resources allocated to the container.
   * This is the limit (in bytes) of RAM the container may use.
   */
  Memory?: number;
  /**
   * MemoryReservation is the reservation (soft limit) of memory available
   * to the container. Soft limits are warnings only and can be exceeded.
   */
  MemoryReservation?: number;
  /**
   * MemorySwap is the total limit for all memory available to the
   * container, including swap. 0 indicates that there is no limit to the
   * amount of memory available.
   */
  MemorySwap?: number;
  /**
   * MemorySwappiness is the willingness of the kernel to page container
   * memory to swap. It is an integer from 0 to 100, with low numbers
   * being more likely to be put into swap.
   * 1, the default, will not set swappiness and use the system defaults.
   */
  MemorySwappiness?: number;
  /**
   * NanoCpus indicates number of CPUs allocated to the container.
   * It is an integer where one full CPU is indicated by 1000000000 (one
   * billion).
   * Thus, 2.5 CPUs (fractional portions of CPUs are allowed) would be
   * 2500000000 (2.5 billion).
   * In 'docker inspect' this is set exclusively of two further options in
   * the output (CpuPeriod and CpuQuota) which are both used to implement
   * this functionality.
   * We can't distinguish here, so if CpuQuota is set to the default of
   * 100000, we will set both CpuQuota, CpuPeriod, and NanoCpus. If
   * CpuQuota is not the default, we will not set NanoCpus.
   */
  NanoCpus?: number;
  /**
   * NetworkMode is the configuration of the container's network
   * namespace.
   * Populated as follows:
   * default - A network namespace is being created and configured via CNI
   * none - A network namespace is being created, not configured via CNI
   * host - No network namespace created
   * container:<id> - Using another container's network namespace
   * ns:<path> - A path to a network namespace has been specified
   */
  NetworkMode?: string;
  /**
   * OomKillDisable indicates whether the kernel OOM killer is disabled
   * for the container.
   */
  OomKillDisable?: boolean;
  /**
   * OOMScoreAdj is an adjustment that will be made to the container's OOM
   * score.
   */
  OomScoreAdj?: number;
  /**
   * PidMode represents the configuration of the container's PID
   * namespace.
   * Populated as follows:
   * "" (empty string) - Default, a PID namespace will be created
   * host - No PID namespace created
   * container:<id> - Using another container's PID namespace
   * ns:<path> - A path to a PID namespace has been specified
   */
  PidMode?: string;
  /**
   * PidsLimit is the maximum number of PIDs that may be created within
   * the container. 0, the default, indicates no limit.
   */
  PidsLimit?: number;
  /**
   * PortBindings contains the container's port bindings.
   * It is formatted as map[string][]InspectHostPort.
   * The string key here is formatted as <integer port number>/<protocol>
   * and represents the container port. A single container port may be
   * bound to multiple host ports (on different IPs).
   */
  PortBindings?: {
    [key: string]: Array<InspectHostPort>;
  };
  /**
   * Privileged indicates whether the container is running with elevated
   * privileges.
   * This has a very specific meaning in the Docker sense, so it's very
   * difficult to decode from the spec and config, and so is stored as an
   * annotation.
   */
  Privileged?: boolean;
  /**
   * PublishAllPorts indicates whether image ports are being published.
   * This is not directly stored in libpod and is saved as an annotation.
   */
  PublishAllPorts?: boolean;
  /**
   * ReadonlyRootfs is whether the container will be mounted read-only.
   */
  ReadonlyRootfs?: boolean;
  RestartPolicy?: InspectRestartPolicy;
  /**
   * Runtime is provided purely for Docker compatibility.
   * It is set unconditionally to "oci" as Podman does not presently
   * support non-OCI runtimes.
   */
  Runtime?: string;
  /**
   * SecurityOpt is a list of security-related options that are set in the
   * container.
   */
  SecurityOpt?: Array<string>;
  ShmSize?: number;
  /**
   * Tmpfs is a list of tmpfs filesystems that will be mounted into the
   * container.
   * It is a map of destination path to options for the mount.
   */
  Tmpfs?: {
    [key: string]: string;
  };
  /**
   * UTSMode represents the configuration of the container's UID
   * namespace.
   * Populated as follows:
   * "" (empty string) - Default, a UTS namespace will be created
   * host - no UTS namespace created
   * container:<id> - Using another container's UTS namespace
   * ns:<path> - A path to a UTS namespace has been specified
   */
  UTSMode?: string;
  /**
   * Ulimits is a set of ulimits that will be set within the container.
   */
  Ulimits?: Array<InspectUlimit>;
  /**
   * UsernsMode represents the configuration of the container's user
   * namespace.
   * When running rootless, a user namespace is created outside of libpod
   * to allow some privileged operations. This will not be reflected here.
   * Populated as follows:
   * "" (empty string) - No user namespace will be created
   * private - The container will be run in a user namespace
   * container:<id> - Using another container's user namespace
   * ns:<path> - A path to a user namespace has been specified
   * TODO Rootless has an additional 'keep-id' option, presently not
   * reflected here.
   */
  UsernsMode?: string;
  /**
   * VolumeDriver is presently unused and is retained for Docker
   * compatibility.
   */
  VolumeDriver?: string;
  /**
   * VolumesFrom is a list of containers which this container uses volumes
   * from. This is not handled directly within libpod and is stored in an
   * annotation.
   * It is formatted as an array of container names and IDs.
   */
  VolumesFrom?: Array<string>;
};

/**
 * InspectContainerState provides a detailed record of a container's current
 * state. It is returned as part of InspectContainerData.
 * As with InspectContainerData, many portions of this struct are matched to
 * Docker, but here we see more fields that are unused (nonsensical in the
 * context of Libpod).
 */
export type InspectContainerState = {
  CgroupPath?: string;
  CheckpointLog?: string;
  CheckpointPath?: string;
  Checkpointed?: boolean;
  CheckpointedAt?: string;
  ConmonPid?: number;
  Dead?: boolean;
  Error?: string;
  ExitCode?: number;
  FinishedAt?: string;
  Health?: HealthCheckResults;
  OOMKilled?: boolean;
  OciVersion?: string;
  Paused?: boolean;
  Pid?: number;
  Restarting?: boolean;
  RestoreLog?: string;
  Restored?: boolean;
  RestoredAt?: string;
  Running?: boolean;
  StartedAt?: string;
  Status?: string;
  StoppedByUser?: boolean;
};

/**
 * InspectDevice is a single device that will be mounted into the container.
 */
export type InspectDevice = {
  /**
   * CgroupPermissions is the permissions of the mounted device.
   * Presently not populated.
   * TODO.
   */
  CgroupPermissions?: string;
  /**
   * PathInContainer is the path of the device within the container.
   */
  PathInContainer?: string;
  /**
   * PathOnHost is the path of the device on the host.
   */
  PathOnHost?: string;
};

/**
 * InspectExecProcess contains information about the process in a given exec
 * session.
 */
export type InspectExecProcess = {
  /**
   * Arguments are the arguments to the entrypoint command of the exec
   * session.
   */
  arguments?: Array<string>;
  /**
   * Entrypoint is the entrypoint for the exec session (the command that
   * will be executed in the container).
   */
  entrypoint?: string;
  /**
   * Privileged is whether the exec session will be started with elevated
   * privileges.
   */
  privileged?: boolean;
  /**
   * Tty is whether the exec session created a terminal.
   */
  tty?: boolean;
  /**
   * User is the user the exec session was started as.
   */
  user?: string;
};

/**
 * InspectExecSession contains information about a given exec session.
 */
export type InspectExecSession = {
  /**
   * CanRemove is legacy and used purely for compatibility reasons.
   * Will always be set to true, unless the exec session is running.
   */
  CanRemove?: boolean;
  /**
   * ContainerID is the ID of the container this exec session is attached
   * to.
   */
  ContainerID?: string;
  /**
   * DetachKeys are the detach keys used by the exec session.
   * If set to "" the default keys are being used.
   * Will show "<none>" if no detach keys are set.
   */
  DetachKeys?: string;
  /**
   * ExitCode is the exit code of the exec session. Will be set to 0 if
   * the exec session has not yet exited.
   */
  ExitCode?: number;
  /**
   * ID is the ID of the exec session.
   */
  ID?: string;
  /**
   * OpenStderr is whether the container's STDERR stream will be attached.
   * Always set to true if the exec session created a TTY.
   */
  OpenStderr?: boolean;
  /**
   * OpenStdin is whether the container's STDIN stream will be attached
   * to.
   */
  OpenStdin?: boolean;
  /**
   * OpenStdout is whether the container's STDOUT stream will be attached.
   * Always set to true if the exec session created a TTY.
   */
  OpenStdout?: boolean;
  /**
   * Pid is the PID of the exec session's process.
   * Will be set to 0 if the exec session is not running.
   */
  Pid?: number;
  ProcessConfig?: InspectExecProcess;
  /**
   * Running is whether the exec session is running.
   */
  Running?: boolean;
};

/**
 * InspectHostPort provides information on a port on the host that a container's
 * port is bound to.
 */
export type InspectHostPort = {
  /**
   * IP on the host we are bound to. "" if not specified (binding to all
   * IPs).
   */
  HostIp?: string;
  /**
   * Port on the host we are bound to. No special formatting - just an
   * integer stuffed into a string.
   */
  HostPort?: string;
};

export type InspectIdMappings = {
  GidMap?: Array<string>;
  UidMap?: Array<string>;
};

/**
 * InspectLogConfig holds information about a container's configured log driver
 */
export type InspectLogConfig = {
  Config?: {
    [key: string]: string;
  };
  /**
   * Path specifies a path to the log file
   */
  Path?: string;
  /**
   * Size specifies a maximum size of the container log
   */
  Size?: string;
  /**
   * Tag specifies a custom log tag for the container
   */
  Tag?: string;
  Type?: string;
};

/**
 * InspectMount provides a record of a single mount in a container. It contains
 * fields for both named and normal volumes. Only user-specified volumes will be
 * included, and tmpfs volumes are not included even if the user specified them.
 */
export type InspectMount = {
  /**
   * The destination directory for the volume. Specified as a path within
   * the container, as it would be passed into the OCI runtime.
   */
  Destination?: string;
  /**
   * The driver used for the named volume. Empty for bind mounts.
   */
  Driver?: string;
  /**
   * Contains SELinux :z/:Z mount options. Unclear what, if anything, else
   * goes in here.
   */
  Mode?: string;
  /**
   * The name of the volume. Empty for bind mounts.
   */
  Name?: string;
  /**
   * All remaining mount options. Additional data, not present in the
   * original output.
   */
  Options?: Array<string>;
  /**
   * Mount propagation for the mount. Can be empty if not specified, but
   * is always printed - no omitempty.
   */
  Propagation?: string;
  /**
   * Whether the volume is read-write
   */
  RW?: boolean;
  /**
   * The source directory for the volume.
   */
  Source?: string;
  /**
   * SubPath object from the volume. Specified as a path within
   * the source volume to be mounted at the Destination.
   */
  SubPath?: string;
  /**
   * Whether the mount is a volume or bind mount. Allowed values are
   * "volume" and "bind".
   */
  Type?: string;
};

/**
 * InspectNetworkSettings holds information about the network settings of the
 * container.
 * Many fields are maintained only for compatibility with `docker inspect` and
 * are unused within Libpod.
 */
export type InspectNetworkSettings = {
  /**
   * AdditionalMacAddresses is a set of additional MAC Addresses beyond
   * the first. CNI may configure more than one interface for a single
   * network, which can cause this.
   */
  AdditionalMACAddresses?: Array<string>;
  Bridge?: string;
  /**
   * EndpointID is unused, maintained exclusively for compatibility.
   */
  EndpointID?: string;
  /**
   * Gateway is the IP address of the gateway this network will use.
   */
  Gateway?: string;
  /**
   * GlobalIPv6Address is the global-scope IPv6 Address for this network.
   */
  GlobalIPv6Address?: string;
  /**
   * GlobalIPv6PrefixLen is the length of the subnet mask of this network.
   */
  GlobalIPv6PrefixLen?: number;
  HairpinMode?: boolean;
  /**
   * IPAddress is the IP address for this network.
   */
  IPAddress?: string;
  /**
   * IPPrefixLen is the length of the subnet mask of this network.
   */
  IPPrefixLen?: number;
  /**
   * IPv6Gateway is the IPv6 gateway this network will use.
   */
  IPv6Gateway?: string;
  LinkLocalIPv6Address?: string;
  LinkLocalIPv6PrefixLen?: number;
  /**
   * MacAddress is the MAC address for the interface in this network.
   */
  MacAddress?: string;
  /**
   * Networks contains information on non-default networks this
   * container has joined.
   * It is a map of network name to network information.
   */
  Networks?: {
    [key: string]: InspectAdditionalNetwork;
  };
  Ports?: {
    [key: string]: Array<InspectHostPort>;
  };
  SandboxID?: string;
  SandboxKey?: string;
  /**
   * SecondaryIPAddresses is a list of extra IP Addresses that the
   * container has been assigned in this network.
   */
  SecondaryIPAddresses?: Array<Address>;
  /**
   * SecondaryIPv6Addresses is a list of extra IPv6 Addresses that the
   * container has been assigned in this network.
   */
  SecondaryIPv6Addresses?: Array<Address>;
};

/**
 * InspectPodContainerInfo contains information on a container in a pod.
 */
export type InspectPodContainerInfo = {
  /**
   * ID is the ID of the container.
   */
  Id?: string;
  /**
   * Name is the name of the container.
   */
  Name?: string;
  /**
   * State is the current status of the container.
   */
  State?: string;
};

/**
 * InspectPodData contains detailed information on a pod's configuration and
 * state. It is used as the output of Inspect on pods.
 */
export type InspectPodData = {
  /**
   * CgroupParent is the parent of the pod's Cgroup.
   */
  CgroupParent?: string;
  /**
   * CgroupPath is the path to the pod's Cgroup.
   */
  CgroupPath?: string;
  /**
   * Containers gives a brief summary of all containers in the pod and
   * their current status.
   */
  Containers?: Array<InspectPodContainerInfo>;
  /**
   * CreateCgroup is whether this pod will create its own Cgroup to group
   * containers under.
   */
  CreateCgroup?: boolean;
  /**
   * CreateCommand is the full command plus arguments of the process the
   * container has been created with.
   */
  CreateCommand?: Array<string>;
  /**
   * CreateInfra is whether this pod will create an infra container to
   * share namespaces.
   */
  CreateInfra?: boolean;
  /**
   * Created is the time when the pod was created.
   */
  Created?: string;
  /**
   * ExitPolicy of the pod.
   */
  ExitPolicy?: string;
  /**
   * Hostname is the hostname that the pod will set.
   */
  Hostname?: string;
  /**
   * ID is the ID of the pod.
   */
  Id?: string;
  InfraConfig?: InspectPodInfraConfig;
  /**
   * InfraContainerID is the ID of the pod's infra container, if one is
   * present.
   */
  InfraContainerID?: string;
  /**
   * Labels is a set of key-value labels that have been applied to the
   * pod.
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * Number of the pod's Libpod lock.
   */
  LockNumber?: number;
  /**
   * Name is the name of the pod.
   */
  Name?: string;
  /**
   * Namespace is the Libpod namespace the pod is placed in.
   */
  Namespace?: string;
  /**
   * NumContainers is the number of containers in the pod, including the
   * infra container.
   */
  NumContainers?: number;
  /**
   * RestartPolicy of the pod.
   */
  RestartPolicy?: string;
  /**
   * SharedNamespaces contains a list of namespaces that will be shared by
   * containers within the pod. Can only be set if CreateInfra is true.
   */
  SharedNamespaces?: Array<string>;
  /**
   * State represents the current state of the pod.
   */
  State?: string;
  /**
   * BlkioWeight contains the blkio weight limit for the pod
   */
  blkio_weight?: number;
  /**
   * BlkioWeightDevice contains the blkio weight device limits for the pod
   */
  blkio_weight_device?: Array<InspectBlkioWeightDevice>;
  /**
   * CPUPeriod contains the CPU period of the pod
   */
  cpu_period?: number;
  /**
   * CPUQuota contains the CPU quota of the pod
   */
  cpu_quota?: number;
  /**
   * CPUShares contains the cpu shares for the pod
   */
  cpu_shares?: number;
  /**
   * CPUSetCPUs contains linux specific CPU data for the pod
   */
  cpuset_cpus?: string;
  /**
   * CPUSetMems contains linux specific CPU data for the pod
   */
  cpuset_mems?: string;
  /**
   * BlkioDeviceReadBps contains the Read/Access limit for the pod's devices
   */
  device_read_bps?: Array<InspectBlkioThrottleDevice>;
  /**
   * BlkioDeviceReadBps contains the Read/Access limit for the pod's devices
   */
  device_write_bps?: Array<InspectBlkioThrottleDevice>;
  /**
   * Devices contains the specified host devices
   */
  devices?: Array<InspectDevice>;
  /**
   * MemoryLimit contains the specified cgroup memory limit for the pod
   */
  memory_limit?: number;
  /**
   * MemorySwap contains the specified memory swap limit for the pod
   */
  memory_swap?: number;
  /**
   * Mounts contains volume related information for the pod
   */
  mounts?: Array<InspectMount>;
  /**
   * SecurityOpt contains the specified security labels and related SELinux information
   */
  security_opt?: Array<string>;
  /**
   * VolumesFrom contains the containers that the pod inherits mounts from
   */
  volumes_from?: Array<string>;
};

/**
 * InspectPodInfraConfig contains the configuration of the pod's infra
 * container.
 */
export type InspectPodInfraConfig = {
  /**
   * DNSOption is a set of DNS options that will be used by the infra
   * container's resolv.conf and shared with the remainder of the pod.
   */
  DNSOption?: Array<string>;
  /**
   * DNSSearch is a set of DNS search domains that will be used by the
   * infra container's resolv.conf and shared with the remainder of the
   * pod.
   */
  DNSSearch?: Array<string>;
  /**
   * DNSServer is a set of DNS Servers that will be used by the infra
   * container's resolv.conf and shared with the remainder of the pod.
   */
  DNSServer?: Array<string>;
  /**
   * HostAdd adds a number of hosts to the infra container's resolv.conf
   * which will be shared with the rest of the pod.
   */
  HostAdd?: Array<string>;
  /**
   * HostNetwork is whether the infra container (and thus the whole pod)
   * will use the host's network and not create a network namespace.
   */
  HostNetwork?: boolean;
  /**
   * HostsFile is the base file to create the `/etc/hosts` file inside the infra container
   * which will be shared with the rest of the pod.
   */
  HostsFile?: string;
  /**
   * NetworkOptions are additional options for each network
   */
  NetworkOptions?: {
    [key: string]: Array<string>;
  };
  /**
   * Networks is a list of networks the pod will join.
   */
  Networks?: Array<string>;
  /**
   * NoManageHostname indicates that the pod will not manage /etc/hostname
   * and instead each container will handle their own.
   */
  NoManageHostname?: boolean;
  /**
   * NoManageHosts indicates that the pod will not manage /etc/hosts and
   * instead each container will handle their own.
   */
  NoManageHosts?: boolean;
  /**
   * NoManageResolvConf indicates that the pod will not manage resolv.conf
   * and instead each container will handle their own.
   */
  NoManageResolvConf?: boolean;
  /**
   * PortBindings are ports that will be forwarded to the infra container
   * and then shared with the pod.
   */
  PortBindings?: {
    [key: string]: Array<InspectHostPort>;
  };
  /**
   * StaticIP is a static IPv4 that will be assigned to the infra
   * container and then used by the pod.
   */
  StaticIP?: string;
  /**
   * StaticMAC is a static MAC address that will be assigned to the infra
   * container and then used by the pod.
   */
  StaticMAC?: string;
  /**
   * CPUPeriod contains the CPU period of the pod
   */
  cpu_period?: number;
  /**
   * CPUQuota contains the CPU quota of the pod
   */
  cpu_quota?: number;
  /**
   * CPUSetCPUs contains linux specific CPU data for the container
   */
  cpuset_cpus?: string;
  /**
   * Pid is the PID namespace mode of the pod's infra container
   */
  pid_ns?: string;
  /**
   * UserNS is the usernamespace that all the containers in the pod will join.
   */
  userns?: string;
  /**
   * UtsNS is the uts namespace that all containers in the pod will join
   */
  uts_ns?: string;
};

/**
 * InspectResponse is the response for the GET "/containers/{name:.*}/json"
 * endpoint.
 */
export type InspectResponse = {
  AppArmorProfile?: string;
  Args?: Array<string>;
  Config?: Config;
  Created?: string;
  Driver?: string;
  ExecIDs?: Array<string>;
  GraphDriver?: DriverData;
  HostConfig?: HostConfig;
  HostnamePath?: string;
  HostsPath?: string;
  Id?: string;
  Image?: string;
  ImageManifestDescriptor?: Descriptor;
  LogPath?: string;
  MountLabel?: string;
  Mounts?: Array<MountPoint>;
  Name?: string;
  NetworkSettings?: NetworkSettings;
  Path?: string;
  Platform?: string;
  ProcessLabel?: string;
  ResolvConfPath?: string;
  RestartCount?: number;
  SizeRootFs?: number;
  SizeRw?: number;
  State?: State;
};

/**
 * InspectRestartPolicy holds information about the container's restart policy.
 */
export type InspectRestartPolicy = {
  /**
   * MaximumRetryCount is the maximum number of retries allowed if the
   * "on-failure" restart policy is in use. Not used if "on-failure" is
   * not set.
   */
  MaximumRetryCount?: number;
  /**
   * Name contains the container's restart policy.
   * Allowable values are "no" or "" (take no action),
   * "on-failure" (restart on non-zero exit code, with an optional max
   * retry count), and "always" (always restart on container stop, unless
   * explicitly requested by API).
   * Note that this is NOT actually a name of any sort - the poor naming
   * is for Docker compatibility.
   */
  Name?: string;
};

/**
 * InspectSecret contains information on secrets mounted inside the container
 */
export type InspectSecret = {
  /**
   * ID is the GID of the mounted secret file
   */
  GID?: number;
  /**
   * ID is the ID of the secret
   */
  ID?: string;
  /**
   * ID is the ID of the mode of the mounted secret file
   */
  Mode?: number;
  /**
   * Name is the name of the secret
   */
  Name?: string;
  /**
   * ID is the UID of the mounted secret file
   */
  UID?: number;
};

/**
 * InspectUlimit is a ulimit that will be applied to the container.
 */
export type InspectUlimit = {
  /**
   * Hard is the hard limit that will be applied.
   */
  Hard?: number;
  /**
   * Name is the name (type) of the ulimit.
   */
  Name?: string;
  /**
   * Soft is the soft limit that will be applied.
   */
  Soft?: number;
};

/**
 * IpcMode represents the container ipc stack.
 */
export type IpcMode = string;

/**
 * Isolation represents the isolation technology of a container. The supported
 * values are platform specific
 */
export type Isolation = string;

/**
 * LeaseRange contains the range where IP are leased.
 */
export type LeaseRange = {
  /**
   * EndIP last IP in the subnet which should be used to assign ips.
   */
  end_ip?: string;
  /**
   * StartIP first IP in the subnet which should be used to assign ips.
   */
  start_ip?: string;
};

export type LibpodContainersRmReport = {
  /**
   * Error which occurred during Rm operation (if any).
   * This field is optional and may be omitted if no error occurred.
   */
  Err?: string | null;
  Id?: string;
};

export type LibpodImageSummary = {
  /**
   * Podman extensions
   */
  Arch?: string;
  Containers?: number;
  Created?: number;
  Dangling?: boolean;
  Digest?: string;
  History?: Array<string>;
  Id?: string;
  /**
   * IsManifestList is a ptr so we can distinguish between a true
   * json empty response and false.  the docker compat side needs to return
   * empty; where as the libpod side needs a value of true or false
   */
  IsManifestList?: boolean;
  Labels?: {
    [key: string]: string;
  };
  Names?: Array<string>;
  Os?: string;
  ParentId?: string;
  ReadOnly?: boolean;
  RW?: boolean; // Podman API compatibility - inverse of ReadOnly
  RepoDigests?: Array<string>;
  RepoTags?: Array<string>;
  SharedSize?: number;
  Size?: number;
  VirtualSize?: number;
};

export type LibpodImagesPullReport = {
  /**
   * Error contains text of errors from c/image
   */
  error?: string;
  /**
   * ID contains image id (retained for backwards compatibility)
   */
  id?: string;
  /**
   * Images contains the ID's of the images pulled
   */
  images?: Array<string>;
  /**
   * Stream used to provide output from c/image
   */
  stream?: string;
};

/**
 * LibpodImagesRemoveReport is the return type for image removal via the rest
 * api.
 */
export type LibpodImagesRemoveReport = {
  /**
   * Deleted images.
   */
  Deleted?: Array<string>;
  /**
   * Image removal requires is to return data and an error.
   */
  Errors?: Array<string>;
  /**
   * ExitCode describes the exit codes as described in the `podman rmi`
   * man page.
   */
  ExitCode?: number;
  /**
   * Untagged images. Can be longer than Deleted.
   */
  Untagged?: Array<string>;
};

/**
 * Info is the overall struct that describes the host system
 * running libpod/podman
 */
export type LibpodInfo = {
  host?: HostInfo;
  plugins?: Plugins;
  registries?: {
    [key: string]: unknown;
  };
  store?: StoreInfo;
  version?: Version;
};

/**
 * LinuxBlockIO for Linux cgroup 'blkio' resource management
 */
export type LinuxBlockIo = {
  /**
   * Specifies tasks' weight in the given cgroup while competing with the cgroup's child cgroups, CFQ scheduler only
   */
  leafWeight?: number;
  /**
   * IO read rate limit per cgroup per device, bytes per second
   */
  throttleReadBpsDevice?: Array<LinuxThrottleDevice>;
  /**
   * IO read rate limit per cgroup per device, IO per second
   */
  throttleReadIOPSDevice?: Array<LinuxThrottleDevice>;
  /**
   * IO write rate limit per cgroup per device, bytes per second
   */
  throttleWriteBpsDevice?: Array<LinuxThrottleDevice>;
  /**
   * IO write rate limit per cgroup per device, IO per second
   */
  throttleWriteIOPSDevice?: Array<LinuxThrottleDevice>;
  /**
   * Specifies per cgroup weight
   */
  weight?: number;
  /**
   * Weight per cgroup per device, can override BlkioWeight
   */
  weightDevice?: Array<LinuxWeightDevice>;
};

/**
 * LinuxBlockIODevice holds major:minor format supported in blkio cgroup
 */
export type LinuxBlockIoDevice = {
  /**
   * Major is the device's major number.
   */
  major?: number;
  /**
   * Minor is the device's minor number.
   */
  minor?: number;
};

/**
 * LinuxCPU for Linux cgroup 'cpu' resource management
 */
export type LinuxCpu = {
  /**
   * CPU hardcap burst limit (in usecs). Allowed accumulated cpu time additionally for burst in a
   * given period.
   */
  burst?: number;
  /**
   * CPUs to use within the cpuset. Default is to use any CPU available.
   */
  cpus?: string;
  /**
   * cgroups are configured with minimum weight, 0: default behavior, 1: SCHED_IDLE.
   */
  idle?: number;
  /**
   * List of memory nodes in the cpuset. Default is to use any available memory node.
   */
  mems?: string;
  /**
   * CPU period to be used for hardcapping (in usecs).
   */
  period?: number;
  /**
   * CPU hardcap limit (in usecs). Allowed cpu time in a given period.
   */
  quota?: number;
  /**
   * CPU period to be used for realtime scheduling (in usecs).
   */
  realtimePeriod?: number;
  /**
   * How much time realtime scheduling may use (in usecs).
   */
  realtimeRuntime?: number;
  /**
   * CPU shares (relative weight (ratio) vs. other cgroups with cpu shares).
   */
  shares?: number;
};

/**
 * LinuxDevice represents the mknod information for a Linux special device file
 */
export type LinuxDevice = {
  fileMode?: FileMode;
  /**
   * Gid of the device.
   */
  gid?: number;
  /**
   * Major is the device's major number.
   */
  major?: number;
  /**
   * Minor is the device's minor number.
   */
  minor?: number;
  /**
   * Path to the device.
   */
  path?: string;
  /**
   * Device type, block, char, etc.
   */
  type?: string;
  /**
   * UID of the device.
   */
  uid?: number;
};

/**
 * LinuxDeviceCgroup represents a device rule for the devices specified to
 * the device controller
 */
export type LinuxDeviceCgroup = {
  /**
   * Cgroup access permissions format, rwm.
   */
  access?: string;
  /**
   * Allow or deny
   */
  allow?: boolean;
  /**
   * Major is the device's major number.
   */
  major?: number;
  /**
   * Minor is the device's minor number.
   */
  minor?: number;
  /**
   * Device type, block, char, etc.
   */
  type?: string;
};

/**
 * LinuxHugepageLimit structure corresponds to limiting kernel hugepages.
 * Default to reservation limits if supported. Otherwise fallback to page fault limits.
 */
export type LinuxHugepageLimit = {
  /**
   * Limit is the limit of "hugepagesize" hugetlb reservations (if supported) or usage.
   */
  limit?: number;
  /**
   * Pagesize is the hugepage size.
   * Format: "<size><unit-prefix>B' (e.g. 64KB, 2MB, 1GB, etc.).
   */
  pageSize?: string;
};

/**
 * LinuxIDMapping specifies UID/GID mappings
 */
export type LinuxIdMapping = {
  /**
   * ContainerID is the starting UID/GID in the container
   */
  containerID?: number;
  /**
   * HostID is the starting UID/GID on the host to be mapped to 'ContainerID'
   */
  hostID?: number;
  /**
   * Size is the number of IDs to be mapped
   */
  size?: number;
};

/**
 * LinuxIntelRdt has container runtime resource constraints for Intel RDT CAT and MBA
 * features and flags enabling Intel RDT CMT and MBM features.
 * Intel RDT features are available in Linux 4.14 and newer kernel versions.
 */
export type LinuxIntelRdt = {
  /**
   * The identity for RDT Class of Service
   */
  closID?: string;
  /**
   * EnableCMT is the flag to indicate if the Intel RDT CMT is enabled. CMT (Cache Monitoring Technology) supports monitoring of
   * the last-level cache (LLC) occupancy for the container.
   */
  enableCMT?: boolean;
  /**
   * EnableMBM is the flag to indicate if the Intel RDT MBM is enabled. MBM (Memory Bandwidth Monitoring) supports monitoring of
   * total and local memory bandwidth for the container.
   */
  enableMBM?: boolean;
  /**
   * The schema for L3 cache id and capacity bitmask (CBM)
   * Format: "L3:<cache_id0>=<cbm0>;<cache_id1>=<cbm1>;..."
   */
  l3CacheSchema?: string;
  /**
   * The schema of memory bandwidth per L3 cache id
   * Format: "MB:<cache_id0>=bandwidth0;<cache_id1>=bandwidth1;..."
   * The unit of memory bandwidth is specified in "percentages" by
   * default, and in "MBps" if MBA Software Controller is enabled.
   */
  memBwSchema?: string;
};

/**
 * LinuxInterfacePriority for network interfaces
 */
export type LinuxInterfacePriority = {
  /**
   * Name is the name of the network interface
   */
  name?: string;
  /**
   * Priority for the interface
   */
  priority?: number;
};

/**
 * LinuxMemory for Linux cgroup 'memory' resource management
 */
export type LinuxMemory = {
  /**
   * CheckBeforeUpdate enables checking if a new memory limit is lower
   * than the current usage during update, and if so, rejecting the new
   * limit.
   */
  checkBeforeUpdate?: boolean;
  /**
   * DisableOOMKiller disables the OOM killer for out of memory conditions
   */
  disableOOMKiller?: boolean;
  /**
   * Kernel memory limit (in bytes).
   *
   * Deprecated: kernel-memory limits are not supported in cgroups v2, and
   * were obsoleted in [kernel v5.4]. This field should no longer be used,
   * as it may be ignored by runtimes.
   *
   * [kernel v5.4]: https://github.com/torvalds/linux/commit/0158115f702b0ba208ab0
   */
  kernel?: number;
  /**
   * Kernel memory limit for tcp (in bytes)
   */
  kernelTCP?: number;
  /**
   * Memory limit (in bytes).
   */
  limit?: number;
  /**
   * Memory reservation or soft_limit (in bytes).
   */
  reservation?: number;
  /**
   * Total memory limit (memory + swap).
   */
  swap?: number;
  /**
   * How aggressive the kernel will swap memory pages.
   */
  swappiness?: number;
  /**
   * Enables hierarchical memory accounting
   */
  useHierarchy?: boolean;
};

/**
 * LinuxNetwork identification and priority configuration
 */
export type LinuxNetwork = {
  /**
   * Set class identifier for container's network packets
   */
  classID?: number;
  /**
   * Set priority of network traffic for container
   */
  priorities?: Array<LinuxInterfacePriority>;
};

/**
 * LinuxPersonality represents the Linux personality syscall input
 */
export type LinuxPersonality = {
  domain?: LinuxPersonalityDomain;
  /**
   * Additional flags
   */
  flags?: Array<LinuxPersonalityFlag>;
};

/**
 * LinuxPersonalityDomain refers to a personality domain.
 */
export type LinuxPersonalityDomain = string;

/**
 * LinuxPersonalityFlag refers to an additional personality flag. None are currently defined.
 */
export type LinuxPersonalityFlag = string;

/**
 * LinuxPids for Linux cgroup 'pids' resource management (Linux 4.3)
 */
export type LinuxPids = {
  /**
   * Maximum number of PIDs. Default is "no limit".
   */
  limit?: number;
};

/**
 * LinuxRdma for Linux cgroup 'rdma' resource management (Linux 4.11)
 */
export type LinuxRdma = {
  /**
   * Maximum number of HCA handles that can be opened. Default is "no limit".
   */
  hcaHandles?: number;
  /**
   * Maximum number of HCA objects that can be created. Default is "no limit".
   */
  hcaObjects?: number;
};

/**
 * LinuxResources has container runtime resource constraints
 */
export type LinuxResources = {
  blockIO?: LinuxBlockIo;
  cpu?: LinuxCpu;
  /**
   * Devices configures the device allowlist.
   */
  devices?: Array<LinuxDeviceCgroup>;
  /**
   * Hugetlb limits (in bytes). Default to reservation limits if supported.
   */
  hugepageLimits?: Array<LinuxHugepageLimit>;
  memory?: LinuxMemory;
  network?: LinuxNetwork;
  pids?: LinuxPids;
  /**
   * Rdma resource restriction configuration.
   * Limits are a set of key value pairs that define RDMA resource limits,
   * where the key is device name and value is resource limits.
   */
  rdma?: {
    [key: string]: LinuxRdma;
  };
  /**
   * Unified resources.
   */
  unified?: {
    [key: string]: string;
  };
};

/**
 * LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair
 */
export type LinuxThrottleDevice = {
  /**
   * Major is the device's major number.
   */
  major?: number;
  /**
   * Minor is the device's minor number.
   */
  minor?: number;
  /**
   * Rate is the IO rate limit per cgroup per device
   */
  rate?: number;
};

/**
 * LinuxWeightDevice struct holds a `major:minor weight` pair for weightDevice
 */
export type LinuxWeightDevice = {
  /**
   * LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
   */
  leafWeight?: number;
  /**
   * Major is the device's major number.
   */
  major?: number;
  /**
   * Minor is the device's minor number.
   */
  minor?: number;
  /**
   * Weight is the bandwidth rate for the device.
   */
  weight?: number;
};

/**
 * ListContainer describes a container suitable for listing
 */
export type ListContainer = {
  /**
   * AutoRemove
   */
  AutoRemove?: boolean;
  /**
   * CIDFile specified at creation time.
   */
  CIDFile?: string;
  /**
   * Container command
   */
  Command?: Array<string>;
  /**
   * Container creation time
   */
  Created?: string;
  /**
   * Human-readable container creation time.
   */
  CreatedAt?: string;
  /**
   * If container has exited, the return code from the command
   */
  ExitCode?: number;
  /**
   * If container has exited/stopped
   */
  Exited?: boolean;
  /**
   * Time container exited
   */
  ExitedAt?: number;
  /**
   * ExposedPorts contains the ports that are exposed but not forwarded,
   * see Ports for forwarded ports.
   * The key is the port number and the string slice contains the protocols,
   * i.e. "tcp", "udp" and "sctp".
   */
  ExposedPorts?: unknown;
  /**
   * The unique identifier for the container
   */
  Id?: string;
  /**
   * Container image
   */
  Image?: string;
  /**
   * Container image ID
   */
  ImageID?: string;
  /**
   * If this container is a Pod infra container
   */
  IsInfra?: boolean;
  /**
   * Labels for container
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * User volume mounts
   */
  Mounts?: Array<string>;
  /**
   * The names assigned to the container
   */
  Names?: Array<string>;
  Namespaces?: ListContainerNamespaces;
  /**
   * The network names assigned to the container
   */
  Networks?: Array<string>;
  /**
   * The process id of the container
   */
  Pid?: number;
  /**
   * If the container is part of Pod, the Pod ID. Requires the pod
   * boolean to be set
   */
  Pod?: string;
  /**
   * If the container is part of Pod, the Pod name. Requires the pod
   * boolean to be set
   */
  PodName?: string;
  /**
   * Port mappings
   */
  Ports?: Array<PortMapping>;
  /**
   * Restarts is how many times the container was restarted by its
   * restart policy. This is NOT incremented by normal container restarts
   * (only by restart policy).
   */
  Restarts?: number;
  Size?: ContainerSize;
  /**
   * Time when container started
   */
  StartedAt?: number;
  /**
   * State of container
   */
  State?: string;
  /**
   * Status is a human-readable approximation of a duration for json output
   */
  Status?: string;
};

/**
 * ListContainerNamespaces contains the identifiers of the container's Linux namespaces
 */
export type ListContainerNamespaces = {
  /**
   * Cgroup namespace
   */
  Cgroup?: string;
  /**
   * IPC namespace
   */
  Ipc?: string;
  /**
   * Mount namespace
   */
  Mnt?: string;
  /**
   * Network namespace
   */
  Net?: string;
  /**
   * PID namespace
   */
  Pidns?: string;
  /**
   * User namespace
   */
  User?: string;
  /**
   * UTS namespace
   */
  Uts?: string;
};

export type ListPodContainer = {
  Id?: string;
  Names?: string;
  RestartCount?: number;
  Status?: string;
};

export type ListPodsReport = {
  Cgroup?: string;
  Containers?: Array<ListPodContainer>;
  Created?: string;
  Id?: string;
  InfraId?: string;
  Labels?: {
    [key: string]: string;
  };
  Name?: string;
  Namespace?: string;
  /**
   * Network names connected to infra container
   */
  Networks?: Array<string>;
  Status?: string;
};

/**
 * ListResponse VolumeListResponse
 * Volume list response
 */
export type ListResponse = {
  /**
   * List of volumes
   */
  Volumes?: Array<Volume>;
  /**
   * Warnings that occurred when fetching the list of volumes.
   */
  Warnings?: Array<string>;
};

/**
 * LogConfig represents the logging configuration of the container.
 */
export type LogConfig = {
  Config?: {
    [key: string]: string;
  };
  Type?: string;
};

/**
 * LogConfig describes the logging characteristics for a container
 */
export type LogConfigLibpod = {
  /**
   * LogDriver is the container's log driver.
   * Optional.
   */
  driver?: string;
  /**
   * A set of options to accompany the log driver.
   * Optional.
   */
  options?: {
    [key: string]: string;
  };
  /**
   * LogPath is the path the container's logs will be stored at.
   * Only available if LogDriver is set to "json-file" or "k8s-file".
   * Optional.
   */
  path?: string;
  /**
   * Size is the maximum size of the log file
   * Optional.
   */
  size?: number;
};

export type MacAddress = HardwareAddr;

/**
 * ManifestAddArtifactOptions provides the model for creating artifact manifests
 * for files and adding those manifests to a manifest list
 */
export type ManifestAddArtifactOptions = {
  /**
   * Annotation to add to the item in the manifest list
   */
  annotation?: Array<string>;
  /**
   * Annotations to add to the item in the manifest list by a map which is preferred over Annotation
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * Arch overrides the architecture for the item in the manifest list
   */
  arch?: string;
  artifact_annotations?: {
    [key: string]: string;
  };
  artifact_config?: string;
  artifact_config_type?: string;
  artifact_exclude_titles?: boolean;
  artifact_files?: Array<string>;
  artifact_layer_type?: string;
  artifact_subject?: string;
  /**
   * Note to future maintainers: keep these fields synchronized with ManifestModifyOptions!
   */
  artifact_type?: string;
  /**
   * Feature list for the item in the manifest list
   */
  features?: Array<string>;
  /**
   * IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
   */
  index_annotation?: Array<string>;
  /**
   * IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
   */
  index_annotations?: {
    [key: string]: string;
  };
  /**
   * OS overrides the operating system for the item in the manifest list
   */
  os?: string;
  /**
   * OS features for the item in the manifest list
   */
  os_features?: Array<string>;
  /**
   * OSVersion overrides the operating system for the item in the manifest list
   */
  os_version?: string;
  /**
   * IndexSubject is a subject value to set in the manifest list itself
   */
  subject?: string;
  /**
   * Variant for the item in the manifest list
   */
  variant?: string;
};

/**
 * ManifestAddOptions provides model for adding digests to manifest list
 */
export type ManifestAddOptions = {
  /**
   * True when operating on a list to include all images
   */
  all?: boolean;
  /**
   * Annotation to add to the item in the manifest list
   */
  annotation?: Array<string>;
  /**
   * Annotations to add to the item in the manifest list by a map which is preferred over Annotation
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * Arch overrides the architecture for the item in the manifest list
   */
  arch?: string;
  /**
   * Feature list for the item in the manifest list
   */
  features?: Array<string>;
  /**
   * Images is an optional list of image references to add to manifest list
   */
  images?: Array<string>;
  /**
   * IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
   */
  index_annotation?: Array<string>;
  /**
   * IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
   */
  index_annotations?: {
    [key: string]: string;
  };
  /**
   * OS overrides the operating system for the item in the manifest list
   */
  os?: string;
  /**
   * OS features for the item in the manifest list
   */
  os_features?: Array<string>;
  /**
   * OSVersion overrides the operating system for the item in the manifest list
   */
  os_version?: string;
  /**
   * IndexSubject is a subject value to set in the manifest list itself
   */
  subject?: string;
  /**
   * Variant for the item in the manifest list
   */
  variant?: string;
};

/**
 * ManifestAnnotateOptions provides model for annotating manifest list
 */
export type ManifestAnnotateOptions = {
  /**
   * Annotation to add to the item in the manifest list
   */
  annotation?: Array<string>;
  /**
   * Annotations to add to the item in the manifest list by a map which is preferred over Annotation
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * Arch overrides the architecture for the item in the manifest list
   */
  arch?: string;
  /**
   * Feature list for the item in the manifest list
   */
  features?: Array<string>;
  /**
   * IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
   */
  index_annotation?: Array<string>;
  /**
   * IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
   */
  index_annotations?: {
    [key: string]: string;
  };
  /**
   * OS overrides the operating system for the item in the manifest list
   */
  os?: string;
  /**
   * OS features for the item in the manifest list
   */
  os_features?: Array<string>;
  /**
   * OSVersion overrides the operating system for the item in the manifest list
   */
  os_version?: string;
  /**
   * IndexSubject is a subject value to set in the manifest list itself
   */
  subject?: string;
  /**
   * Variant for the item in the manifest list
   */
  variant?: string;
};

export type ManifestKind = string;

/**
 * ManifestModifyOptions provides the model for mutating a manifest
 * swagger 2.0 does not support oneOf for schema validation.
 *
 * Operation "update" uses all fields.
 * Operation "remove" uses fields: Operation and Images
 * Operation "annotate" uses fields: Operation and Annotations
 */
export type ManifestModifyOptions = {
  /**
   * True when operating on a list to include all images
   */
  all?: boolean;
  /**
   * Annotation to add to the item in the manifest list
   */
  annotation?: Array<string>;
  /**
   * Annotations to add to the item in the manifest list by a map which is preferred over Annotation
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * Arch overrides the architecture for the item in the manifest list
   */
  arch?: string;
  artifact_annotations?: {
    [key: string]: string;
  };
  artifact_config?: string;
  artifact_config_type?: string;
  artifact_exclude_titles?: boolean;
  artifact_files?: Array<string>;
  artifact_layer_type?: string;
  artifact_subject?: string;
  /**
   * The following are all of the fields from ManifestAddArtifactOptions.
   * We can't just embed the whole structure because it embeds a
   * ManifestAnnotateOptions, which would conflict with the one that
   * ManifestAddOptions embeds.
   */
  artifact_type?: string;
  /**
   * Feature list for the item in the manifest list
   */
  features?: Array<string>;
  /**
   * Images is an optional list of image references to add to manifest list
   */
  images?: Array<string>;
  /**
   * IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
   */
  index_annotation?: Array<string>;
  /**
   * IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
   */
  index_annotations?: {
    [key: string]: string;
  };
  operation?: string;
  /**
   * OS overrides the operating system for the item in the manifest list
   */
  os?: string;
  /**
   * OS features for the item in the manifest list
   */
  os_features?: Array<string>;
  /**
   * OSVersion overrides the operating system for the item in the manifest list
   */
  os_version?: string;
  /**
   * IndexSubject is a subject value to set in the manifest list itself
   */
  subject?: string;
  /**
   * Variant for the item in the manifest list
   */
  variant?: string;
};

export type ManifestModifyReport = {
  /**
   * Manifest List ID
   */
  Id?: string;
  /**
   * Errors associated with operation
   */
  errors?: Array<string>;
  /**
   * Files added to manifest list, otherwise not provided.
   */
  files?: Array<string>;
  /**
   * Images added to or removed from manifest list, otherwise not provided.
   */
  images?: Array<string>;
};

export type ManifestPushReport = {
  /**
   * ID of the pushed manifest
   */
  Id?: string;
  /**
   * Error contains text of errors from pushing
   */
  error?: string;
  /**
   * Stream used to provide push progress
   */
  stream?: string;
};

/**
 * ManifestRemoveOptions provides the model for removing digests from a manifest
 */
export type ManifestRemoveOptions = {
  [key: string]: unknown;
};

export type ManifestRemoveReport = {
  /**
   * Deleted manifest list.
   */
  Deleted?: Array<string>;
  /**
   * Errors associated with operation
   */
  Errors?: Array<string>;
  /**
   * ExitCode describes the exit codes as described in the `podman rmi`
   * man page.
   */
  ExitCode?: number;
  /**
   * Untagged images. Can be longer than Deleted.
   */
  Untagged?: Array<string>;
};

export type ManifestSummary = {
  AttestationData?: AttestationProperties;
  /**
   * Indicates whether all the child content (image config, layers) is
   * fully available locally
   */
  Available: boolean;
  Descriptor: Descriptor;
  /**
   * ID is the content-addressable ID of an image and is the same as the
   * digest of the image manifest.
   */
  ID: string;
  ImageData?: ImageProperties;
  Kind: ManifestKind;
  /**
   * Size is the size information of the content related to this manifest.
   * Note: These sizes only take the locally available content into account.
   */
  Size: {
    /**
     * Content is the size (in bytes) of all the locally present
     * content in the content store (e.g. image config, layers)
     * referenced by this manifest and its children.
     * This only includes blobs in the content store.
     */
    Content?: number;
    /**
     * Total is the total size (in bytes) of all the locally present
     * data (both distributable and non-distributable) that's related to
     * this manifest and its children.
     * This equal to the sum of [Content] size AND all the sizes in the
     * [Size] struct present in the Kind-specific data struct.
     * For example, for an image kind (Kind == ManifestKindImage),
     * this would include the size of the image content and unpacked
     * image snapshots ([Size.Content] + [ImageData.Size.Unpacked]).
     */
    Total?: number;
  };
};

/**
 * Meta is a base object inherited by most of the other once.
 */
export type Meta = {
  CreatedAt?: string;
  UpdatedAt?: string;
  Version?: Version;
};

/**
 * Metadata contains engine-local data about the image.
 */
export type Metadata = {
  /**
   * LastTagTime is the date and time at which the image was last tagged.
   */
  LastTagTime?: string;
};

/**
 * Mount represents a mount (volume).
 */
/**
 * PODMAN TYPES FIXED - Added compatibility fields
 * - Added Mount.Destination alongside Mount.Target for Podman API
 * - Added Mount.RW alongside Mount.ReadOnly for Podman API compatibility
 *
 * Usage:
 * - Docker API: use Target and ReadOnly
 * - Podman API: use Destination, ReadOnly or RW
 */
export type Mount = {
  BindOptions?: BindOptions;
  ClusterOptions?: ClusterOptions;
  Consistency?: Consistency;
  ImageOptions?: ImageOptions;
  ReadOnly?: boolean;
  RW?: boolean; // Podman API compatibility - inverse of ReadOnly
  /**
   * Source specifies the name of the mount. Depending on mount type, this
   * may be a volume name or a host path, or even ignored.
   * Source is not supported for tmpfs (must be an empty value)
   */
  Source?: string;
  Target?: string;
  Destination?: string; // Podman API compatibility
  TmpfsOptions?: TmpfsOptions;
  Type?: Type;
  VolumeOptions?: VolumeOptions;
};

/**
 * MountPoint represents a mount point configuration inside the container.
 * This is used for reporting the mountpoints in use by a container.
 */
export type MountPoint = {
  /**
   * Destination is the path relative to the container root (`/`) where the
   * Source is mounted inside the container.
   */
  Destination?: string;
  /**
   * Driver is the volume driver used to create the volume (if it is a volume).
   */
  Driver?: string;
  /**
   * Mode is a comma separated list of options supplied by the user when
   * creating the bind/volume mount.
   *
   * The default is platform-specific (`"z"` on Linux, empty on Windows).
   */
  Mode?: string;
  /**
   * Name is the name reference to the underlying data defined by `Source`
   * e.g., the volume name.
   */
  Name?: string;
  Propagation?: Propagation;
  /**
   * RW indicates whether the mount is mounted writable (read-write).
   */
  RW?: boolean;
  /**
   * Source is the source location of the mount.
   *
   * For volumes, this contains the storage location of the volume (within
   * `/var/lib/docker/volumes/`). For bind-mounts, and `npipe`, this contains
   * the source (host) part of the bind-mount. For `tmpfs` mount points, this
   * field is empty.
   */
  Source?: string;
  Type?: Type;
};

/**
 * NamedVolume holds information about a named volume that will be mounted into
 * the container.
 */
export type NamedVolume = {
  /**
   * Destination to mount the named volume within the container. Must be
   * an absolute path. Path will be created if it does not exist.
   */
  Dest?: string;
  /**
   * IsAnonymous sets the named volume as anonymous even if it has a name
   * This is used for emptyDir volumes from a kube yaml
   */
  IsAnonymous?: boolean;
  /**
   * Name is the name of the named volume to be mounted. May be empty.
   * If empty, a new named volume with a pseudorandomly generated name
   * will be mounted at the given destination.
   */
  Name?: string;
  /**
   * Options are options that the named volume will be mounted with.
   */
  Options?: Array<string>;
  /**
   * SubPath stores the sub directory of the named volume to be mounted in the container
   */
  SubPath?: string;
};

/**
 * Namespace describes the namespace
 */
export type Namespace = {
  nsmode?: NamespaceMode;
  value?: string;
};

export type NamespaceMode = string;

/**
 * NetAddress contains the ip address, subnet and gateway.
 */
export type NetAddress = {
  /**
   * Gateway for the network. This can be empty if there is no gateway, e.g. internal network.
   */
  gateway?: string;
  ipnet?: IpNet;
};

/**
 * NetInterface contains the settings for a given network interface.
 */
export type NetInterface = {
  /**
   * MacAddress for this Interface.
   */
  mac_address?: string;
  /**
   * Subnets list of assigned subnets with their gateway.
   */
  subnets?: Array<NetAddress>;
};

/**
 * NetOptions reflect the shared network options between
 * pods and containers
 */
export type NetOptions = {
  dns_option?: Array<string>;
  dns_search?: Array<string>;
  dns_server?: Array<string>;
  hostadd?: Array<string>;
  hosts_file?: string;
  netns?: Namespace;
  network_alias?: Array<string>;
  /**
   * NetworkOptions are additional options for each network
   */
  network_options?: {
    [key: string]: Array<string>;
  };
  networks?: {
    [key: string]: PerNetworkOptions;
  };
  no_manage_hostname?: boolean;
  no_manage_hosts?: boolean;
  no_manage_resolv_conf?: boolean;
  portmappings?: Array<PortMapping>;
};

/**
 * Network describes the Network attributes.
 */
export type Network = {
  /**
   * Created contains the timestamp when this network was created.
   */
  created?: string;
  /**
   * DNSEnabled is whether name resolution is active for container on
   * this Network. Only supported with the bridge driver.
   */
  dns_enabled?: boolean;
  /**
   * Driver for this Network, e.g. bridge, macvlan...
   */
  driver?: string;
  /**
   * ID of the Network.
   */
  id?: string;
  /**
   * Internal is whether the Network should not have external routes
   * to public or other Networks.
   */
  internal?: boolean;
  /**
   * IPAMOptions contains options used for the ip assignment.
   */
  ipam_options?: {
    [key: string]: string;
  };
  /**
   * IPv6Enabled if set to true an ipv6 subnet should be created for this net.
   */
  ipv6_enabled?: boolean;
  /**
   * Labels is a set of key-value labels that have been applied to the
   * Network.
   */
  labels?: {
    [key: string]: string;
  };
  /**
   * Name of the Network.
   */
  name?: string;
  /**
   * List of custom DNS server for podman's DNS resolver at network level,
   * all the containers attached to this network will consider resolvers
   * configured at network level.
   */
  network_dns_servers?: Array<string>;
  /**
   * NetworkInterface is the network interface name on the host.
   */
  network_interface?: string;
  /**
   * Options is a set of key-value options that have been applied to
   * the Network.
   */
  options?: {
    [key: string]: string;
  };
  /**
   * Routes to use for this network.
   */
  routes?: Array<Route>;
  /**
   * Subnets to use for this network.
   */
  subnets?: Array<Subnet>;
};

export type NetworkBackend = string;

/**
 * NetworkConnectOptions describes options for connecting
 * a container to a network
 */
export type NetworkConnectOptions = {
  /**
   * Aliases contains a list of names which the dns server should resolve
   * to this container. Should only be set when DNSEnabled is true on the Network.
   * If aliases are set but there is no dns support for this network the
   * network interface implementation should ignore this and NOT error.
   * Optional.
   */
  aliases?: Array<string>;
  container?: string;
  /**
   * InterfaceName for this container. Required in the backend.
   * Optional in the frontend. Will be filled with ethX (where X is a integer) when empty.
   */
  interface_name?: string;
  /**
   * Driver-specific options for this container.
   */
  options?: {
    [key: string]: string;
  };
  /**
   * StaticIPs for this container. Optional.
   */
  static_ips?: Array<string>;
  /**
   * StaticMac for this container. Optional.
   */
  static_mac?: string;
};

export type NetworkContainerInfo = {
  /**
   * Interfaces configured for this container with their addresses
   */
  interfaces?: {
    [key: string]: NetInterface;
  };
  /**
   * Name of the container
   */
  name?: string;
};

/**
 * NetworkInfo contains the network information.
 */
export type NetworkInfo = {
  backend?: NetworkBackend;
  dns?: DnsNetworkInfo;
  package?: string;
  path?: string;
  version?: string;
};

export type NetworkInspectReport = {
  containers?: {
    [key: string]: NetworkContainerInfo;
  };
  /**
   * Created contains the timestamp when this network was created.
   */
  created?: string;
  /**
   * DNSEnabled is whether name resolution is active for container on
   * this Network. Only supported with the bridge driver.
   */
  dns_enabled?: boolean;
  /**
   * Driver for this Network, e.g. bridge, macvlan...
   */
  driver?: string;
  /**
   * ID of the Network.
   */
  id?: string;
  /**
   * Internal is whether the Network should not have external routes
   * to public or other Networks.
   */
  internal?: boolean;
  /**
   * IPAMOptions contains options used for the ip assignment.
   */
  ipam_options?: {
    [key: string]: string;
  };
  /**
   * IPv6Enabled if set to true an ipv6 subnet should be created for this net.
   */
  ipv6_enabled?: boolean;
  /**
   * Labels is a set of key-value labels that have been applied to the
   * Network.
   */
  labels?: {
    [key: string]: string;
  };
  /**
   * Name of the Network.
   */
  name?: string;
  /**
   * List of custom DNS server for podman's DNS resolver at network level,
   * all the containers attached to this network will consider resolvers
   * configured at network level.
   */
  network_dns_servers?: Array<string>;
  /**
   * NetworkInterface is the network interface name on the host.
   */
  network_interface?: string;
  /**
   * Options is a set of key-value options that have been applied to
   * the Network.
   */
  options?: {
    [key: string]: string;
  };
  /**
   * Routes to use for this network.
   */
  routes?: Array<Route>;
  /**
   * Subnets to use for this network.
   */
  subnets?: Array<Subnet>;
};

/**
 * NetworkMode represents the container network stack.
 */
export type NetworkMode = string;

/**
 * NetworkPruneReport containers the name of network and an error
 * associated in its pruning (removal)
 */
export type NetworkPruneReport = {
  Error?: string;
  Name?: string;
};

/**
 * NetworkRmReport describes the results of network removal
 */
export type NetworkRmReport = {
  Err?: string;
  Name?: string;
};

/**
 * NetworkSettings exposes the network settings in the api
 */
export type NetworkSettings = {
  Bridge?: string;
  EndpointID?: string;
  Gateway?: string;
  GlobalIPv6Address?: string;
  GlobalIPv6PrefixLen?: number;
  /**
   * HairpinMode specifies if hairpin NAT should be enabled on the virtual interface
   *
   * Deprecated: This field is never set and will be removed in a future release.
   */
  HairpinMode?: boolean;
  IPAddress?: string;
  IPPrefixLen?: number;
  IPv6Gateway?: string;
  /**
   * LinkLocalIPv6Address is an IPv6 unicast address using the link-local prefix
   *
   * Deprecated: This field is never set and will be removed in a future release.
   */
  LinkLocalIPv6Address?: string;
  /**
   * LinkLocalIPv6PrefixLen is the prefix length of an IPv6 unicast address
   *
   * Deprecated: This field is never set and will be removed in a future release.
   */
  LinkLocalIPv6PrefixLen?: number;
  MacAddress?: string;
  Networks?: {
    [key: string]: EndpointSettings;
  };
  Ports?: PortMap;
  SandboxID?: string;
  SandboxKey?: string;
  SecondaryIPAddresses?: Array<Address>;
  SecondaryIPv6Addresses?: Array<Address>;
};

/**
 * NetworkSettingsSummary provides a summary of container's networks
 * in /containers/json
 */
export type NetworkSettingsSummary = {
  Networks?: {
    [key: string]: EndpointSettings;
  };
};

/**
 * NetworkUpdateOptions describes options to update a network
 */
export type NetworkUpdateOptions = {
  adddnsservers?: Array<string>;
  removednsservers?: Array<string>;
};

/**
 * NetworkingConfig represents the container's networking configuration for each of its interfaces
 * Carries the networking configs specified in the `docker run` and `docker network connect` commands
 */
export type NetworkingConfig = {
  EndpointsConfig?: {
    [key: string]: EndpointSettings;
  };
};

/**
 * OCIRuntimeInfo describes the runtime (crun or runc) being
 * used with podman
 */
export type OciRuntimeInfo = {
  name?: string;
  package?: string;
  path?: string;
  version?: string;
};

/**
 * OverlayVolume holds information about an overlay volume that will be mounted into
 * the container.
 */
export type OverlayVolume = {
  /**
   * Destination is the absolute path where the mount will be placed in the container.
   */
  destination?: string;
  /**
   * Options holds overlay volume options.
   */
  options?: Array<string>;
  /**
   * Source specifies the source path of the mount.
   */
  source?: string;
};

/**
 * POSIXRlimit type and restrictions
 */
export type PosixRlimit = {
  /**
   * Hard is the hard limit for the specified type
   */
  hard?: number;
  /**
   * Soft is the soft limit for the specified type
   */
  soft?: number;
  /**
   * Type of the rlimit to set
   */
  type?: string;
};

/**
 * PastaInfo describes the pasta executable that is being used
 */
export type PastaInfo = {
  executable?: string;
  package?: string;
  version?: string;
};

/**
 * PeerInfo represents one peer of an overlay network
 */
export type PeerInfo = {
  IP?: string;
  Name?: string;
};

/**
 * PerNetworkOptions are options which should be set on a per network basis.
 */
export type PerNetworkOptions = {
  /**
   * Aliases contains a list of names which the dns server should resolve
   * to this container. Should only be set when DNSEnabled is true on the Network.
   * If aliases are set but there is no dns support for this network the
   * network interface implementation should ignore this and NOT error.
   * Optional.
   */
  aliases?: Array<string>;
  /**
   * InterfaceName for this container. Required in the backend.
   * Optional in the frontend. Will be filled with ethX (where X is a integer) when empty.
   */
  interface_name?: string;
  /**
   * Driver-specific options for this container.
   */
  options?: {
    [key: string]: string;
  };
  /**
   * StaticIPs for this container. Optional.
   */
  static_ips?: Array<string>;
  /**
   * StaticMac for this container. Optional.
   */
  static_mac?: string;
};

/**
 * PidMode represents the pid namespace of the container.
 */
export type PidMode = string;

/**
 * Platform describes the platform which the image in the manifest runs on.
 */
export type Platform = {
  /**
   * Architecture field specifies the CPU architecture, for example
   * `amd64` or `ppc64le`.
   */
  architecture?: string;
  /**
   * OS specifies the operating system, for example `linux` or `windows`.
   */
  os?: string;
  /**
   * OSFeatures is an optional field specifying an array of strings,
   * each listing a required OS feature (for example on Windows `win32k`).
   */
  'os.features'?: Array<string>;
  /**
   * OSVersion is an optional field specifying the operating system
   * version, for example on Windows `10.0.14393.1066`.
   */
  'os.version'?: string;
  /**
   * Variant is an optional field specifying a variant of the CPU, for
   * example `v7` to specify ARMv7 when architecture is `arm`.
   */
  variant?: string;
};

export type PlayKubePod = {
  /**
   * ContainerErrors - any errors that occurred while starting containers
   * in the pod.
   */
  ContainerErrors?: Array<string>;
  /**
   * Containers - the IDs of the containers running in the created pod.
   */
  Containers?: Array<string>;
  /**
   * ID - ID of the pod created as a result of play kube.
   */
  ID?: string;
  /**
   * InitContainers - the IDs of the init containers to be run in the created pod.
   */
  InitContainers?: Array<string>;
  /**
   * Logs - non-fatal errors and log messages while processing.
   */
  Logs?: Array<string>;
};

export type PlayKubeReport = {
  /**
   * If set, exit with the specified exit code.
   */
  ExitCode?: number;
  /**
   * Pods - pods created by play kube.
   */
  Pods?: Array<PlayKubePod>;
  RmReport?: Array<PodRmReport>;
  SecretRmReport?: Array<SecretRmReport>;
  /**
   * Secrets - secrets created by play kube
   */
  Secrets?: Array<PlaySecret>;
  /**
   * ServiceContainerID - ID of the service container if one is created
   */
  ServiceContainerID?: string;
  StopReport?: Array<PodStopReport>;
  VolumeRmReport?: Array<VolumeRmReport>;
  /**
   * Volumes - volumes created by play kube.
   */
  Volumes?: Array<PlayKubeVolume>;
};

export type PlayKubeVolume = {
  /**
   * Name - Name of the volume created by play kube.
   */
  Name?: string;
};

export type PlaySecret = {
  CreateReport?: SecretCreateReport;
};

/**
 * Plugin A plugin for the Engine API
 */
export type Plugin = {
  Config: PluginConfig;
  /**
   * True if the plugin is running. False if the plugin is not running, only installed.
   */
  Enabled: boolean;
  /**
   * Id
   */
  Id?: string;
  /**
   * name
   */
  Name: string;
  /**
   * plugin remote reference used to push/pull the plugin
   */
  PluginReference?: string;
  Settings: PluginSettings;
};

/**
 * PluginConfig The config of a plugin.
 */
export type PluginConfig = {
  Args: PluginConfigArgs;
  /**
   * description
   */
  Description: string;
  /**
   * Docker Version used to create the plugin
   */
  DockerVersion?: string;
  /**
   * documentation
   */
  Documentation: string;
  /**
   * entrypoint
   */
  Entrypoint: Array<string>;
  /**
   * env
   */
  Env: Array<PluginEnv>;
  Interface: PluginConfigInterface;
  /**
   * ipc host
   */
  IpcHost: boolean;
  Linux: PluginConfigLinux;
  /**
   * mounts
   */
  Mounts: Array<PluginMount>;
  Network: PluginConfigNetwork;
  /**
   * pid host
   */
  PidHost: boolean;
  /**
   * propagated mount
   */
  PropagatedMount: string;
  User?: PluginConfigUser;
  /**
   * work dir
   */
  WorkDir: string;
  rootfs?: PluginConfigRootfs;
};

/**
 * PluginConfigArgs plugin config args
 */
export type PluginConfigArgs = {
  /**
   * description
   */
  Description: string;
  /**
   * name
   */
  Name: string;
  /**
   * settable
   */
  Settable: Array<string>;
  /**
   * value
   */
  Value: Array<string>;
};

/**
 * PluginConfigInterface The interface between Docker and the plugin
 */
export type PluginConfigInterface = {
  /**
   * Protocol to use for clients connecting to the plugin.
   */
  ProtocolScheme?: string;
  /**
   * socket
   */
  Socket: string;
  /**
   * types
   */
  Types: Array<PluginInterfaceType>;
};

/**
 * PluginConfigLinux plugin config linux
 */
export type PluginConfigLinux = {
  /**
   * allow all devices
   */
  AllowAllDevices: boolean;
  /**
   * capabilities
   */
  Capabilities: Array<string>;
  /**
   * devices
   */
  Devices: Array<PluginDevice>;
};

/**
 * PluginConfigNetwork plugin config network
 */
export type PluginConfigNetwork = {
  /**
   * type
   */
  Type: string;
};

/**
 * PluginConfigRootfs plugin config rootfs
 */
export type PluginConfigRootfs = {
  /**
   * diff ids
   */
  diff_ids?: Array<string>;
  /**
   * type
   */
  type?: string;
};

/**
 * PluginConfigUser plugin config user
 */
export type PluginConfigUser = {
  /**
   * g ID
   */
  GID?: number;
  /**
   * UID
   */
  UID?: number;
};

/**
 * PluginDevice plugin device
 */
export type PluginDevice = {
  /**
   * description
   */
  Description: string;
  /**
   * name
   */
  Name: string;
  /**
   * path
   */
  Path: string;
  /**
   * settable
   */
  Settable: Array<string>;
};

/**
 * PluginEnv plugin env
 */
export type PluginEnv = {
  /**
   * description
   */
  Description: string;
  /**
   * name
   */
  Name: string;
  /**
   * settable
   */
  Settable: Array<string>;
  /**
   * value
   */
  Value: string;
};

/**
 * PluginInterfaceType plugin interface type
 */
export type PluginInterfaceType = {
  /**
   * capability
   */
  Capability: string;
  /**
   * prefix
   */
  Prefix: string;
  /**
   * version
   */
  Version: string;
};

/**
 * PluginMount plugin mount
 */
export type PluginMount = {
  /**
   * description
   */
  Description: string;
  /**
   * destination
   */
  Destination: string;
  /**
   * name
   */
  Name: string;
  /**
   * options
   */
  Options: Array<string>;
  /**
   * settable
   */
  Settable: Array<string>;
  /**
   * source
   */
  Source: string;
  /**
   * type
   */
  Type: string;
};

/**
 * PluginSettings Settings that can be modified by users.
 */
export type PluginSettings = {
  /**
   * args
   */
  Args: Array<string>;
  /**
   * devices
   */
  Devices: Array<PluginDevice>;
  /**
   * env
   */
  Env: Array<string>;
  /**
   * mounts
   */
  Mounts: Array<PluginMount>;
};

export type Plugins = {
  /**
   * Authorization is provided for compatibility, will always be nil as Podman has no daemon
   */
  authorization?: Array<string>;
  log?: Array<string>;
  network?: Array<string>;
  volume?: Array<string>;
};

/**
 * PodBasicConfig contains basic configuration options for pods.
 */
export type PodBasicConfig = {
  /**
   * ExitPolicy determines the pod's exit and stop behaviour.
   */
  exit_policy?: string;
  /**
   * Hostname is the pod's hostname. If not set, the name of the pod will
   * be used (if a name was not provided here, the name auto-generated for
   * the pod will be used). This will be used by the infra container and
   * all containers in the pod as long as the UTS namespace is shared.
   * Optional.
   */
  hostname?: string;
  /**
   * InfraCommand sets the command that will be used to start the infra
   * container.
   * If not set, the default set in the Libpod configuration file will be
   * used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  infra_command?: Array<string>;
  /**
   * InfraConmonPidFile is a custom path to store the infra container's
   * conmon PID.
   */
  infra_conmon_pid_file?: string;
  /**
   * InfraImage is the image that will be used for the infra container.
   * If not set, the default set in the Libpod configuration file will be
   * used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  infra_image?: string;
  /**
   * InfraName is the name that will be used for the infra container.
   * If not set, the default set in the Libpod configuration file will be
   * used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  infra_name?: string;
  ipcns?: Namespace;
  /**
   * Labels are key-value pairs that are used to add metadata to pods.
   * Optional.
   */
  labels?: {
    [key: string]: string;
  };
  /**
   * Name is the name of the pod.
   * If not provided, a name will be generated when the pod is created.
   * Optional.
   */
  name?: string;
  /**
   * NoInfra tells the pod not to create an infra container. If this is
   * done, many networking-related options will become unavailable.
   * Conflicts with setting any options in PodNetworkConfig, and the
   * InfraCommand and InfraImages in this struct.
   * Optional.
   */
  no_infra?: boolean;
  pidns?: Namespace;
  pod_create_command?: Array<string>;
  /**
   * Devices contains user specified Devices to be added to the Pod
   */
  pod_devices?: Array<string>;
  /**
   * RestartPolicy is the pod's restart policy - an action which
   * will be taken when one or all the containers in the pod exits.
   * If not given, the default policy will be set to Always, which
   * restarts the containers in the pod when they exit indefinitely.
   * Optional.
   */
  restart_policy?: string;
  /**
   * RestartRetries is the number of attempts that will be made to restart
   * the container.
   * Only available when RestartPolicy is set to "on-failure".
   * Optional.
   */
  restart_tries?: number;
  /**
   * PodCreateCommand is the command used to create this pod.
   * This will be shown in the output of Inspect() on the pod, and may
   * also be used by some tools that wish to recreate the pod
   * (e.g. `podman generate systemd --new`).
   * Optional.
   * ShareParent determines if all containers in the pod will share the pod's cgroup as the cgroup parent
   */
  share_parent?: boolean;
  /**
   * SharedNamespaces instructs the pod to share a set of namespaces.
   * Shared namespaces will be joined (by default) by every container
   * which joins the pod.
   * If not set and NoInfra is false, the pod will set a default set of
   * namespaces to share.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  shared_namespaces?: Array<string>;
  /**
   * Sysctl sets kernel parameters for the pod
   */
  sysctl?: {
    [key: string]: string;
  };
  userns?: Namespace;
  utsns?: Namespace;
};

/**
 * PodCgroupConfig contains configuration options about a pod's cgroups.
 * This will be expanded in future updates to pods.
 */
export type PodCgroupConfig = {
  /**
   * CgroupParent is the parent for the Cgroup that the pod will create.
   * This pod cgroup will, in turn, be the default cgroup parent for all
   * containers in the pod.
   * Optional.
   */
  cgroup_parent?: string;
};

/**
 * PodCreateOptions provides all possible options for creating a pod and its infra container.
 * The JSON tags below are made to match the respective field in ContainerCreateOptions for the purpose of mapping.
 */
export type PodCreateOptions = {
  cgroup_parent?: string;
  container_command?: string;
  container_conmon_pidfile?: string;
  container_name?: string;
  cpus?: number;
  cpuset_cpus?: string;
  create_command?: Array<string>;
  device_read_bps?: Array<string>;
  devices?: Array<string>;
  exit_policy?: string;
  hostname?: string;
  infra?: boolean;
  infra_image?: string;
  ipc?: string;
  labels?: {
    [key: string]: string;
  };
  name?: string;
  net?: NetOptions;
  pid?: string;
  restart?: string;
  security_opt?: Array<string>;
  share?: Array<string>;
  share_parent?: boolean;
  sysctl?: Array<string>;
  uts?: string;
  volume?: Array<string>;
  volumes_from?: Array<string>;
};

export type PodKillReport = {
  Errs?: Array<string>;
  Id?: string;
};

/**
 * PodNetworkConfig contains networking configuration for a pod.
 */
export type PodNetworkConfig = {
  /**
   * Map of networks names to ids the container should join to.
   * You can request additional settings for each network, you can
   * set network aliases, static ips, static mac address  and the
   * network interface name for this container on the specific network.
   * If the map is empty and the bridge network mode is set the container
   * will be joined to the default network.
   */
  Networks?: {
    [key: string]: PerNetworkOptions;
  };
  /**
   * CNINetworks is a list of CNI networks to join the container to.
   * If this list is empty, the default CNI network will be joined
   * instead. If at least one entry is present, we will not join the
   * default network (unless it is part of this list).
   * Only available if NetNS is set to bridge.
   * Optional.
   * Deprecated: as of podman 4.0 use "Networks" instead.
   */
  cni_networks?: Array<string>;
  /**
   * DNSOption is a set of DNS options that will be used in the infra
   * container's resolv.conf, which will, by default, be shared with all
   * containers in the pod.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  dns_option?: Array<string>;
  /**
   * DNSSearch is a set of DNS search domains that will be used in the
   * infra container's resolv.conf, which will, by default, be shared with
   * all containers in the pod.
   * If not provided, DNS search domains from the host's resolv.conf will
   * be used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  dns_search?: Array<string>;
  /**
   * DNSServer is a set of DNS servers that will be used in the infra
   * container's resolv.conf, which will, by default, be shared with all
   * containers in the pod.
   * If not provided, the host's DNS servers will be used, unless the only
   * server set is a localhost address. As the container cannot connect to
   * the host's localhost, a default server will instead be set.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  dns_server?: Array<string>;
  /**
   * HostAdd is a set of hosts that will be added to the infra container's
   * etc/hosts that will, by default, be shared with all containers in
   * the pod.
   * Conflicts with NoInfra=true and NoManageHosts.
   * Optional.
   */
  hostadd?: Array<string>;
  /**
   * HostsFile is the base file to create the `/etc/hosts` file inside the infra container.
   * This must either be an absolute path to a file on the host system, or one of the
   * special flags `image` or `none`.
   * If it is empty it defaults to the base_hosts_file configuration in containers.conf.
   * Conflicts with NoInfra=true and NoManageHosts.
   * Optional.
   */
  hostsFile?: string;
  netns?: Namespace;
  /**
   * NetworkOptions are additional options for each network
   * Optional.
   */
  network_options?: {
    [key: string]: Array<string>;
  };
  /**
   * NoManageHostname indicates that /etc/hostname should not be managed
   * by the pod. Instead, each container will create a separate
   * etc/hostname as they would if not in a pod.
   */
  no_manage_hostname?: boolean;
  /**
   * NoManageHosts indicates that /etc/hosts should not be managed by the
   * pod. Instead, each container will create a separate /etc/hosts as
   * they would if not in a pod.
   * Conflicts with HostAdd.
   */
  no_manage_hosts?: boolean;
  /**
   * NoManageResolvConf indicates that /etc/resolv.conf should not be
   * managed by the pod. Instead, each container will create and manage a
   * separate resolv.conf as if they had not joined a pod.
   * Conflicts with NoInfra=true and DNSServer, DNSSearch, DNSOption.
   * Optional.
   */
  no_manage_resolv_conf?: boolean;
  /**
   * PortMappings is a set of ports to map into the infra container.
   * As, by default, containers share their network with the infra
   * container, this will forward the ports to the entire pod.
   * Only available if NetNS is set to Bridge, Slirp, or Pasta.
   * Optional.
   */
  portmappings?: Array<PortMapping>;
};

export type PodPauseReport = {
  Errs?: Array<string>;
  Id?: string;
};

export type PodPruneReport = {
  Err?: string;
  Id?: string;
};

export type PodResourceConfig = {
  resource_limits?: LinuxResources;
};

export type PodRestartReport = {
  Errs?: Array<string>;
  Id?: string;
};

export type PodRmReport = {
  Err?: string;
  Id?: string;
  RemovedCtrs?: {
    [key: string]: string;
  };
};

export type PodSecurityConfig = {
  idmappings?: IdMappingOptions;
  security_opt?: Array<string>;
};

/**
 * PodSpecGenerator describes options to create a pod
 */
export type PodSpecGenerator = {
  /**
   * Map of networks names to ids the container should join to.
   * You can request additional settings for each network, you can
   * set network aliases, static ips, static mac address  and the
   * network interface name for this container on the specific network.
   * If the map is empty and the bridge network mode is set the container
   * will be joined to the default network.
   */
  Networks?: {
    [key: string]: PerNetworkOptions;
  };
  /**
   * CgroupParent is the parent for the Cgroup that the pod will create.
   * This pod cgroup will, in turn, be the default cgroup parent for all
   * containers in the pod.
   * Optional.
   */
  cgroup_parent?: string;
  /**
   * CNINetworks is a list of CNI networks to join the container to.
   * If this list is empty, the default CNI network will be joined
   * instead. If at least one entry is present, we will not join the
   * default network (unless it is part of this list).
   * Only available if NetNS is set to bridge.
   * Optional.
   * Deprecated: as of podman 4.0 use "Networks" instead.
   */
  cni_networks?: Array<string>;
  /**
   * DNSOption is a set of DNS options that will be used in the infra
   * container's resolv.conf, which will, by default, be shared with all
   * containers in the pod.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  dns_option?: Array<string>;
  /**
   * DNSSearch is a set of DNS search domains that will be used in the
   * infra container's resolv.conf, which will, by default, be shared with
   * all containers in the pod.
   * If not provided, DNS search domains from the host's resolv.conf will
   * be used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  dns_search?: Array<string>;
  /**
   * DNSServer is a set of DNS servers that will be used in the infra
   * container's resolv.conf, which will, by default, be shared with all
   * containers in the pod.
   * If not provided, the host's DNS servers will be used, unless the only
   * server set is a localhost address. As the container cannot connect to
   * the host's localhost, a default server will instead be set.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  dns_server?: Array<string>;
  /**
   * ExitPolicy determines the pod's exit and stop behaviour.
   */
  exit_policy?: string;
  /**
   * HostAdd is a set of hosts that will be added to the infra container's
   * etc/hosts that will, by default, be shared with all containers in
   * the pod.
   * Conflicts with NoInfra=true and NoManageHosts.
   * Optional.
   */
  hostadd?: Array<string>;
  /**
   * Hostname is the pod's hostname. If not set, the name of the pod will
   * be used (if a name was not provided here, the name auto-generated for
   * the pod will be used). This will be used by the infra container and
   * all containers in the pod as long as the UTS namespace is shared.
   * Optional.
   */
  hostname?: string;
  /**
   * HostsFile is the base file to create the `/etc/hosts` file inside the infra container.
   * This must either be an absolute path to a file on the host system, or one of the
   * special flags `image` or `none`.
   * If it is empty it defaults to the base_hosts_file configuration in containers.conf.
   * Conflicts with NoInfra=true and NoManageHosts.
   * Optional.
   */
  hostsFile?: string;
  idmappings?: IdMappingOptions;
  /**
   * Image volumes bind-mount a container-image mount into the pod's infra container.
   * Optional.
   */
  image_volumes?: Array<ImageVolume>;
  /**
   * InfraCommand sets the command that will be used to start the infra
   * container.
   * If not set, the default set in the Libpod configuration file will be
   * used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  infra_command?: Array<string>;
  /**
   * InfraConmonPidFile is a custom path to store the infra container's
   * conmon PID.
   */
  infra_conmon_pid_file?: string;
  /**
   * InfraImage is the image that will be used for the infra container.
   * If not set, the default set in the Libpod configuration file will be
   * used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  infra_image?: string;
  /**
   * InfraName is the name that will be used for the infra container.
   * If not set, the default set in the Libpod configuration file will be
   * used.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  infra_name?: string;
  ipcns?: Namespace;
  /**
   * Labels are key-value pairs that are used to add metadata to pods.
   * Optional.
   */
  labels?: {
    [key: string]: string;
  };
  /**
   * Mounts are mounts that will be added to the pod.
   * These will supersede Image Volumes and VolumesFrom volumes where
   * there are conflicts.
   * Optional.
   */
  mounts?: Array<Mount>;
  /**
   * Name is the name of the pod.
   * If not provided, a name will be generated when the pod is created.
   * Optional.
   */
  name?: string;
  netns?: Namespace;
  /**
   * NetworkOptions are additional options for each network
   * Optional.
   */
  network_options?: {
    [key: string]: Array<string>;
  };
  /**
   * NoInfra tells the pod not to create an infra container. If this is
   * done, many networking-related options will become unavailable.
   * Conflicts with setting any options in PodNetworkConfig, and the
   * InfraCommand and InfraImages in this struct.
   * Optional.
   */
  no_infra?: boolean;
  /**
   * NoManageHostname indicates that /etc/hostname should not be managed
   * by the pod. Instead, each container will create a separate
   * etc/hostname as they would if not in a pod.
   */
  no_manage_hostname?: boolean;
  /**
   * NoManageHosts indicates that /etc/hosts should not be managed by the
   * pod. Instead, each container will create a separate /etc/hosts as
   * they would if not in a pod.
   * Conflicts with HostAdd.
   */
  no_manage_hosts?: boolean;
  /**
   * NoManageResolvConf indicates that /etc/resolv.conf should not be
   * managed by the pod. Instead, each container will create and manage a
   * separate resolv.conf as if they had not joined a pod.
   * Conflicts with NoInfra=true and DNSServer, DNSSearch, DNSOption.
   * Optional.
   */
  no_manage_resolv_conf?: boolean;
  /**
   * Overlay volumes are named volumes that will be added to the pod.
   * Optional.
   */
  overlay_volumes?: Array<OverlayVolume>;
  pidns?: Namespace;
  pod_create_command?: Array<string>;
  /**
   * Devices contains user specified Devices to be added to the Pod
   */
  pod_devices?: Array<string>;
  /**
   * PortMappings is a set of ports to map into the infra container.
   * As, by default, containers share their network with the infra
   * container, this will forward the ports to the entire pod.
   * Only available if NetNS is set to Bridge, Slirp, or Pasta.
   * Optional.
   */
  portmappings?: Array<PortMapping>;
  resource_limits?: LinuxResources;
  /**
   * RestartPolicy is the pod's restart policy - an action which
   * will be taken when one or all the containers in the pod exits.
   * If not given, the default policy will be set to Always, which
   * restarts the containers in the pod when they exit indefinitely.
   * Optional.
   */
  restart_policy?: string;
  /**
   * RestartRetries is the number of attempts that will be made to restart
   * the container.
   * Only available when RestartPolicy is set to "on-failure".
   * Optional.
   */
  restart_tries?: number;
  security_opt?: Array<string>;
  /**
   * The ID of the pod's service container.
   */
  serviceContainerID?: string;
  /**
   * PodCreateCommand is the command used to create this pod.
   * This will be shown in the output of Inspect() on the pod, and may
   * also be used by some tools that wish to recreate the pod
   * (e.g. `podman generate systemd --new`).
   * Optional.
   * ShareParent determines if all containers in the pod will share the pod's cgroup as the cgroup parent
   */
  share_parent?: boolean;
  /**
   * SharedNamespaces instructs the pod to share a set of namespaces.
   * Shared namespaces will be joined (by default) by every container
   * which joins the pod.
   * If not set and NoInfra is false, the pod will set a default set of
   * namespaces to share.
   * Conflicts with NoInfra=true.
   * Optional.
   */
  shared_namespaces?: Array<string>;
  /**
   * ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes.
   * Conflicts with ShmSize if IpcNS is not private.
   * Optional.
   */
  shm_size?: number;
  /**
   * ShmSizeSystemd is the size of systemd-specific tmpfs mounts
   * specifically /run, /run/lock, /var/log/journal and /tmp.
   * Optional
   */
  shm_size_systemd?: number;
  /**
   * Sysctl sets kernel parameters for the pod
   */
  sysctl?: {
    [key: string]: string;
  };
  userns?: Namespace;
  utsns?: Namespace;
  /**
   * Volumes are named volumes that will be added to the pod.
   * These will supersede Image Volumes and VolumesFrom  volumes where
   * there are conflicts.
   * Optional.
   */
  volumes?: Array<NamedVolume>;
  /**
   * VolumesFrom is a set of containers whose volumes will be added to
   * this pod. The name or ID of the container must be provided, and
   * may optionally be followed by a : and then one or more
   * comma-separated options. Valid options are 'ro', 'rw', and 'z'.
   * Options will be used for all volumes sourced from the container.
   */
  volumes_from?: Array<string>;
};

export type PodStartReport = {
  Errs?: Array<string>;
  Id?: string;
  RawInput?: string;
};

/**
 * PodStatsReport includes pod-resource statistics data.
 */
export type PodStatsReport = {
  /**
   * Humanized disk usage read + write
   */
  BlockIO?: string;
  /**
   * Container ID
   */
  CID?: string;
  /**
   * Percentage of CPU utilized by pod
   */
  CPU?: string;
  /**
   * Percentage of Memory utilized by pod
   */
  Mem?: string;
  /**
   * Humanized Memory usage and maximum
   */
  MemUsage?: string;
  /**
   * Memory usage and maximum in bytes
   */
  MemUsageBytes?: string;
  /**
   * Pod Name
   */
  Name?: string;
  /**
   * Network usage inbound + outbound
   */
  NetIO?: string;
  /**
   * Container PID
   */
  PIDS?: string;
  /**
   * Pod ID
   */
  Pod?: string;
};

export type PodStopReport = {
  Errs?: Array<string>;
  Id?: string;
  RawInput?: string;
};

/**
 * PodStorageConfig contains all of the storage related options for the pod and its infra container.
 */
export type PodStorageConfig = {
  /**
   * Image volumes bind-mount a container-image mount into the pod's infra container.
   * Optional.
   */
  image_volumes?: Array<ImageVolume>;
  /**
   * Mounts are mounts that will be added to the pod.
   * These will supersede Image Volumes and VolumesFrom volumes where
   * there are conflicts.
   * Optional.
   */
  mounts?: Array<Mount>;
  /**
   * Overlay volumes are named volumes that will be added to the pod.
   * Optional.
   */
  overlay_volumes?: Array<OverlayVolume>;
  /**
   * ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes.
   * Conflicts with ShmSize if IpcNS is not private.
   * Optional.
   */
  shm_size?: number;
  /**
   * ShmSizeSystemd is the size of systemd-specific tmpfs mounts
   * specifically /run, /run/lock, /var/log/journal and /tmp.
   * Optional
   */
  shm_size_systemd?: number;
  /**
   * Volumes are named volumes that will be added to the pod.
   * These will supersede Image Volumes and VolumesFrom  volumes where
   * there are conflicts.
   * Optional.
   */
  volumes?: Array<NamedVolume>;
  /**
   * VolumesFrom is a set of containers whose volumes will be added to
   * this pod. The name or ID of the container must be provided, and
   * may optionally be followed by a : and then one or more
   * comma-separated options. Valid options are 'ro', 'rw', and 'z'.
   * Options will be used for all volumes sourced from the container.
   */
  volumes_from?: Array<string>;
};

export type PodTopOkBody = {
  /**
   * Each process running in the container, where each process
   * is an array of values corresponding to the titles.
   */
  Processes?: Array<Array<string>>;
  /**
   * The ps column titles
   */
  Titles?: Array<string>;
};

export type PodUnpauseReport = {
  Errs?: Array<string>;
  Id?: string;
};

/**
 * Port An open port on a container
 */
export type Port = {
  /**
   * Host IP address that the container's port is mapped to
   */
  IP?: string;
  /**
   * Port on the container
   */
  PrivatePort: number;
  /**
   * Port exposed on the host
   */
  PublicPort?: number;
  /**
   * type
   */
  Type: string;
};

/**
 * PortBinding represents a binding between a Host IP address and a Host Port
 */
export type PortBinding = {
  /**
   * HostIP is the host IP Address
   */
  HostIp?: string;
  /**
   * HostPort is the host port number
   */
  HostPort?: string;
};

/**
 * PortMap is a collection of PortBinding indexed by Port
 */
export type PortMap = {
  [key: string]: Array<PortBinding>;
};

/**
 * PortMapping is one or more ports that will be mapped into the container.
 */
export type PortMapping = {
  /**
   * ContainerPort is the port number that will be exposed from the
   * container.
   * Mandatory.
   */
  container_port?: number;
  /**
   * HostIP is the IP that we will bind to on the host.
   * If unset, assumed to be 0.0.0.0 (all interfaces).
   */
  host_ip?: string;
  /**
   * HostPort is the port number that will be forwarded from the host into
   * the container.
   * If omitted, a random port on the host (guaranteed to be over 1024)
   * will be assigned.
   */
  host_port?: number;
  /**
   * Protocol is the protocol forward.
   * Must be either "tcp", "udp", and "sctp", or some combination of these
   * separated by commas.
   * If unset, assumed to be TCP.
   */
  protocol?: string;
  /**
   * Range is the number of ports that will be forwarded, starting at
   * HostPort and ContainerPort and counting up.
   * This is 1-indexed, so 1 is assumed to be a single port (only the
   * Hostport:Containerport mapping will be added), 2 is two ports (both
   * Hostport:Containerport and Hostport+1:Containerport+1), etc.
   * If unset, assumed to be 1 (a single port).
   * Both hostport + range and containerport + range must be less than
   * 65536.
   */
  range?: number;
};

/**
 * PortSet is a collection of structs indexed by Port
 */
export type PortSet = {
  [key: string]: {
    [key: string]: unknown;
  };
};

/**
 * Propagation represents the propagation of a mount.
 */
export type Propagation = string;

/**
 * PruneReport contains the response for Engine API:
 * POST "/volumes/prune"
 */
export type PruneReport = {
  Err?: string;
  Id?: string;
  Size?: number;
};

/**
 * PublishState represents the state of a Volume as it pertains to its
 * use on a particular Node.
 */
export type PublishState = string;

/**
 * PublishStatus represents the status of the volume as published to an
 * individual node
 */
export type PublishStatus = {
  /**
   * NodeID is the ID of the swarm node this Volume is published to.
   */
  NodeID?: string;
  /**
   * PublishContext is the PublishContext returned by the CSI plugin when
   * a volume is published.
   */
  PublishContext?: {
    [key: string]: string;
  };
  State?: PublishState;
};

/**
 * RemoteSocket describes information about the API socket
 */
export type RemoteSocket = {
  exists?: boolean;
  path?: string;
};

/**
 * Resources contains container's resources (cgroups config, ulimits...)
 */
export type Resources = {
  BlkioDeviceReadBps?: Array<ThrottleDevice>;
  BlkioDeviceReadIOps?: Array<ThrottleDevice>;
  BlkioDeviceWriteBps?: Array<ThrottleDevice>;
  BlkioDeviceWriteIOps?: Array<ThrottleDevice>;
  BlkioWeight?: number;
  BlkioWeightDevice?: Array<WeightDevice>;
  /**
   * Applicable to UNIX platforms
   */
  CgroupParent?: string;
  /**
   * Applicable to Windows
   */
  CpuCount?: number;
  CpuPercent?: number;
  CpuPeriod?: number;
  CpuQuota?: number;
  CpuRealtimePeriod?: number;
  CpuRealtimeRuntime?: number;
  /**
   * Applicable to all platforms
   */
  CpuShares?: number;
  CpusetCpus?: string;
  CpusetMems?: string;
  DeviceCgroupRules?: Array<string>;
  DeviceRequests?: Array<DeviceRequest>;
  Devices?: Array<DeviceMapping>;
  IOMaximumBandwidth?: number;
  IOMaximumIOps?: number;
  /**
   * KernelMemory specifies the kernel memory limit (in bytes) for the container.
   * Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
   */
  KernelMemory?: number;
  KernelMemoryTCP?: number;
  Memory?: number;
  MemoryReservation?: number;
  MemorySwap?: number;
  MemorySwappiness?: number;
  NanoCpus?: number;
  OomKillDisable?: boolean;
  PidsLimit?: number;
  Ulimits?: Array<Ulimit>;
};

/**
 * RestartPolicy represents the restart policies of the container.
 */
export type RestartPolicy = {
  MaximumRetryCount?: number;
  Name?: RestartPolicyMode;
};

export type RestartPolicyMode = string;

/**
 * RootFS holds the root fs information of an image.
 */
export type RootFs = {
  Layers?: Array<Digest>;
  Type?: string;
};

export type Route = {
  /**
   * Destination for this route in CIDR form.
   */
  destination?: string;
  /**
   * Gateway IP for this route.
   */
  gateway?: string;
  /**
   * Metric for this route. Optional.
   */
  metric?: number;
};

/**
 * Schema2HealthConfig is a HealthConfig, which holds configuration settings
 * for the HEALTHCHECK feature, from docker/docker/api/types/container.
 */
export type Schema2HealthConfig = {
  Interval?: Duration;
  /**
   * Retries is the number of consecutive failures needed to consider a container as unhealthy.
   * Zero means inherit.
   */
  Retries?: number;
  StartInterval?: Duration;
  StartPeriod?: Duration;
  /**
   * Test is the test to perform to check that the container is healthy.
   * An empty slice means to inherit the default.
   * The options are:
   * {} : inherit healthcheck
   * {"NONE"} : disable healthcheck
   * {"CMD", args...} : exec arguments directly
   * {"CMD-SHELL", command} : run command with system's default shell
   */
  Test?: Array<string>;
  Timeout?: Duration;
};

/**
 * Schema2ListPublic is a list of platform-specific manifests.
 * This is publicly visible as c/image/manifest.Schema2List.
 * Internal users should usually use Schema2List instead.
 */
export type Schema2ListPublic = {
  manifests?: Array<Schema2ManifestDescriptor>;
  mediaType?: string;
  schemaVersion?: number;
};

/**
 * Schema2ManifestDescriptor references a platform-specific manifest.
 * This is publicly visible as c/image/manifest.Schema2ManifestDescriptor.
 */
export type Schema2ManifestDescriptor = {
  digest?: Digest;
  mediaType?: string;
  platform?: Schema2PlatformSpec;
  size?: number;
  urls?: Array<string>;
};

/**
 * Schema2PlatformSpec describes the platform which a particular manifest is
 * specialized for.
 * This is publicly visible as c/image/manifest.Schema2PlatformSpec.
 */
export type Schema2PlatformSpec = {
  architecture?: string;
  features?: Array<string>;
  os?: string;
  'os.features'?: Array<string>;
  'os.version'?: string;
  variant?: string;
};

/**
 * Scope defines the Scope of a Cluster Volume. This is how many nodes a
 * Volume can be accessed simultaneously on.
 */
export type Scope = string;

export type ScpReport = {
  Id?: string;
};

/**
 * Secret represents a Swarm Secret value that must be passed to the CSI
 * storage plugin when operating on this Volume. It represents one key-value
 * pair of possibly many.
 */
export type Secret = {
  /**
   * Key is the name of the key of the key-value pair passed to the plugin.
   */
  Key?: string;
  /**
   * Secret is the swarm Secret object from which to read data. This can be a
   * Secret name or ID. The Secret data is retrieved by Swarm and used as the
   * value of the key-value pair passed to the plugin.
   */
  Secret?: string;
};

export type SecretCreate = {
  /**
   * Base64-url-safe-encoded (RFC 4648) data to store as secret.
   */
  Data?: string;
  Driver?: SecretDriverSpec;
  /**
   * Labels are labels on the secret
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * User-defined name of the secret.
   */
  Name?: string;
};

export type SecretCreateReport = {
  ID?: string;
};

export type SecretDriverSpec = {
  Name?: string;
  Options?: {
    [key: string]: string;
  };
};

export type SecretInfoReport = {
  CreatedAt?: string;
  ID?: string;
  SecretData?: string;
  Spec?: SecretSpec;
  UpdatedAt?: string;
};

export type SecretInfoReportCompat = {
  CreatedAt?: string;
  ID?: string;
  SecretData?: string;
  Spec?: SecretSpec;
  UpdatedAt?: string;
  Version?: SecretVersion;
};

export type SecretRmReport = {
  Err?: string;
  ID?: string;
};

export type SecretSpec = {
  Driver?: SecretDriverSpec;
  Labels?: {
    [key: string]: string;
  };
  Name?: string;
};

export type SecretVersion = {
  Index?: number;
};

/**
 * SecurityInfo describes the libpod host
 */
export type SecurityInfo = {
  apparmorEnabled?: boolean;
  capabilities?: string;
  rootless?: boolean;
  seccompEnabled?: boolean;
  seccompProfilePath?: string;
  selinuxEnabled?: boolean;
};

/**
 * ServiceCreateResponse contains the information returned to a client on the
 * creation of a new service.
 */
export type ServiceCreateResponse = {
  /**
   * The ID of the created service.
   */
  ID?: string;
  /**
   * Optional warning message.
   *
   * FIXME(thaJeztah): this should have "omitempty" in the generated type.
   */
  Warnings?: Array<string>;
};

/**
 * ServiceInfo represents service parameters with the list of service's tasks
 */
export type ServiceInfo = {
  LocalLBIndex?: number;
  Ports?: Array<string>;
  Tasks?: Array<Task>;
  VIP?: string;
};

/**
 * ServiceUpdateResponse service update response
 */
export type ServiceUpdateResponse = {
  /**
   * Optional warning messages
   */
  Warnings?: Array<string>;
};

/**
 * SharingMode defines the Sharing of a Cluster Volume. This is how Tasks using a
 * Volume at the same time can use it.
 */
export type SharingMode = string;

/**
 * A Signal is a number describing a process signal.
 * It implements the [os.Signal] interface.
 */
export type Signal = number;

/**
 * SlirpInfo describes the slirp executable that is being used
 */
export type SlirpInfo = {
  executable?: string;
  package?: string;
  version?: string;
};

/**
 * SpecGenerator creates an OCI spec and Libpod configuration options to create
 * a container based on the given configuration.
 */
export type SpecGenerator = {
  /**
   * Map of networks names or ids that the container should join.
   * You can request additional settings for each network, you can
   * set network aliases, static ips, static mac address  and the
   * network interface name for this container on the specific network.
   * If the map is empty and the bridge network mode is set the container
   * will be joined to the default network.
   * Optional.
   */
  Networks?: {
    [key: string]: PerNetworkOptions;
  };
  /**
   * Annotations are key-value options passed into the container runtime
   * that can be used to trigger special behavior.
   * Optional.
   */
  annotations?: {
    [key: string]: string;
  };
  /**
   * ApparmorProfile is the name of the Apparmor profile the container
   * will use.
   * Optional.
   */
  apparmor_profile?: string;
  /**
   * ArtifactVolumes volumes based on an existing artifact.
   */
  artifact_volumes?: Array<ArtifactVolume>;
  /**
   * BaseHostsFile is the base file to create the `/etc/hosts` file inside the container.
   * This must either be an absolute path to a file on the host system, or one of the
   * special flags `image` or `none`.
   * If it is empty it defaults to the base_hosts_file configuration in containers.conf.
   * Optional.
   */
  base_hosts_file?: string;
  /**
   * CapAdd are capabilities which will be added to the container.
   * Conflicts with Privileged.
   * Optional.
   */
  cap_add?: Array<string>;
  /**
   * CapDrop are capabilities which will be removed from the container.
   * Conflicts with Privileged.
   * Optional.
   */
  cap_drop?: Array<string>;
  /**
   * CgroupParent is the container's Cgroup parent.
   * If not set, the default for the current cgroup driver will be used.
   * Optional.
   */
  cgroup_parent?: string;
  cgroupns?: Namespace;
  /**
   * CgroupsMode sets a policy for how cgroups will be created for the
   * container, including the ability to disable creation entirely.
   * Optional.
   */
  cgroups_mode?: string;
  /**
   * ChrootDirs is an additional set of directories that need to be
   * treated as root directories. Standard bind mounts will be mounted
   * into paths relative to these directories.
   * Optional.
   */
  chroot_directories?: Array<string>;
  /**
   * CNINetworks is a list of CNI networks to join the container to.
   * If this list is empty, the default CNI network will be joined
   * instead. If at least one entry is present, we will not join the
   * default network (unless it is part of this list).
   * Only available if NetNS is set to bridge.
   * Optional.
   * Deprecated: as of podman 4.0 use "Networks" instead.
   */
  cni_networks?: Array<string>;
  /**
   * Command is the container's command.
   * If not given and Image is specified, this will be populated by the
   * image's configuration.
   * Optional.
   */
  command?: Array<string>;
  /**
   * ConmonPidFile is a path at which a PID file for Conmon will be
   * placed.
   * If not given, a default location will be used.
   * Optional.
   */
  conmon_pid_file?: string;
  /**
   * ContainerCreateCommand is the command that was used to create this
   * container.
   * This will be shown in the output of Inspect() on the container, and
   * may also be used by some tools that wish to recreate the container
   * (e.g. `podman generate systemd --new`).
   * Optional.
   */
  containerCreateCommand?: Array<string>;
  /**
   * Create the working directory if it doesn't exist.
   * If unset, it doesn't create it.
   * Optional.
   */
  create_working_dir?: boolean;
  /**
   * DependencyContainers is an array of containers this container
   * depends on. Dependency containers must be started before this
   * container. Dependencies can be specified by name or full/partial ID.
   * Optional.
   */
  dependencyContainers?: Array<string>;
  /**
   * DeviceCgroupRule are device cgroup rules that allow containers
   * to use additional types of devices.
   */
  device_cgroup_rule?: Array<LinuxDeviceCgroup>;
  /**
   * Devices are devices that will be added to the container.
   * Optional.
   */
  devices?: Array<LinuxDevice>;
  /**
   * DevicesFrom specifies that this container will mount the device(s) from other container(s).
   * Optional.
   */
  devices_from?: Array<string>;
  /**
   * DNSOptions is a set of DNS options that will be used in the
   * container's resolv.conf, replacing the host's DNS options which are
   * used by default.
   * Conflicts with UseImageResolvConf.
   * Optional.
   */
  dns_option?: Array<string>;
  /**
   * DNSSearch is a set of DNS search domains that will be used in the
   * container's resolv.conf, replacing the host's DNS search domains
   * which are used by default.
   * Conflicts with UseImageResolvConf.
   * Optional.
   */
  dns_search?: Array<string>;
  /**
   * DNSServers is a set of DNS servers that will be used in the
   * container's resolv.conf, replacing the host's DNS Servers which are
   * used by default.
   * Conflicts with UseImageResolvConf.
   * Optional.
   */
  dns_server?: Array<string>;
  /**
   * Entrypoint is the container's entrypoint.
   * If not given and Image is specified, this will be populated by the
   * image's configuration.
   * Optional.
   */
  entrypoint?: Array<string>;
  /**
   * Env is a set of environment variables that will be set in the
   * container.
   * Optional.
   */
  env?: {
    [key: string]: string;
  };
  /**
   * EnvHost indicates that the host environment should be added to container
   * Optional.
   */
  env_host?: boolean;
  /**
   * EnvMerge takes the specified environment variables from image and preprocess them before injecting them into the
   * container.
   * Optional.
   */
  envmerge?: Array<string>;
  /**
   * Expose is a number of ports that will be forwarded to the container
   * if PublishExposedPorts is set.
   * Expose is a map of uint16 (port number) to a string representing
   * protocol i.e map[uint16]string. Allowed protocols are "tcp", "udp", and "sctp", or some
   * combination of the three separated by commas.
   * If protocol is set to "" we will assume TCP.
   * Only available if NetNS is set to Bridge or Slirp, and
   * PublishExposedPorts is set.
   * Optional.
   */
  expose?: unknown;
  /**
   * GroupEntry specifies an arbitrary string to append to the container's /etc/group file.
   * Optional.
   */
  group_entry?: string;
  /**
   * Groups are a list of supplemental groups the container's user will
   * be granted access to.
   * Optional.
   */
  groups?: Array<string>;
  health_check_on_failure_action?: HealthCheckOnFailureAction;
  /**
   * HealthLogDestination defines the destination where the log is stored.
   * TODO (6.0): In next major release convert it to pointer and use omitempty
   */
  healthLogDestination?: string;
  /**
   * HealthMaxLogCount is maximum number of attempts in the HealthCheck log file.
   * ('0' value means an infinite number of attempts in the log file).
   * TODO (6.0): In next major release convert it to pointer and use omitempty
   */
  healthMaxLogCount?: number;
  /**
   * HealthMaxLogSize is the maximum length in characters of stored HealthCheck log
   * ("0" value means an infinite log length).
   * TODO (6.0): In next major release convert it to pointer and use omitempty
   */
  healthMaxLogSize?: number;
  healthconfig?: Schema2HealthConfig;
  /**
   * HostDeviceList is used to recreate the mounted device on inherited containers
   */
  host_device_list?: Array<LinuxDevice>;
  /**
   * HostAdd is a set of hosts which will be added to the container's
   * etc/hosts file.
   * Conflicts with UseImageHosts.
   * Optional.
   */
  hostadd?: Array<string>;
  /**
   * Hostname is the container's hostname. If not set, the hostname will
   * not be modified (if UtsNS is not private) or will be set to the
   * container ID (if UtsNS is private).
   * Conflicts with UtsNS if UtsNS is not set to private.
   * Optional.
   */
  hostname?: string;
  /**
   * HostUsers is a list of host usernames or UIDs to add to the container
   * etc/passwd file
   */
  hostusers?: Array<string>;
  /**
   * EnvHTTPProxy indicates that the http host proxy environment variables
   * should be added to container
   * Optional.
   */
  httpproxy?: boolean;
  idmappings?: IdMappingOptions;
  /**
   * Image is the image the container will be based on. The image will be
   * used as the container's root filesystem, and its environment vars,
   * volumes, and other configuration will be applied to the container.
   * Conflicts with Rootfs.
   * At least one of Image or Rootfs must be specified.
   */
  image?: string;
  /**
   * ImageArch is the user-specified image architecture.
   * Used to select a different variant from a manifest list.
   * Optional.
   */
  image_arch?: string;
  /**
   * ImageOS is the user-specified OS of the image.
   * Used to select a different variant from a manifest list.
   * Optional.
   */
  image_os?: string;
  /**
   * ImageVariant is the user-specified image variant.
   * Used to select a different variant from a manifest list.
   * Optional.
   */
  image_variant?: string;
  /**
   * ImageVolumeMode indicates how image volumes will be created.
   * Supported modes are "ignore" (do not create), "tmpfs" (create as
   * tmpfs), and "anonymous" (create as anonymous volumes).
   * The default if unset is anonymous.
   * Optional.
   */
  image_volume_mode?: string;
  /**
   * Image volumes bind-mount a container-image mount into the container.
   * Optional.
   */
  image_volumes?: Array<ImageVolume>;
  /**
   * Init specifies that an init binary will be mounted into the
   * container, and will be used as PID1.
   * Optional.
   */
  init?: boolean;
  /**
   * InitContainerType describes if this container is an init container
   * and if so, what type: always or once.
   * Optional.
   */
  init_container_type?: string;
  /**
   * InitPath specifies the path to the init binary that will be added if
   * Init is specified above. If not specified, the default set in the
   * Libpod config will be used. Ignored if Init above is not set.
   * Optional.
   */
  init_path?: string;
  intelRdt?: LinuxIntelRdt;
  ipcns?: Namespace;
  /**
   * LabelNested indicates whether or not the container is allowed to
   * run fully nested containers including SELinux labelling.
   * Optional.
   */
  label_nested?: boolean;
  /**
   * Labels are key-value pairs that are used to add metadata to
   * containers.
   * Optional.
   */
  labels?: {
    [key: string]: string;
  };
  log_configuration?: LogConfigLibpod;
  /**
   * Passwd is a container run option that determines if we are validating users/groups before running the container
   */
  manage_password?: boolean;
  /**
   * Mask is the path we want to mask in the container. This masks the paths
   * given in addition to the default list.
   * Optional
   */
  mask?: Array<string>;
  /**
   * Mounts are mounts that will be added to the container.
   * These will supersede Image Volumes and VolumesFrom volumes where
   * there are conflicts.
   * Optional.
   */
  mounts?: Array<Mount>;
  /**
   * Name is the name the container will be given.
   * If no name is provided, one will be randomly generated.
   * Optional.
   */
  name?: string;
  netns?: Namespace;
  /**
   * NetworkOptions are additional options for each network
   * Optional.
   */
  network_options?: {
    [key: string]: Array<string>;
  };
  /**
   * NoNewPrivileges is whether the container will set the no new
   * privileges flag on create, which disables gaining additional
   * privileges (e.g. via setuid) in the container.
   * Optional.
   */
  no_new_privileges?: boolean;
  /**
   * OCIRuntime is the name of the OCI runtime that will be used to create
   * the container.
   * If not specified, the default will be used.
   * Optional.
   */
  oci_runtime?: string;
  /**
   * OOMScoreAdj adjusts the score used by the OOM killer to determine
   * processes to kill for the container's process.
   * Optional.
   */
  oom_score_adj?: number;
  /**
   * Overlay volumes are named volumes that will be added to the container.
   * Optional.
   */
  overlay_volumes?: Array<OverlayVolume>;
  /**
   * PasswdEntry specifies an arbitrary string to append to the container's /etc/passwd file.
   * Optional.
   */
  passwd_entry?: string;
  personality?: LinuxPersonality;
  pidns?: Namespace;
  /**
   * Pod is the ID of the pod the container will join.
   * Optional.
   */
  pod?: string;
  /**
   * PortBindings is a set of ports to map into the container.
   * Only available if NetNS is set to bridge, slirp, or pasta.
   * Optional.
   */
  portmappings?: Array<PortMapping>;
  /**
   * Privileged is whether the container is privileged.
   * Privileged does the following:
   * Adds all devices on the system to the container.
   * Adds all capabilities to the container.
   * Disables Seccomp, SELinux, and Apparmor confinement.
   * (Though SELinux can be manually re-enabled).
   * TODO: this conflicts with things.
   * TODO: this does more.
   * Optional.
   */
  privileged?: boolean;
  /**
   * ProcOpts are the options used for the proc mount.
   */
  procfs_opts?: Array<string>;
  /**
   * PublishExposedPorts will publish ports specified in the image to
   * random unused ports (guaranteed to be above 1024) on the host.
   * This is based on ports set in Expose below, and any ports specified
   * by the Image (if one is given).
   * Only available if NetNS is set to Bridge or Slirp.
   * Optional.
   */
  publish_image_ports?: boolean;
  /**
   * Rlimits are POSIX rlimits to apply to the container.
   * Optional.
   */
  r_limits?: Array<PosixRlimit>;
  /**
   * RawImageName is the user-specified and unprocessed input referring
   * to a local or a remote image.
   * Optional, but strongly encouraged to be set if Image is set.
   */
  raw_image_name?: string;
  /**
   * ReadOnlyFilesystem indicates that everything will be mounted
   * as read-only.
   * Optional.
   */
  read_only_filesystem?: boolean;
  /**
   * ReadWriteTmpfs indicates that when running with a ReadOnlyFilesystem
   * mount temporary file systems.
   * Optional.
   */
  read_write_tmpfs?: boolean;
  /**
   * Remove indicates if the container should be removed once it has been started
   * and exits.
   * Optional.
   */
  remove?: boolean;
  /**
   * RemoveImage indicates that the container should remove the image it
   * was created from after it exits.
   * Only allowed if Remove is set to true and Image, not Rootfs, is in
   * use.
   * Optional.
   */
  removeImage?: boolean;
  resource_limits?: LinuxResources;
  /**
   * RestartPolicy is the container's restart policy - an action which
   * will be taken when the container exits.
   * If not given, the default policy, which does nothing, will be used.
   * Optional.
   */
  restart_policy?: string;
  /**
   * RestartRetries is the number of attempts that will be made to restart
   * the container.
   * Only available when RestartPolicy is set to "on-failure".
   * Optional.
   */
  restart_tries?: number;
  /**
   * Rootfs is the path to a directory that will be used as the
   * container's root filesystem. No modification will be made to the
   * directory, it will be directly mounted into the container as root.
   * Conflicts with Image.
   * At least one of Image or Rootfs must be specified.
   */
  rootfs?: string;
  /**
   * RootfsMapping specifies if there are UID/GID mappings to apply to the rootfs.
   * Optional.
   */
  rootfs_mapping?: string;
  /**
   * RootfsOverlay tells if rootfs is actually an overlay on top of base path.
   * Optional.
   */
  rootfs_overlay?: boolean;
  /**
   * RootfsPropagation is the rootfs propagation mode for the container.
   * If not set, the default of rslave will be used.
   * Optional.
   */
  rootfs_propagation?: string;
  /**
   * Determine how to handle the NOTIFY_SOCKET - do we participate or pass it through
   * "container" - let the OCI runtime deal with it, advertise conmon's MAINPID
   * "conmon-only" - advertise conmon's MAINPID, send READY when started, don't pass to OCI
   * "ignore" - unset NOTIFY_SOCKET
   * Optional.
   */
  sdnotifyMode?: string;
  /**
   * SeccompPolicy determines which seccomp profile gets applied
   * the container. valid values: empty,default,image
   */
  seccomp_policy?: string;
  /**
   * SeccompProfilePath is the path to a JSON file containing the
   * container's Seccomp profile.
   * If not specified, no Seccomp profile will be used.
   * Optional.
   */
  seccomp_profile_path?: string;
  /**
   * EnvSecrets are secrets that will be set as environment variables
   * Optional.
   */
  secret_env?: {
    [key: string]: string;
  };
  /**
   * Secrets are the secrets that will be added to the container
   * Optional.
   */
  secrets?: Array<Secret>;
  /**
   * SelinuxProcessLabel is the process label the container will use.
   * If SELinux is enabled and this is not specified, a label will be
   * automatically generated if not specified.
   * Optional.
   */
  selinux_opts?: Array<string>;
  /**
   * ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes.
   * Conflicts with ShmSize if IpcNS is not private.
   * Optional.
   */
  shm_size?: number;
  /**
   * ShmSizeSystemd is the size of systemd-specific tmpfs mounts
   * specifically /run, /run/lock, /var/log/journal and /tmp.
   * Optional
   */
  shm_size_systemd?: number;
  startupHealthConfig?: StartupHealthCheck;
  /**
   * Stdin is whether the container will keep its STDIN open.
   * Optional.
   */
  stdin?: boolean;
  stop_signal?: Signal;
  /**
   * StopTimeout is a timeout between the container's stop signal being
   * sent and SIGKILL being sent.
   * If not provided, the default will be used.
   * If 0 is used, stop signal will not be sent, and SIGKILL will be sent
   * instead.
   * Optional.
   */
  stop_timeout?: number;
  /**
   * StorageOpts is the container's storage options
   * Optional.
   */
  storage_opts?: {
    [key: string]: string;
  };
  /**
   * Sysctl sets kernel parameters for the container
   */
  sysctl?: {
    [key: string]: string;
  };
  /**
   * Systemd is whether the container will be started in systemd mode.
   * Valid options are "true", "false", and "always".
   * "true" enables this mode only if the binary run in the container is
   * sbin/init or systemd. "always" unconditionally enables systemd mode.
   * "false" unconditionally disables systemd mode.
   * If enabled, mounts and stop signal will be modified.
   * If set to "always" or set to "true" and conditionally triggered,
   * conflicts with StopSignal.
   * If not specified, "false" will be assumed.
   * Optional.
   */
  systemd?: string;
  /**
   * Terminal is whether the container will create a PTY.
   * Optional.
   */
  terminal?: boolean;
  /**
   * IO read rate limit per cgroup per device, bytes per second
   */
  throttleReadBpsDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * IO read rate limit per cgroup per device, IO per second
   */
  throttleReadIOPSDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * IO write rate limit per cgroup per device, bytes per second
   */
  throttleWriteBpsDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * IO write rate limit per cgroup per device, IO per second
   */
  throttleWriteIOPSDevice?: {
    [key: string]: LinuxThrottleDevice;
  };
  /**
   * Timeout is a maximum time in seconds the container will run before
   * main process is sent SIGKILL.
   * If 0 is used, signal will not be sent. Container can run indefinitely
   * if they do not stop after the default termination signal.
   * Optional.
   */
  timeout?: number;
  /**
   * Timezone is the timezone inside the container.
   * Local means it has the same timezone as the host machine
   * Optional.
   */
  timezone?: string;
  /**
   * Umask is the umask the init process of the container will be run with.
   */
  umask?: string;
  /**
   * CgroupConf are key-value options passed into the container runtime
   * that are used to configure cgroup v2.
   * Optional.
   */
  unified?: {
    [key: string]: string;
  };
  /**
   * Unmask a path in the container. Some paths are masked by default,
   * preventing them from being accessed within the container; this undoes
   * that masking. If ALL is passed, all paths will be unmasked.
   * Optional.
   */
  unmask?: Array<string>;
  /**
   * UnsetEnv unsets the specified default environment variables from the image or from built-in or containers.conf
   * Optional.
   */
  unsetenv?: Array<string>;
  /**
   * UnsetEnvAll unsetall default environment variables from the image or from built-in or containers.conf
   * UnsetEnvAll unsets all default environment variables from the image or from built-in
   * Optional.
   */
  unsetenvall?: boolean;
  /**
   * UseImageHostname indicates that /etc/hostname should not be managed by
   * Podman, and instead sourced from the image.
   * Optional.
   */
  use_image_hostname?: boolean;
  /**
   * UseImageHosts indicates that /etc/hosts should not be managed by
   * Podman, and instead sourced from the image.
   * Conflicts with HostAdd.
   * Optional.
   */
  use_image_hosts?: boolean;
  /**
   * UseImageResolvConf indicates that resolv.conf should not be managed
   * by Podman, but instead sourced from the image.
   * Conflicts with DNSServer, DNSSearch, DNSOption.
   * Optional.
   */
  use_image_resolve_conf?: boolean;
  /**
   * User is the user the container will be run as.
   * Can be given as a UID or a username; if a username, it will be
   * resolved within the container, using the container's /etc/passwd.
   * If unset, the container will be run as root.
   * Optional.
   */
  user?: string;
  userns?: Namespace;
  utsns?: Namespace;
  /**
   * Volatile specifies whether the container storage can be optimized
   * at the cost of not syncing all the dirty files in memory.
   * Optional.
   */
  volatile?: boolean;
  /**
   * Volumes are named volumes that will be added to the container.
   * These will supersede Image Volumes and VolumesFrom volumes where
   * there are conflicts.
   * Optional.
   */
  volumes?: Array<NamedVolume>;
  /**
   * VolumesFrom is a set of containers whose volumes will be added to
   * this container. The name or ID of the container must be provided, and
   * may optionally be followed by a : and then one or more
   * comma-separated options. Valid options are 'ro', 'rw', and 'z'.
   * Options will be used for all volumes sourced from the container.
   * Optional.
   */
  volumes_from?: Array<string>;
  /**
   * Weight per cgroup per device, can override BlkioWeight
   */
  weightDevice?: {
    [key: string]: LinuxWeightDevice;
  };
  /**
   * WorkDir is the container's working directory.
   * If unset, the default, /, will be used.
   * Optional.
   */
  work_dir?: string;
};

/**
 * StartupHealthCheck is the configuration of a startup healthcheck.
 */
export type StartupHealthCheck = {
  Interval?: Duration;
  /**
   * Retries is the number of consecutive failures needed to consider a container as unhealthy.
   * Zero means inherit.
   */
  Retries?: number;
  StartInterval?: Duration;
  StartPeriod?: Duration;
  /**
   * Successes are the number of successes required to mark the startup HC
   * as passed.
   * If set to 0, a single success will mark the HC as passed.
   */
  Successes?: number;
  /**
   * Test is the test to perform to check that the container is healthy.
   * An empty slice means to inherit the default.
   * The options are:
   * {} : inherit healthcheck
   * {"NONE"} : disable healthcheck
   * {"CMD", args...} : exec arguments directly
   * {"CMD-SHELL", command} : run command with system's default shell
   */
  Test?: Array<string>;
  Timeout?: Duration;
};

/**
 * State stores container's running state
 * it's part of ContainerJSONBase and returned by "inspect" command
 */
export type State = {
  Dead?: boolean;
  Error?: string;
  ExitCode?: number;
  FinishedAt?: string;
  Health?: Health;
  OOMKilled?: boolean;
  Paused?: boolean;
  Pid?: number;
  Restarting?: boolean;
  Running?: boolean;
  StartedAt?: string;
  Status?: string;
};

/**
 * StoreInfo describes the container storage and its
 * attributes
 */
export type StoreInfo = {
  configFile?: string;
  containerStore?: ContainerStore;
  graphDriverName?: string;
  graphOptions?: {
    [key: string]: unknown;
  };
  graphRoot?: string;
  /**
   * GraphRootAllocated is how much space the graphroot has in bytes
   */
  graphRootAllocated?: number;
  /**
   * GraphRootUsed is how much of graphroot is used in bytes
   */
  graphRootUsed?: number;
  graphStatus?: {
    [key: string]: string;
  };
  imageCopyTmpDir?: string;
  imageStore?: ImageStore;
  runRoot?: string;
  transientStore?: boolean;
  volumePath?: string;
};

/**
 * StrSlice represents a string or an array of strings.
 * We need to override the json decoder to accept both options.
 */
export type StrSlice = Array<string>;

export type Subnet = {
  /**
   * Gateway IP for this Network.
   */
  gateway?: string;
  lease_range?: LeaseRange;
  /**
   * Subnet for this Network in CIDR form.
   */
  subnet?: string;
};

export type Summary = {
  /**
   * Number of containers using this image. Includes both stopped and running
   * containers.
   *
   * This size is not calculated by default, and depends on which API endpoint
   * is used. `-1` indicates that the value has not been set / calculated.
   */
  Containers: number;
  /**
   * Date and time at which the image was created as a Unix timestamp
   * (number of seconds since EPOCH).
   */
  Created: number;
  Descriptor?: Descriptor;
  /**
   * ID is the content-addressable ID of an image.
   *
   * This identifier is a content-addressable digest calculated from the
   * image's configuration (which includes the digests of layers used by
   * the image).
   *
   * Note that this digest differs from the `RepoDigests` below, which
   * holds digests of image manifests that reference the image.
   */
  Id: string;
  /**
   * User-defined key/value metadata.
   */
  Labels: {
    [key: string]: string;
  };
  /**
   * Manifests is a list of image manifests available in this image.  It
   * provides a more detailed view of the platform-specific image manifests or
   * other image-attached data like build attestations.
   *
   * WARNING: This is experimental and may change at any time without any backward
   * compatibility.
   */
  Manifests?: Array<ManifestSummary>;
  /**
   * ID of the parent image.
   *
   * Depending on how the image was created, this field may be empty and
   * is only set for images that were built/created locally. This field
   * is empty if the image was pulled from an image registry.
   */
  ParentId: string;
  /**
   * List of content-addressable digests of locally available image manifests
   * that the image is referenced from. Multiple manifests can refer to the
   * same image.
   *
   * These digests are usually only available if the image was either pulled
   * from a registry, or if the image was pushed to a registry, which is when
   * the manifest is generated and its digest calculated.
   */
  RepoDigests: Array<string>;
  /**
   * List of image names/tags in the local image cache that reference this
   * image.
   *
   * Multiple image tags can refer to the same image, and this list may be
   * empty if no tags reference the image, in which case the image is
   * "untagged", in which case it can still be referenced by its ID.
   */
  RepoTags: Array<string>;
  /**
   * Total size of image layers that are shared between this image and other
   * images.
   *
   * This size is not calculated by default. `-1` indicates that the value
   * has not been set / calculated.
   */
  SharedSize: number;
  /**
   * Total size of the image including all layers it is composed of.
   */
  Size: number;
  /**
   * Total size of the image including all layers it is composed of.
   *
   * Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
   */
  VirtualSize?: number;
};

/**
 * SystemCheckReport provides a report of what a storage consistency check
 * found, and if we removed anything that was damaged, what we removed.
 */
export type SystemCheckReport = {
  Containers?: {
    [key: string]: Array<string>;
  };
  Errors?: boolean;
  Images?: {
    [key: string]: Array<string>;
  };
  Layers?: {
    [key: string]: Array<string>;
  };
  ROImages?: {
    [key: string]: Array<string>;
  };
  ROLayers?: {
    [key: string]: Array<string>;
  };
  RemovedContainers?: {
    [key: string]: string;
  };
  RemovedImages?: {
    [key: string]: Array<string>;
  };
  RemovedLayers?: Array<string>;
};

/**
 * SystemComponentVersion is the type used by pkg/domain/entities
 */
export type SystemComponentVersion = {
  ApiVersion?: string;
  Arch?: string;
  BuildTime?: string;
  Components?: Array<ComponentVersion>;
  Experimental?: boolean;
  GitCommit?: string;
  GoVersion?: string;
  KernelVersion?: string;
  MinAPIVersion?: string;
  Os?: string;
  Platform?: {
    Name?: string;
  };
  Version?: string;
};

/**
 * SystemDfContainerReport describes a container for use with df
 */
export type SystemDfContainerReport = {
  Command?: Array<string>;
  ContainerID?: string;
  Created?: string;
  Image?: string;
  LocalVolumes?: number;
  Names?: string;
  RWSize?: number;
  Size?: number;
  Status?: string;
};

/**
 * SystemDfImageReport describes an image for use with df
 */
export type SystemDfImageReport = {
  Containers?: number;
  Created?: string;
  ImageID?: string;
  Repository?: string;
  SharedSize?: number;
  Size?: number;
  Tag?: string;
  UniqueSize?: number;
};

/**
 * SystemDfReport describes the response for df information
 */
export type SystemDfReport = {
  Containers?: Array<SystemDfContainerReport>;
  Images?: Array<SystemDfImageReport>;
  ImagesSize?: number;
  Volumes?: Array<SystemDfVolumeReport>;
};

/**
 * SystemDfVolumeReport describes a volume and its size
 */
export type SystemDfVolumeReport = {
  Links?: number;
  ReclaimableSize?: number;
  Size?: number;
  VolumeName?: string;
};

/**
 * SystemPruneReport provides report after system prune is executed.
 */
export type SystemPruneReport = {
  ContainerPruneReports?: Array<PruneReport>;
  ImagePruneReports?: Array<PruneReport>;
  NetworkPruneReports?: Array<NetworkPruneReport>;
  PodPruneReport?: Array<PodPruneReport>;
  ReclaimedSpace?: number;
  VolumePruneReports?: Array<PruneReport>;
};

/**
 * Task carries the information about one backend task
 */
export type Task = {
  EndpointID?: string;
  EndpointIP?: string;
  Info?: {
    [key: string]: string;
  };
  Name?: string;
};

/**
 * ThrottleDevice is a structure that holds device:rate_per_second pair
 */
export type ThrottleDevice = {
  Path?: string;
  Rate?: number;
};

/**
 * TmpfsOptions defines options specific to mounts of type "tmpfs".
 */
export type TmpfsOptions = {
  Mode?: FileMode;
  /**
   * Options to be passed to the tmpfs mount. An array of arrays. Flag
   * options should be provided as 1-length arrays. Other types should be
   * provided as 2-length arrays, where the first item is the key and the
   * second the value.
   */
  Options?: Array<Array<string>>;
  /**
   * Size sets the size of the tmpfs, in bytes.
   *
   * This will be converted to an operating system specific value
   * depending on the host. For example, on linux, it will be converted to
   * use a 'k', 'm' or 'g' syntax. BSD, though not widely supported with
   * docker, uses a straight byte value.
   *
   * Percentages are not supported.
   */
  SizeBytes?: number;
};

/**
 * TopResponse ContainerTopResponse
 * Container "top" response.
 */
export type TopResponse = {
  /**
   * Each process running in the container, where each process
   * is an array of values corresponding to the titles.
   */
  Processes?: Array<Array<string>>;
  /**
   * The ps column titles
   */
  Titles?: Array<string>;
};

/**
 * Topology is a map of topological domains to topological segments.
 * This description is taken verbatim from the CSI Spec:
 *
 * A topological domain is a sub-division of a cluster, like "region",
 * "zone", "rack", etc.
 * A topological segment is a specific instance of a topological domain,
 * like "zone3", "rack3", etc.
 * For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
 * Valid keys have two segments: an OPTIONAL prefix and name, separated
 * by a slash (/), for example: "com.company.example/zone".
 * The key name segment is REQUIRED. The prefix is OPTIONAL.
 * The key name MUST be 63 characters or less, begin and end with an
 * alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
 * underscores (_), dots (.), or alphanumerics in between, for example
 * "zone".
 * The key prefix MUST be 63 characters or less, begin and end with a
 * lower-case alphanumeric character ([a-z0-9]), contain only
 * dashes (-), dots (.), or lower-case alphanumerics in between, and
 * follow domain name notation format
 * (https://tools.ietf.org/html/rfc1035#section-2.3.1).
 * The key prefix SHOULD include the plugin's host company name and/or
 * the plugin name, to minimize the possibility of collisions with keys
 * from other plugins.
 * If a key prefix is specified, it MUST be identical across all
 * topology keys returned by the SP (across all RPCs).
 * Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
 * MUST not both exist.
 * Each value (topological segment) MUST contain 1 or more strings.
 * Each string MUST be 63 characters or less and begin and end with an
 * alphanumeric character with '-', '_', '.', or alphanumerics in
 * between.
 */
export type Topology = {
  Segments?: {
    [key: string]: string;
  };
};

/**
 * TopologyRequirement expresses the user's requirements for a volume's
 * accessible topology.
 */
export type TopologyRequirement = {
  /**
   * Preferred is a list of Topologies that the volume should attempt to be
   * provisioned in.
   *
   * Taken from the CSI spec:
   *
   * Specifies the list of topologies the CO would prefer the volume to
   * be provisioned in.
   *
   * This field is OPTIONAL. If TopologyRequirement is specified either
   * requisite or preferred or both MUST be specified.
   *
   * An SP MUST attempt to make the provisioned volume available using
   * the preferred topologies in order from first to last.
   *
   * If requisite is specified, all topologies in preferred list MUST
   * also be present in the list of requisite topologies.
   *
   * If the SP is unable to make the provisioned volume available
   * from any of the preferred topologies, the SP MAY choose a topology
   * from the list of requisite topologies.
   * If the list of requisite topologies is not specified, then the SP
   * MAY choose from the list of all possible topologies.
   * If the list of requisite topologies is specified and the SP is
   * unable to make the provisioned volume available from any of the
   * requisite topologies it MUST fail the CreateVolume call.
   *
   * Example 1:
   * Given a volume should be accessible from a single zone, and
   * requisite =
   * {"region": "R1", "zone": "Z2"},
   * {"region": "R1", "zone": "Z3"}
   * preferred =
   * {"region": "R1", "zone": "Z3"}
   * then the SP SHOULD first attempt to make the provisioned volume
   * available from "zone" "Z3" in the "region" "R1" and fall back to
   * "zone" "Z2" in the "region" "R1" if that is not possible.
   *
   * Example 2:
   * Given a volume should be accessible from a single zone, and
   * requisite =
   * {"region": "R1", "zone": "Z2"},
   * {"region": "R1", "zone": "Z3"},
   * {"region": "R1", "zone": "Z4"},
   * {"region": "R1", "zone": "Z5"}
   * preferred =
   * {"region": "R1", "zone": "Z4"},
   * {"region": "R1", "zone": "Z2"}
   * then the SP SHOULD first attempt to make the provisioned volume
   * accessible from "zone" "Z4" in the "region" "R1" and fall back to
   * "zone" "Z2" in the "region" "R1" if that is not possible. If that
   * is not possible, the SP may choose between either the "zone"
   * "Z3" or "Z5" in the "region" "R1".
   *
   * Example 3:
   * Given a volume should be accessible from TWO zones (because an
   * opaque parameter in CreateVolumeRequest, for example, specifies
   * the volume is accessible from two zones, aka synchronously
   * replicated), and
   * requisite =
   * {"region": "R1", "zone": "Z2"},
   * {"region": "R1", "zone": "Z3"},
   * {"region": "R1", "zone": "Z4"},
   * {"region": "R1", "zone": "Z5"}
   * preferred =
   * {"region": "R1", "zone": "Z5"},
   * {"region": "R1", "zone": "Z3"}
   * then the SP SHOULD first attempt to make the provisioned volume
   * accessible from the combination of the two "zones" "Z5" and "Z3" in
   * the "region" "R1". If that's not possible, it should fall back to
   * a combination of "Z5" and other possibilities from the list of
   * requisite. If that's not possible, it should fall back  to a
   * combination of "Z3" and other possibilities from the list of
   * requisite. If that's not possible, it should fall back  to a
   * combination of other possibilities from the list of requisite.
   */
  Preferred?: Array<Topology>;
  /**
   * Requisite specifies a list of Topologies, at least one of which the
   * volume must be accessible from.
   *
   * Taken verbatim from the CSI Spec:
   *
   * Specifies the list of topologies the provisioned volume MUST be
   * accessible from.
   * This field is OPTIONAL. If TopologyRequirement is specified either
   * requisite or preferred or both MUST be specified.
   *
   * If requisite is specified, the provisioned volume MUST be
   * accessible from at least one of the requisite topologies.
   *
   * Given
   * x = number of topologies provisioned volume is accessible from
   * n = number of requisite topologies
   * The CO MUST ensure n >= 1. The SP MUST ensure x >= 1
   * If x==n, then the SP MUST make the provisioned volume available to
   * all topologies from the list of requisite topologies. If it is
   * unable to do so, the SP MUST fail the CreateVolume call.
   * For example, if a volume should be accessible from a single zone,
   * and requisite =
   * {"region": "R1", "zone": "Z2"}
   * then the provisioned volume MUST be accessible from the "region"
   * "R1" and the "zone" "Z2".
   * Similarly, if a volume should be accessible from two zones, and
   * requisite =
   * {"region": "R1", "zone": "Z2"},
   * {"region": "R1", "zone": "Z3"}
   * then the provisioned volume MUST be accessible from the "region"
   * "R1" and both "zone" "Z2" and "zone" "Z3".
   *
   * If x<n, then the SP SHALL choose x unique topologies from the list
   * of requisite topologies. If it is unable to do so, the SP MUST fail
   * the CreateVolume call.
   * For example, if a volume should be accessible from a single zone,
   * and requisite =
   * {"region": "R1", "zone": "Z2"},
   * {"region": "R1", "zone": "Z3"}
   * then the SP may choose to make the provisioned volume available in
   * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
   * Similarly, if a volume should be accessible from two zones, and
   * requisite =
   * {"region": "R1", "zone": "Z2"},
   * {"region": "R1", "zone": "Z3"},
   * {"region": "R1", "zone": "Z4"}
   * then the provisioned volume MUST be accessible from any combination
   * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
   * "R1/Z4", or "R1/Z3" and "R1/Z4".
   *
   * If x>n, then the SP MUST make the provisioned volume available from
   * all topologies from the list of requisite topologies and MAY choose
   * the remaining x-n unique topologies from the list of all possible
   * topologies. If it is unable to do so, the SP MUST fail the
   * CreateVolume call.
   * For example, if a volume should be accessible from two zones, and
   * requisite =
   * {"region": "R1", "zone": "Z2"}
   * then the provisioned volume MUST be accessible from the "region"
   * "R1" and the "zone" "Z2" and the SP may select the second zone
   * independently, e.g. "R1/Z4".
   */
  Requisite?: Array<Topology>;
};

/**
 * Type represents the type of a mount.
 */
export type Type = string;

/**
 * TypeBlock defines options for using a volume as a block-type volume.
 * Intentionally empty.
 */
export type TypeBlock = {
  [key: string]: unknown;
};

/**
 * TypeMount contains options for using a volume as a Mount-type
 * volume.
 */
export type TypeMount = {
  /**
   * FsType specifies the filesystem type for the mount volume. Optional.
   */
  FsType?: string;
  /**
   * MountFlags defines flags to pass when mounting the volume. Optional.
   */
  MountFlags?: Array<string>;
};

/**
 * UTSMode represents the UTS namespace of the container.
 */
export type UtsMode = string;

/**
 * Ulimit is a human friendly version of Rlimit.
 */
export type Ulimit = {
  Hard?: number;
  Name?: string;
  Soft?: number;
};

/**
 * UpdateConfig holds the mutable attributes of a Container.
 * Those attributes can be updated at runtime.
 */
export type UpdateConfig = {
  BlkioDeviceReadBps?: Array<ThrottleDevice>;
  BlkioDeviceReadIOps?: Array<ThrottleDevice>;
  BlkioDeviceWriteBps?: Array<ThrottleDevice>;
  BlkioDeviceWriteIOps?: Array<ThrottleDevice>;
  BlkioWeight?: number;
  BlkioWeightDevice?: Array<WeightDevice>;
  /**
   * Applicable to UNIX platforms
   */
  CgroupParent?: string;
  /**
   * Applicable to Windows
   */
  CpuCount?: number;
  CpuPercent?: number;
  CpuPeriod?: number;
  CpuQuota?: number;
  CpuRealtimePeriod?: number;
  CpuRealtimeRuntime?: number;
  /**
   * Applicable to all platforms
   */
  CpuShares?: number;
  CpusetCpus?: string;
  CpusetMems?: string;
  DeviceCgroupRules?: Array<string>;
  DeviceRequests?: Array<DeviceRequest>;
  Devices?: Array<DeviceMapping>;
  IOMaximumBandwidth?: number;
  IOMaximumIOps?: number;
  /**
   * KernelMemory specifies the kernel memory limit (in bytes) for the container.
   * Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
   */
  KernelMemory?: number;
  KernelMemoryTCP?: number;
  Memory?: number;
  MemoryReservation?: number;
  MemorySwap?: number;
  MemorySwappiness?: number;
  NanoCpus?: number;
  OomKillDisable?: boolean;
  PidsLimit?: number;
  RestartPolicy?: RestartPolicy;
  Ulimits?: Array<Ulimit>;
};

export type UpdateContainerDevicesLimits = {
  /**
   * Block IO weight (relative device weight) in the form:
   * ```[{"Path": "device_path", "Weight": weight}]```
   */
  BlkIOWeightDevice?: Array<WeightDevice>;
  /**
   * Limit read rate (bytes per second) from a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceReadBPs?: Array<ThrottleDevice>;
  /**
   * Limit read rate (IO per second) from a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceReadIOPs?: Array<ThrottleDevice>;
  /**
   * Limit write rate (bytes per second) to a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceWriteBPs?: Array<ThrottleDevice>;
  /**
   * Limit write rate (IO per second) to a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceWriteIOPs?: Array<ThrottleDevice>;
};

/**
 * UpdateEntities used to wrap the oci resource spec in a swagger model
 */
export type UpdateEntities = {
  /**
   * Block IO weight (relative device weight) in the form:
   * ```[{"Path": "device_path", "Weight": weight}]```
   */
  BlkIOWeightDevice?: Array<WeightDevice>;
  /**
   * Limit read rate (bytes per second) from a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceReadBPs?: Array<ThrottleDevice>;
  /**
   * Limit read rate (IO per second) from a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceReadIOPs?: Array<ThrottleDevice>;
  /**
   * Limit write rate (bytes per second) to a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceWriteBPs?: Array<ThrottleDevice>;
  /**
   * Limit write rate (IO per second) to a device, in the form:
   * ```[{"Path": "device_path", "Rate": rate}]```
   */
  DeviceWriteIOPs?: Array<ThrottleDevice>;
  Env?: Array<string>;
  UnsetEnv?: Array<string>;
  blockIO?: LinuxBlockIo;
  cpu?: LinuxCpu;
  /**
   * Devices configures the device allowlist.
   */
  devices?: Array<LinuxDeviceCgroup>;
  /**
   * HealthCmd set a healthcheck command for the container. ('none' disables the existing healthcheck)
   */
  health_cmd?: string;
  /**
   * HealthInterval set an interval for the healthcheck.
   * (a value of disable results in no automatic timer setup) Changing this setting resets timer.
   */
  health_interval?: string;
  /**
   * HealthLogDestination set the destination of the HealthCheck log.
   * Directory path, local or events_logger (local use container state file)
   * Warning: Changing this setting may cause the loss of previous logs!
   */
  health_log_destination?: string;
  /**
   * HealthMaxLogCount set maximum number of attempts in the HealthCheck log file.
   * ('0' value means an infinite number of attempts in the log file)
   */
  health_max_log_count?: number;
  /**
   * HealthMaxLogSize set maximum length in characters of stored HealthCheck log.
   * ('0' value means an infinite log length)
   */
  health_max_log_size?: number;
  /**
   * HealthOnFailure set the action to take once the container turns unhealthy.
   */
  health_on_failure?: string;
  /**
   * HealthRetries set the number of retries allowed before a healthcheck is considered to be unhealthy.
   */
  health_retries?: number;
  /**
   * HealthStartPeriod set the initialization time needed for a container to bootstrap.
   */
  health_start_period?: string;
  /**
   * HealthStartupCmd set a startup healthcheck command for the container.
   */
  health_startup_cmd?: string;
  /**
   * HealthStartupInterval set an interval for the startup healthcheck.
   * Changing this setting resets the timer, depending on the state of the container.
   */
  health_startup_interval?: string;
  /**
   * HealthStartupRetries set the maximum number of retries before the startup healthcheck will restart the container.
   */
  health_startup_retries?: number;
  /**
   * HealthStartupSuccess set the number of consecutive successes before the startup healthcheck is marked as successful
   * and the normal healthcheck begins (0 indicates any success will start the regular healthcheck)
   */
  health_startup_success?: number;
  /**
   * HealthStartupTimeout set the maximum amount of time that the startup healthcheck may take before it is considered failed.
   */
  health_startup_timeout?: string;
  /**
   * HealthTimeout set the maximum time allowed to complete the healthcheck before an interval is considered failed.
   */
  health_timeout?: string;
  /**
   * Hugetlb limits (in bytes). Default to reservation limits if supported.
   */
  hugepageLimits?: Array<LinuxHugepageLimit>;
  memory?: LinuxMemory;
  network?: LinuxNetwork;
  /**
   * Disable healthchecks on container.
   */
  no_healthcheck?: boolean;
  pids?: LinuxPids;
  /**
   * Rdma resource restriction configuration.
   * Limits are a set of key value pairs that define RDMA resource limits,
   * where the key is device name and value is resource limits.
   */
  rdma?: {
    [key: string]: LinuxRdma;
  };
  /**
   * Unified resources.
   */
  unified?: {
    [key: string]: string;
  };
};

export type UpdateHealthCheckConfig = {
  /**
   * HealthCmd set a healthcheck command for the container. ('none' disables the existing healthcheck)
   */
  health_cmd?: string;
  /**
   * HealthInterval set an interval for the healthcheck.
   * (a value of disable results in no automatic timer setup) Changing this setting resets timer.
   */
  health_interval?: string;
  /**
   * HealthLogDestination set the destination of the HealthCheck log.
   * Directory path, local or events_logger (local use container state file)
   * Warning: Changing this setting may cause the loss of previous logs!
   */
  health_log_destination?: string;
  /**
   * HealthMaxLogCount set maximum number of attempts in the HealthCheck log file.
   * ('0' value means an infinite number of attempts in the log file)
   */
  health_max_log_count?: number;
  /**
   * HealthMaxLogSize set maximum length in characters of stored HealthCheck log.
   * ('0' value means an infinite log length)
   */
  health_max_log_size?: number;
  /**
   * HealthOnFailure set the action to take once the container turns unhealthy.
   */
  health_on_failure?: string;
  /**
   * HealthRetries set the number of retries allowed before a healthcheck is considered to be unhealthy.
   */
  health_retries?: number;
  /**
   * HealthStartPeriod set the initialization time needed for a container to bootstrap.
   */
  health_start_period?: string;
  /**
   * HealthStartupCmd set a startup healthcheck command for the container.
   */
  health_startup_cmd?: string;
  /**
   * HealthStartupInterval set an interval for the startup healthcheck.
   * Changing this setting resets the timer, depending on the state of the container.
   */
  health_startup_interval?: string;
  /**
   * HealthStartupRetries set the maximum number of retries before the startup healthcheck will restart the container.
   */
  health_startup_retries?: number;
  /**
   * HealthStartupSuccess set the number of consecutive successes before the startup healthcheck is marked as successful
   * and the normal healthcheck begins (0 indicates any success will start the regular healthcheck)
   */
  health_startup_success?: number;
  /**
   * HealthStartupTimeout set the maximum amount of time that the startup healthcheck may take before it is considered failed.
   */
  health_startup_timeout?: string;
  /**
   * HealthTimeout set the maximum time allowed to complete the healthcheck before an interval is considered failed.
   */
  health_timeout?: string;
  /**
   * Disable healthchecks on container.
   */
  no_healthcheck?: boolean;
};

/**
 * UpdateResponse ContainerUpdateResponse
 * Response for a successful container-update.
 */
export type UpdateResponse = {
  /**
   * Warnings encountered when updating the container.
   */
  Warnings?: Array<string>;
};

/**
 * UsageData Usage details about the volume. This information is used by the
 * `GET /system/df` endpoint, and omitted in other endpoints.
 */
export type UsageData = {
  /**
   * The number of containers referencing this volume. This field
   * is set to `-1` if the reference-count is not available.
   */
  RefCount: number;
  /**
   * Amount of disk space used by the volume (in bytes). This information
   * is only available for volumes created with the `"local"` volume
   * driver. For volumes created with other volume drivers, this field
   * is set to `-1` ("not available")
   */
  Size: number;
};

/**
 * UsernsMode represents userns mode in the container.
 */
export type UsernsMode = string;

/**
 * Version represents the internal object version.
 */
export type Version = {
  Index?: number;
};

/**
 * Volume volume
 */
export type Volume = {
  ClusterVolume?: ClusterVolume;
  /**
   * Date/Time the volume was created.
   */
  CreatedAt?: string;
  /**
   * Name of the volume driver used by the volume.
   */
  Driver: string;
  /**
   * User-defined key/value metadata.
   */
  Labels: {
    [key: string]: string;
  };
  /**
   * Mount path of the volume on the host.
   */
  Mountpoint: string;
  /**
   * Name of the volume.
   */
  Name: string;
  /**
   * The driver specific options used when creating the volume.
   */
  Options: {
    [key: string]: string;
  };
  /**
   * The level at which the volume exists. Either `global` for cluster-wide,
   * or `local` for machine level.
   */
  Scope: string;
  /**
   * Low-level details about the volume, provided by the volume driver.
   * Details are returned as a map with key/value pairs:
   * `{"key":"value","key2":"value2"}`.
   *
   * The `Status` field is optional, and is omitted if the volume driver
   * does not support this feature.
   */
  Status?: {
    [key: string]: unknown;
  };
  UsageData?: UsageData;
};

export type VolumeConfigResponse = {
  /**
   * Anonymous indicates that the volume was created as an anonymous
   * volume for a specific container, and will be removed when any
   * container using it is removed.
   */
  Anonymous?: boolean;
  /**
   * CreatedAt is the date and time the volume was created at. This is not
   * stored for older Libpod volumes; if so, it will be omitted.
   */
  CreatedAt?: string;
  /**
   * Driver is the driver used to create the volume.
   * If set to "local" or "", the Local driver (Podman built-in code) is
   * used to service the volume; otherwise, a volume plugin with the given
   * name is used to mount and manage the volume.
   */
  Driver?: string;
  /**
   * GID is the GID that the volume was created with.
   */
  GID?: number;
  /**
   * Labels includes the volume's configured labels, key:value pairs that
   * can be passed during volume creation to provide information for third
   * party tools.
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * LockNumber is the number of the volume's Libpod lock.
   */
  LockNumber?: number;
  /**
   * MountCount is the number of times this volume has been mounted.
   */
  MountCount?: number;
  /**
   * Mountpoint is the path on the host where the volume is mounted.
   */
  Mountpoint?: string;
  /**
   * Name is the name of the volume.
   */
  Name?: string;
  /**
   * NeedsChown indicates that the next time the volume is mounted into
   * a container, the container will chown the volume to the container process
   * UID/GID.
   */
  NeedsChown?: boolean;
  /**
   * NeedsCopyUp indicates that the next time the volume is mounted into
   */
  NeedsCopyUp?: boolean;
  /**
   * Options is a set of options that were used when creating the volume.
   * For the Local driver, these are mount options that will be used to
   * determine how a local filesystem is mounted; they are handled as
   * parameters to Mount in a manner described in the volume create
   * manpage.
   * For non-local drivers, these are passed as-is to the volume plugin.
   */
  Options?: {
    [key: string]: string;
  };
  /**
   * Scope is unused and provided solely for Docker compatibility. It is
   * unconditionally set to "local".
   */
  Scope?: string;
  /**
   * Status is used to return information on the volume's current state,
   * if the volume was created using a volume plugin (uses a Driver that
   * is not the local driver).
   * Status is provided to us by an external program, so no guarantees are
   * made about its format or contents. Further, it is an optional field,
   * so it may not be set even in cases where a volume plugin is in use.
   */
  Status?: {
    [key: string]: unknown;
  };
  /**
   * StorageID is the ID of the container backing the volume in c/storage.
   * Only used with Image Volumes.
   */
  StorageID?: string;
  /**
   * Timeout is the specified driver timeout if given
   */
  Timeout?: number;
  /**
   * UID is the UID that the volume was created with.
   */
  UID?: number;
};

export type VolumeCreateOptions = {
  /**
   * Volume driver to use
   */
  Driver?: string;
  /**
   * Ignore existing volumes
   */
  IgnoreIfExists?: boolean;
  /**
   * User-defined key/value metadata. Provided for compatibility
   */
  Label?: {
    [key: string]: string;
  };
  /**
   * User-defined key/value metadata. Preferred field, will override Label
   */
  Labels?: {
    [key: string]: string;
  };
  /**
   * New volume's name. Can be left blank
   */
  Name?: string;
  /**
   * Mapping of driver options and values.
   */
  Options?: {
    [key: string]: string;
  };
};

/**
 * VolumeOptions represents the options for a mount of type volume.
 */
export type VolumeOptions = {
  DriverConfig?: Driver;
  Labels?: {
    [key: string]: string;
  };
  NoCopy?: boolean;
  Subpath?: string;
};

export type VolumeRmReport = {
  Err?: string;
  Id?: string;
};

/**
 * WaitExitError container waiting error, if any
 */
export type WaitExitError = {
  /**
   * Details of an error
   */
  Message?: string;
};

/**
 * WaitResponse ContainerWaitResponse
 * OK response to ContainerWait operation
 */
export type WaitResponse = {
  Error?: WaitExitError;
  /**
   * Exit code of the container
   */
  StatusCode: number;
};

/**
 * WeightDevice is a structure that holds device:weight pair
 */
export type WeightDevice = {
  Path?: string;
  Weight?: number;
};

export type CacheLibImage = {
  [key: string]: unknown;
};

/**
 * Container update
 */
export type ContainerUpdateRequest = {
  BlkioDeviceReadBps?: Array<ThrottleDevice>;
  BlkioDeviceReadIOps?: Array<ThrottleDevice>;
  BlkioDeviceWriteBps?: Array<ThrottleDevice>;
  BlkioDeviceWriteIOps?: Array<ThrottleDevice>;
  BlkioWeight?: number;
  BlkioWeightDevice?: Array<WeightDevice>;
  /**
   * Applicable to UNIX platforms
   */
  CgroupParent?: string;
  /**
   * Applicable to Windows
   */
  CpuCount?: number;
  CpuPercent?: number;
  CpuPeriod?: number;
  CpuQuota?: number;
  CpuRealtimePeriod?: number;
  CpuRealtimeRuntime?: number;
  /**
   * Applicable to all platforms
   */
  CpuShares?: number;
  CpusetCpus?: string;
  CpusetMems?: string;
  DeviceCgroupRules?: Array<string>;
  DeviceRequests?: Array<DeviceRequest>;
  Devices?: Array<DeviceMapping>;
  IOMaximumBandwidth?: number;
  IOMaximumIOps?: number;
  /**
   * KernelMemory specifies the kernel memory limit (in bytes) for the container.
   * Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
   */
  KernelMemory?: number;
  KernelMemoryTCP?: number;
  Memory?: number;
  MemoryReservation?: number;
  MemorySwap?: number;
  MemorySwappiness?: number;
  NanoCpus?: number;
  OomKillDisable?: boolean;
  PidsLimit?: number;
  RestartPolicy?: RestartPolicy;
  Ulimits?: Array<Ulimit>;
};

export type NetworkConnectRequest = ConnectOptions;

export type NetworkConnectRequestLibpod = NetworkConnectOptions;

export type NetworkCreate = CreateRequest;

/**
 * Network create
 */
export type NetworkCreateLibpod = {
  /**
   * Created contains the timestamp when this network was created.
   */
  created?: string;
  /**
   * DNSEnabled is whether name resolution is active for container on
   * this Network. Only supported with the bridge driver.
   */
  dns_enabled?: boolean;
  /**
   * Driver for this Network, e.g. bridge, macvlan...
   */
  driver?: string;
  /**
   * ID of the Network.
   */
  id?: string;
  /**
   * Internal is whether the Network should not have external routes
   * to public or other Networks.
   */
  internal?: boolean;
  /**
   * IPAMOptions contains options used for the ip assignment.
   */
  ipam_options?: {
    [key: string]: string;
  };
  /**
   * IPv6Enabled if set to true an ipv6 subnet should be created for this net.
   */
  ipv6_enabled?: boolean;
  /**
   * Labels is a set of key-value labels that have been applied to the
   * Network.
   */
  labels?: {
    [key: string]: string;
  };
  /**
   * Name of the Network.
   */
  name?: string;
  /**
   * List of custom DNS server for podman's DNS resolver at network level,
   * all the containers attached to this network will consider resolvers
   * configured at network level.
   */
  network_dns_servers?: Array<string>;
  /**
   * NetworkInterface is the network interface name on the host.
   */
  network_interface?: string;
  /**
   * Options is a set of key-value options that have been applied to
   * the Network.
   */
  options?: {
    [key: string]: string;
  };
  /**
   * Routes to use for this network.
   */
  routes?: Array<Route>;
  /**
   * Subnets to use for this network.
   */
  subnets?: Array<Subnet>;
};

export type NetworkDisconnectRequest = DisconnectOptions;

export type NetworkUpdateRequestLibpod = NetworkUpdateOptions;

/**
 * Details for creating a volume
 */
export type VolumeCreate = {
  /**
   * Name of the volume driver to use.
   */
  Driver: string;
  /**
   * A mapping of driver options and values. These options are
   * passed directly to the driver and are driver specific.
   */
  DriverOpts: {
    [key: string]: string;
  };
  /**
   * User-defined key/value metadata.
   */
  Labels: {
    [key: string]: string;
  };
  /**
   * The new volume's name. If not specified, Docker generates a name.
   */
  Name: string;
};

export type SystemAuthData = {
  /**
   * Authentication to check
   */
  body?: AuthConfig;
  path?: never;
  query?: never;
  url: '/auth';
};

export type SystemAuthErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemAuthError = SystemAuthErrors[keyof SystemAuthErrors];

export type SystemAuthResponses = {
  /**
   * Auth response
   */
  200: AuthReport;
};

export type SystemAuthResponse = SystemAuthResponses[keyof SystemAuthResponses];

export type ImageBuildData = {
  /**
   * A tar archive compressed with one of the following algorithms:
   * identity (no compression), gzip, bzip2, xz.
   *
   */
  body?: Blob | File;
  headers?: {
    'Content-Type'?: 'application/x-tar';
    'X-Registry-Config'?: string;
  };
  path?: never;
  query?: {
    /**
     * Path within the build context to the `Dockerfile`.
     * This is ignored if remote is specified and points to an external `Dockerfile`.
     *
     */
    dockerfile?: string;
    /**
     * A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag, the default latest value is assumed. You can provide several t parameters.
     */
    t?: string;
    /**
     * TBD Extra hosts to add to /etc/hosts
     * (As of version 1.xx)
     *
     */
    extrahosts?: string;
    /**
     * Not to create /etc/hosts when building the image
     *
     */
    nohosts?: boolean;
    /**
     * A Git repository URI or HTTP/HTTPS context URI.
     * If the URI points to a single text file, the file’s contents are placed
     * into a file called Dockerfile and the image is built from that file. If
     * the URI points to a tarball, the file is downloaded by the daemon and the
     * contents therein used as the context for the build. If the URI points to a
     * tarball and the dockerfile parameter is also specified, there must be a file
     * with the corresponding path inside the tarball.
     * (As of version 1.xx)
     *
     */
    remote?: string;
    /**
     * Number of times to retry in case of failure when performing push/pull.
     *
     */
    retry?: number;
    /**
     * Delay between retries in case of push/pull failures.
     *
     */
    'retry-delay'?: string;
    /**
     * Suppress verbose build output
     *
     */
    q?: boolean;
    /**
     * Contents of base images to be modified on ADD or COPY only
     * (As of Podman version v5.2)
     *
     */
    compatvolumes?: boolean;
    /**
     * Inherit the labels from the base image or base stages
     * (As of Podman version v5.5)
     *
     */
    inheritlabels?: boolean;
    /**
     * Do not use the cache when building the image
     * (As of version 1.xx)
     *
     */
    nocache?: boolean;
    /**
     * JSON array of images used to build cache resolution
     * (As of version 1.xx)
     *
     */
    cachefrom?: string;
    /**
     * Attempt to pull the image even if an older image exists locally
     * (As of version 1.xx)
     *
     */
    pull?: boolean;
    /**
     * Remove intermediate containers after a successful build
     * (As of version 1.xx)
     *
     */
    rm?: boolean;
    /**
     * Always remove intermediate containers, even upon failure
     * (As of version 1.xx)
     *
     */
    forcerm?: boolean;
    /**
     * Memory is the upper limit (in bytes) on how much memory running containers can use
     * (As of version 1.xx)
     *
     */
    memory?: number;
    /**
     * MemorySwap limits the amount of memory and swap together
     * (As of version 1.xx)
     *
     */
    memswap?: number;
    /**
     * CPUShares (relative weight
     * (As of version 1.xx)
     *
     */
    cpushares?: number;
    /**
     * CPUSetCPUs in which to allow execution (0-3, 0,1)
     * (As of version 1.xx)
     *
     */
    cpusetcpus?: string;
    /**
     * CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period
     * (As of version 1.xx)
     *
     */
    cpuperiod?: number;
    /**
     * CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota
     * (As of version 1.xx)
     *
     */
    cpuquota?: number;
    /**
     * JSON map of string pairs denoting build-time variables.
     * For example, the build argument `Foo` with the value of `bar` would be encoded in JSON as `["Foo":"bar"]`.
     *
     * For example, buildargs={"Foo":"bar"}.
     *
     * Note(s):
     * * This should not be used to pass secrets.
     * * The value of buildargs should be URI component encoded before being passed to the API.
     *
     * (As of version 1.xx)
     *
     */
    buildargs?: string;
    /**
     * ShmSize is the "size" value to use when mounting an shmfs on the container's /dev/shm directory.
     * Default is 64MB
     * (As of version 1.xx)
     *
     */
    shmsize?: number;
    /**
     * Silently ignored.
     * Squash the resulting images layers into a single layer
     * (As of version 1.xx)
     *
     */
    squash?: boolean;
    /**
     * JSON map of key, value pairs to set as labels on the new image
     * (As of version 1.xx)
     *
     */
    labels?: string;
    /**
     * Sets the networking mode for the run commands during build.
     * Supported standard values are:
     * * `bridge` limited to containers within a single host, port mapping required for external access
     * * `host` no isolation between host and containers on this network
     * * `none` disable all networking for this container
     * * container:<nameOrID> share networking with given container
     * ---All other values are assumed to be a custom network's name
     * (As of version 1.xx)
     *
     */
    networkmode?: string;
    /**
     * Platform format os[/arch[/variant]]
     * Can be comma separated list for multi arch builds.
     * (As of version 1.xx)
     *
     */
    platform?: string;
    /**
     * Target build stage
     * (As of version 1.xx)
     *
     */
    target?: string;
    /**
     * output configuration TBD
     * (As of version 1.xx)
     *
     */
    outputs?: string;
  };
  url: '/build';
};

export type ImageBuildErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageBuildError = ImageBuildErrors[keyof ImageBuildErrors];

export type ImageBuildResponses = {
  /**
   * OK (As of version 1.xx)
   */
  200: {
    /**
     * output from build process
     */
    stream: string;
  };
};

export type ImageBuildResponse = ImageBuildResponses[keyof ImageBuildResponses];

export type ImageCommitData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * the name or ID of a container
     */
    container?: string;
    /**
     * the repository name for the created image
     */
    repo?: string;
    /**
     * tag name for the created image
     */
    tag?: string;
    /**
     * commit message
     */
    comment?: string;
    /**
     * author of the image
     */
    author?: string;
    /**
     * pause the container before committing it
     */
    pause?: boolean;
    /**
     * instructions to apply while committing in Dockerfile format
     */
    changes?: string;
    /**
     * squash newly built layers into a single new layer
     */
    squash?: boolean;
  };
  url: '/commit';
};

export type ImageCommitErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageCommitError = ImageCommitErrors[keyof ImageCommitErrors];

export type ImageCommitResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ContainerDeleteData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * If the container is running, kill it before removing it.
     */
    force?: boolean;
    /**
     * Remove the volumes associated with the container.
     */
    v?: boolean;
    /**
     * not supported
     */
    link?: boolean;
  };
  url: '/containers/{name}';
};

export type ContainerDeleteErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerDeleteError = ContainerDeleteErrors[keyof ContainerDeleteErrors];

export type ContainerDeleteResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerArchiveData = {
  body?: never;
  path: {
    /**
     * container name or id
     */
    name: string;
  };
  query: {
    /**
     * Path to a directory in the container to extract
     */
    path: string;
  };
  url: '/containers/{name}/archive';
};

export type ContainerArchiveErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerArchiveError = ContainerArchiveErrors[keyof ContainerArchiveErrors];

export type ContainerArchiveResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ContainerArchiveResponse = ContainerArchiveResponses[keyof ContainerArchiveResponses];

export type PutContainerArchiveData = {
  /**
   * tarfile of files to copy into the container
   */
  body?: string;
  path: {
    /**
     * container name or id
     */
    name: string;
  };
  query: {
    /**
     * Path to a directory in the container to extract
     */
    path: string;
    /**
     * if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa (1 or true)
     */
    noOverwriteDirNonDir?: string;
    /**
     * copy UID/GID maps to the dest file or di (1 or true)
     */
    copyUIDGID?: string;
  };
  url: '/containers/{name}/archive';
};

export type PutContainerArchiveErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * the container rootfs is read-only
   */
  403: unknown;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PutContainerArchiveError = PutContainerArchiveErrors[keyof PutContainerArchiveErrors];

export type PutContainerArchiveResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type ContainerAttachData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * keys to use for detaching from the container
     */
    detachKeys?: string;
    /**
     * Stream all logs from the container across the connection. Happens before streaming attach (if requested). At least one of logs or stream must be set
     */
    logs?: boolean;
    /**
     * Attach to the container. If unset, and logs is set, only the container's logs will be sent. At least one of stream or logs must be set
     */
    stream?: boolean;
    /**
     * Attach to container STDOUT
     */
    stdout?: boolean;
    /**
     * Attach to container STDERR
     */
    stderr?: boolean;
    /**
     * Attach to container STDIN
     */
    stdin?: boolean;
  };
  url: '/containers/{name}/attach';
};

export type ContainerAttachErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerAttachError = ContainerAttachErrors[keyof ContainerAttachErrors];

export type ContainerExecData = {
  /**
   * Attributes for create
   */
  body?: {
    /**
     * Attach to stderr of the exec command
     */
    AttachStderr?: boolean;
    /**
     * Attach to stdin of the exec command
     */
    AttachStdin?: boolean;
    /**
     * Attach to stdout of the exec command
     */
    AttachStdout?: boolean;
    /**
     * Command to run, as a string or array of strings.
     */
    Cmd?: Array<string>;
    /**
     * "Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _."
     *
     */
    DetachKeys?: string;
    /**
     * A list of environment variables in the form ["VAR=value", ...]
     */
    Env?: Array<string>;
    /**
     * Runs the exec process with extended privileges
     */
    Privileged?: boolean;
    /**
     * Allocate a pseudo-TTY
     */
    Tty?: boolean;
    /**
     * "The user, and optionally, group to run the exec process inside the container. Format is one of: user, user:group, uid, or uid:gid."
     *
     */
    User?: string;
    /**
     * The working directory for the exec process inside the container.
     */
    WorkingDir?: string;
  };
  path: {
    /**
     * name of container
     */
    name: string;
  };
  query?: never;
  url: '/containers/{name}/exec';
};

export type ContainerExecErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * container is paused
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerExecError = ContainerExecErrors[keyof ContainerExecErrors];

export type ContainerExecResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ContainerExportData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/containers/{name}/export';
};

export type ContainerExportErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerExportError = ContainerExportErrors[keyof ContainerExportErrors];

export type ContainerExportResponses = {
  /**
   * tarball is returned in body
   */
  200: unknown;
};

export type ContainerInspectData = {
  body?: never;
  path: {
    /**
     * the name or id of the container
     */
    name: string;
  };
  query?: {
    /**
     * include the size of the container
     */
    size?: boolean;
  };
  url: '/containers/{name}/json';
};

export type ContainerInspectErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerInspectError = ContainerInspectErrors[keyof ContainerInspectErrors];

export type ContainerInspectResponses = {
  /**
   * Inspect container
   */
  200: InspectResponse;
};

export type ContainerInspectResponse = ContainerInspectResponses[keyof ContainerInspectResponses];

export type ContainerKillData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Send kill signal to all containers
     */
    all?: boolean;
    /**
     * signal to be sent to container
     */
    signal?: string;
  };
  url: '/containers/{name}/kill';
};

export type ContainerKillErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerKillError = ContainerKillErrors[keyof ContainerKillErrors];

export type ContainerKillResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerLogsData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Keep connection after returning logs.
     */
    follow?: boolean;
    /**
     * Return logs from stdout
     */
    stdout?: boolean;
    /**
     * Return logs from stderr
     */
    stderr?: boolean;
    /**
     * Only return logs since this time, as a UNIX timestamp
     */
    since?: string;
    /**
     * Only return logs before this time, as a UNIX timestamp
     */
    until?: string;
    /**
     * Add timestamps to every log line
     */
    timestamps?: boolean;
    /**
     * Only return this number of log lines from the end of the logs
     */
    tail?: string;
  };
  url: '/containers/{name}/logs';
};

export type ContainerLogsErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerLogsError = ContainerLogsErrors[keyof ContainerLogsErrors];

export type ContainerLogsResponses = {
  /**
   * logs returned as a stream in response body.
   */
  200: unknown;
};

export type ContainerPauseData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/containers/{name}/pause';
};

export type ContainerPauseErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerPauseError = ContainerPauseErrors[keyof ContainerPauseErrors];

export type ContainerPauseResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerRenameData = {
  body?: never;
  path: {
    /**
     * Full or partial ID or full name of the container to rename
     */
    name: string;
  };
  query: {
    /**
     * New name for the container
     */
    name: string;
  };
  url: '/containers/{name}/rename';
};

export type ContainerRenameErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerRenameError = ContainerRenameErrors[keyof ContainerRenameErrors];

export type ContainerRenameResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerResizeData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Height to set for the terminal, in characters
     */
    h?: number;
    /**
     * Width to set for the terminal, in characters
     */
    w?: number;
    /**
     * Ignore containers not running errors
     */
    running?: boolean;
  };
  url: '/containers/{name}/resize';
};

export type ContainerResizeErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerResizeError = ContainerResizeErrors[keyof ContainerResizeErrors];

export type ContainerResizeResponses = {
  /**
   * Success
   */
  200: {
    [key: string]: unknown;
  };
};

export type ContainerResizeResponse = ContainerResizeResponses[keyof ContainerResizeResponses];

export type ContainerRestartData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * timeout before sending kill signal to container
     */
    t?: number;
  };
  url: '/containers/{name}/restart';
};

export type ContainerRestartErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerRestartError = ContainerRestartErrors[keyof ContainerRestartErrors];

export type ContainerRestartResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerStartData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _.
     */
    detachKeys?: string;
  };
  url: '/containers/{name}/start';
};

export type ContainerStartErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerStartError = ContainerStartErrors[keyof ContainerStartErrors];

export type ContainerStartResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerStatsData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Stream the output
     */
    stream?: boolean;
    /**
     * Provide a one-shot response in which preCPU stats are blank, resulting in a single cycle return.
     */
    'one-shot'?: boolean;
  };
  url: '/containers/{name}/stats';
};

export type ContainerStatsErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerStatsError = ContainerStatsErrors[keyof ContainerStatsErrors];

export type ContainerStatsResponses = {
  /**
   * no error
   */
  200: {
    [key: string]: unknown;
  };
};

export type ContainerStatsResponse = ContainerStatsResponses[keyof ContainerStatsResponses];

export type ContainerStopData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * number of seconds to wait before killing container
     */
    t?: number;
  };
  url: '/containers/{name}/stop';
};

export type ContainerStopErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerStopError = ContainerStopErrors[keyof ContainerStopErrors];

export type ContainerStopResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerTopData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * arguments to pass to ps such as aux.
     */
    ps_args?: string;
  };
  url: '/containers/{name}/top';
};

export type ContainerTopErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerTopError = ContainerTopErrors[keyof ContainerTopErrors];

export type ContainerTopResponses = {
  /**
   * List processes in container
   */
  200: ContainerTopOkBody;
};

export type ContainerTopResponse = ContainerTopResponses[keyof ContainerTopResponses];

export type ContainerUnpauseData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/containers/{name}/unpause';
};

export type ContainerUnpauseErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerUnpauseError = ContainerUnpauseErrors[keyof ContainerUnpauseErrors];

export type ContainerUnpauseResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerUpdateData = {
  /**
   * attributes for updating the container
   */
  body?: ContainerUpdateRequest;
  path: {
    /**
     * Full or partial ID or full name of the container to rename
     */
    name: string;
  };
  query?: never;
  url: '/containers/{name}/update';
};

export type ContainerUpdateErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerUpdateError = ContainerUpdateErrors[keyof ContainerUpdateErrors];

export type ContainerUpdateResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type ContainerWaitData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * wait until container is to a given condition. default is stopped. valid conditions are:
     * - configured
     * - created
     * - exited
     * - paused
     * - running
     * - stopped
     *
     */
    condition?: string;
    /**
     * Time Interval to wait before polling for completion.
     */
    interval?: string;
  };
  url: '/containers/{name}/wait';
};

export type ContainerWaitErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerWaitError = ContainerWaitErrors[keyof ContainerWaitErrors];

export type ContainerWaitResponses = {
  /**
   * Wait container
   */
  200: {
    Error?: {
      Message?: string;
    };
    /**
     * container exit code
     */
    StatusCode?: number;
  };
};

export type ContainerWaitResponse = ContainerWaitResponses[keyof ContainerWaitResponses];

export type ContainerCreateData = {
  /**
   * Container to create
   */
  body: CreateContainerConfig;
  path?: never;
  query?: {
    /**
     * container name
     */
    name?: string;
  };
  url: '/containers/create';
};

export type ContainerCreateErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerCreateError = ContainerCreateErrors[keyof ContainerCreateErrors];

export type ContainerCreateResponses = {
  /**
   * Create container
   */
  201: ContainerCreateResponse;
};

export type ContainerCreateResponse2 = ContainerCreateResponses[keyof ContainerCreateResponses];

export type ContainerListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Return all containers. By default, only running containers are shown
     */
    all?: boolean;
    /**
     * Return containers in storage not controlled by Podman
     */
    external?: boolean;
    /**
     * Return this number of most recently created containers, including non-running ones.
     */
    limit?: number;
    /**
     * Return the size of container as fields SizeRw and SizeRootFs.
     */
    size?: boolean;
    /**
     * A JSON encoded value of the filters (a `map[string][]string`) to process on the containers list. Available filters:
     * - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`)
     * - `before`=(`<container id>` or `<container name>`)
     * - `expose`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`)
     * - `exited=<int>` containers with exit code of `<int>`
     * - `health`=(`starting`, `healthy`, `unhealthy` or `none`)
     * - `id=<ID>` a container's ID
     * - `is-task`=(`true` or `false`)
     * - `label`=(`key` or `"key=value"`) of a container label
     * - `name=<name>` a container's name
     * - `network`=(`<network id>` or `<network name>`)
     * - `publish`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`)
     * - `since`=(`<container id>` or `<container name>`)
     * - `status`=(`created`, `restarting`, `running`, `removing`, `paused`, `exited` or `dead`)
     * - `volume`=(`<volume name>` or `<mount point destination>`)
     *
     */
    filters?: string;
  };
  url: '/containers/json';
};

export type ContainerListErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerListError = ContainerListErrors[keyof ContainerListErrors];

export type ContainerListResponses = {
  /**
   * List Containers
   */
  200: Array<Container>;
};

export type ContainerListResponse = ContainerListResponses[keyof ContainerListResponses];

export type ContainerPruneData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:
     * - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/containers/prune';
};

export type ContainerPruneErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerPruneError = ContainerPruneErrors[keyof ContainerPruneErrors];

export type ContainerPruneResponses = {
  /**
   * Prune Containers
   */
  200: Array<ContainersPruneReport>;
};

export type ContainerPruneResponse = ContainerPruneResponses[keyof ContainerPruneResponses];

export type SystemEventsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * start streaming events from this time
     */
    since?: string;
    /**
     * stop streaming events later than this
     */
    until?: string;
    /**
     * JSON encoded map[string][]string of constraints
     */
    filters?: string;
  };
  url: '/events';
};

export type SystemEventsErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemEventsError = SystemEventsErrors[keyof SystemEventsErrors];

export type SystemEventsResponses = {
  /**
   * returns a string of json data describing an event
   */
  200: unknown;
};

export type ExecInspectData = {
  body?: never;
  path: {
    /**
     * Exec instance ID
     */
    id: string;
  };
  query?: never;
  url: '/exec/{id}/json';
};

export type ExecInspectErrors = {
  /**
   * No such exec instance
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ExecInspectError = ExecInspectErrors[keyof ExecInspectErrors];

export type ExecInspectResponses = {
  /**
   * Exec Session Inspect
   */
  200: InspectExecSession;
};

export type ExecInspectResponse = ExecInspectResponses[keyof ExecInspectResponses];

export type ExecResizeData = {
  body?: never;
  path: {
    /**
     * Exec instance ID
     */
    id: string;
  };
  query?: {
    /**
     * Height of the TTY session in characters
     */
    h?: number;
    /**
     * Width of the TTY session in characters
     */
    w?: number;
    /**
     * Ignore containers not running errors
     */
    running?: boolean;
  };
  url: '/exec/{id}/resize';
};

export type ExecResizeErrors = {
  /**
   * No such exec instance
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ExecResizeError = ExecResizeErrors[keyof ExecResizeErrors];

export type ExecResizeResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ExecStartData = {
  /**
   * Attributes for start
   */
  body?: {
    /**
     * Detach from the command. Not presently supported.
     */
    Detach?: boolean;
    /**
     * Allocate a pseudo-TTY. Presently ignored.
     */
    Tty?: boolean;
  };
  path: {
    /**
     * Exec instance ID
     */
    id: string;
  };
  query?: never;
  url: '/exec/{id}/start';
};

export type ExecStartErrors = {
  /**
   * No such exec instance
   */
  404: ErrorModel;
  /**
   * container is not running
   */
  409: Blob | File;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ExecStartError = ExecStartErrors[keyof ExecStartErrors];

export type ExecStartResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ExecStartResponse = ExecStartResponses[keyof ExecStartResponses];

export type ImageDeleteData = {
  body?: never;
  path: {
    /**
     * name or ID of image to delete
     */
    name: string;
  };
  query?: {
    /**
     * remove the image even if used by containers or has other tags
     */
    force?: boolean;
    /**
     * do not remove dangling parent images
     */
    noprune?: boolean;
  };
  url: '/images/{name}';
};

export type ImageDeleteErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageDeleteError = ImageDeleteErrors[keyof ImageDeleteErrors];

export type ImageDeleteResponses = {
  /**
   * Image Delete
   */
  200: Array<{
    deleted?: string;
    untagged?: Array<string>;
  }>;
};

export type ImageDeleteResponse = ImageDeleteResponses[keyof ImageDeleteResponses];

export type ImageGetData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/images/{name}/get';
};

export type ImageGetErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageGetError = ImageGetErrors[keyof ImageGetErrors];

export type ImageGetResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImageGetResponse = ImageGetResponses[keyof ImageGetResponses];

export type ImageHistoryData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/images/{name}/history';
};

export type ImageHistoryErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageHistoryError = ImageHistoryErrors[keyof ImageHistoryErrors];

export type ImageHistoryResponses = {
  /**
   * Image History
   */
  200: HistoryResponse;
};

export type ImageHistoryResponse = ImageHistoryResponses[keyof ImageHistoryResponses];

export type ImageInspectData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/images/{name}/json';
};

export type ImageInspectErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageInspectError = ImageInspectErrors[keyof ImageInspectErrors];

export type ImageInspectResponses = {
  /**
   * Image Inspect
   */
  200: ImageInspect;
};

export type ImageInspectResponse = ImageInspectResponses[keyof ImageInspectResponses];

export type ImagePushData = {
  body?: never;
  headers?: {
    /**
     * A base64-encoded auth configuration.
     */
    'X-Registry-Auth'?: string;
  };
  path: {
    /**
     * Name of image to push.
     */
    name: string;
  };
  query?: {
    /**
     * The tag to associate with the image on the registry.
     */
    tag?: string;
    /**
     * All indicates whether to push all images related to the image list
     */
    all?: boolean;
    /**
     * Use compression on image.
     */
    compress?: boolean;
    /**
     * Allows for pushing the image to a different destination than the image refers to.
     */
    destination?: string;
    /**
     * Manifest type (oci, v2s1, or v2s2) to use when pushing an image. Default is manifest type of source, with fallbacks.
     */
    format?: string;
    /**
     * Require TLS verification.
     */
    tlsVerify?: boolean;
  };
  url: '/images/{name}/push';
};

export type ImagePushErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImagePushError = ImagePushErrors[keyof ImagePushErrors];

export type ImagePushResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImagePushResponse = ImagePushResponses[keyof ImagePushResponses];

export type ImageTagData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * the repository to tag in
     */
    repo?: string;
    /**
     * the name of the new tag
     */
    tag?: string;
  };
  url: '/images/{name}/tag';
};

export type ImageTagErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageTagError = ImageTagErrors[keyof ImageTagErrors];

export type ImageTagResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ImageCreateData = {
  /**
   * Image content if fromSrc parameter was used
   */
  body?: Blob | File;
  headers?: {
    /**
     * A base64-encoded auth configuration.
     */
    'X-Registry-Auth'?: string;
  };
  path?: never;
  query?: {
    /**
     * Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
     */
    fromImage?: string;
    /**
     * Source to import. The value may be a URL from which the image can be retrieved or - to read the image from the request body. This parameter may only be used when importing an image
     */
    fromSrc?: string;
    /**
     * Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
     */
    repo?: string;
    /**
     * Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
     */
    tag?: string;
    /**
     * Set commit message for imported image.
     */
    message?: string;
    /**
     * Platform in the format os[/arch[/variant]]
     */
    platform?: string;
  };
  url: '/images/create';
};

export type ImageCreateErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageCreateError = ImageCreateErrors[keyof ImageCreateErrors];

export type ImageCreateResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImageCreateResponse = ImageCreateResponses[keyof ImageCreateResponses];

export type ImageGetAllData = {
  body?: never;
  path?: never;
  query: {
    /**
     * one or more image names or IDs comma separated
     */
    names: string;
  };
  url: '/images/get';
};

export type ImageGetAllErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageGetAllError = ImageGetAllErrors[keyof ImageGetAllErrors];

export type ImageGetAllResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImageGetAllResponse = ImageGetAllResponses[keyof ImageGetAllResponses];

export type ImageListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Show all images. Only images from a final layer (no children) are shown by default.
     */
    all?: boolean;
    /**
     * A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
     * - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
     * - `dangling=true`
     * - `label=key` or `label="key=value"` of an image label
     * - `reference`=(`<image-name>[:<tag>]`)
     * - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
     *
     */
    filters?: string;
    /**
     * Not supported
     */
    digests?: boolean;
  };
  url: '/images/json';
};

export type ImageListErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageListError = ImageListErrors[keyof ImageListErrors];

export type ImageListResponses = {
  /**
   * Image summary for compat API
   */
  200: Array<Summary>;
};

export type ImageListResponse = ImageListResponses[keyof ImageListResponses];

export type ImageLoadData = {
  /**
   * tarball of container image
   */
  body?: string;
  path?: never;
  query?: {
    /**
     * not supported
     */
    quiet?: boolean;
  };
  url: '/images/load';
};

export type ImageLoadErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageLoadError = ImageLoadErrors[keyof ImageLoadErrors];

export type ImageLoadResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type ImagePruneData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:
     * - `dangling=<boolean>` When set to `true` (or `1`), prune only
     * unused *and* untagged images. When set to `false`
     * (or `0`), all unused images are pruned.
     * - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/images/prune';
};

export type ImagePruneErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImagePruneError = ImagePruneErrors[keyof ImagePruneErrors];

export type ImagePruneResponses = {
  /**
   * Image Delete
   */
  200: Array<{
    deleted?: string;
    untagged?: Array<string>;
  }>;
};

export type ImagePruneResponse = ImagePruneResponses[keyof ImagePruneResponses];

export type ImageSearchData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * term to search
     */
    term?: string;
    /**
     * maximum number of results
     */
    limit?: number;
    /**
     * A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
     * - `is-automated=(true|false)`
     * - `is-official=(true|false)`
     * - `stars=<number>` Matches images that have at least 'number' stars.
     *
     */
    filters?: string;
    /**
     * Require HTTPS and verify signatures when contacting registries.
     */
    tlsVerify?: boolean;
    /**
     * list the available tags in the repository
     */
    listTags?: boolean;
  };
  url: '/images/search';
};

export type ImageSearchErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageSearchError = ImageSearchErrors[keyof ImageSearchErrors];

export type ImageSearchResponses = {
  /**
   * Registry Search
   */
  200: {
    /**
     * Automated indicates if the image was created by an automated build.
     */
    Automated?: string;
    /**
     * Description of the image.
     */
    Description?: string;
    /**
     * Index is the image index
     */
    Index?: string;
    /**
     * Name is the canonical name of the image
     */
    Name?: string;
    /**
     * Official indicates if it's an official image.
     */
    Official?: string;
    /**
     * Stars is the number of stars of the image.
     */
    Stars?: number;
    /**
     * Tag is the image tag
     */
    Tag?: string;
  };
};

export type ImageSearchResponse = ImageSearchResponses[keyof ImageSearchResponses];

export type SystemInfoData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/info';
};

export type SystemInfoErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemInfoError = SystemInfoErrors[keyof SystemInfoErrors];

export type SystemInfoResponses = {
  /**
   * to be determined
   */
  200: unknown;
};

export type SystemPingData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/_ping';
};

export type SystemPingErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemPingError = SystemPingErrors[keyof SystemPingErrors];

export type SystemPingResponses = {
  /**
   * OK
   */
  200: string;
};

export type SystemPingResponse = SystemPingResponses[keyof SystemPingResponses];

export type ImageBuildLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Path within the build context to the `Dockerfile`.
     * This is ignored if remote is specified and points to an external `Dockerfile`.
     *
     */
    dockerfile?: string;
    /**
     * A name and optional tag to apply to the image in the `name:tag` format.  If you omit the tag, the default latest value is assumed. You can provide several t parameters.
     */
    t?: string;
    /**
     * Instead of building for a set of platforms specified using the platform option, inspect the build's base images,
     * and build for all of the platforms that are available.  Stages that use *scratch* as a starting point can not be inspected,
     * so at least one non-*scratch* stage must be present for detection to work usefully.
     *
     */
    allplatforms?: boolean;
    /**
     * TBD Extra hosts to add to /etc/hosts
     * (As of version 1.xx)
     *
     */
    extrahosts?: string;
    /**
     * Not to create /etc/hosts when building the image
     *
     */
    nohosts?: boolean;
    /**
     * A Git repository URI or HTTP/HTTPS context URI.
     * If the URI points to a single text file, the file’s contents are placed
     * into a file called Dockerfile and the image is built from that file. If
     * the URI points to a tarball, the file is downloaded by the daemon and the
     * contents therein used as the context for the build. If the URI points to a
     * tarball and the dockerfile parameter is also specified, there must be a file
     * with the corresponding path inside the tarball.
     * (As of version 1.xx)
     *
     */
    remote?: string;
    /**
     * Suppress verbose build output
     *
     */
    q?: boolean;
    /**
     * Contents of base images to be modified on ADD or COPY only
     * (As of Podman version v5.2)
     *
     */
    compatvolumes?: boolean;
    /**
     * Inherit the labels from the base image or base stages
     * (As of Podman version v5.5)
     *
     */
    inheritlabels?: boolean;
    /**
     * Do not use the cache when building the image
     * (As of version 1.xx)
     *
     */
    nocache?: boolean;
    /**
     * JSON array of images used to build cache resolution
     * (As of version 1.xx)
     *
     */
    cachefrom?: string;
    /**
     * Attempt to pull the image even if an older image exists locally
     * (As of version 1.xx)
     *
     */
    pull?: boolean;
    /**
     * Remove intermediate containers after a successful build
     * (As of version 1.xx)
     *
     */
    rm?: boolean;
    /**
     * Always remove intermediate containers, even upon failure
     * (As of version 1.xx)
     *
     */
    forcerm?: boolean;
    /**
     * Memory is the upper limit (in bytes) on how much memory running containers can use
     * (As of version 1.xx)
     *
     */
    memory?: number;
    /**
     * MemorySwap limits the amount of memory and swap together
     * (As of version 1.xx)
     *
     */
    memswap?: number;
    /**
     * CPUShares (relative weight
     * (As of version 1.xx)
     *
     */
    cpushares?: number;
    /**
     * CPUSetCPUs in which to allow execution (0-3, 0,1)
     * (As of version 1.xx)
     *
     */
    cpusetcpus?: string;
    /**
     * CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period
     * (As of version 1.xx)
     *
     */
    cpuperiod?: number;
    /**
     * CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota
     * (As of version 1.xx)
     *
     */
    cpuquota?: number;
    /**
     * JSON map of string pairs denoting build-time variables.
     * For example, the build argument `Foo` with the value of `bar` would be encoded in JSON as `["Foo":"bar"]`.
     *
     * For example, buildargs={"Foo":"bar"}.
     *
     * Note(s):
     * * This should not be used to pass secrets.
     * * The value of buildargs should be URI component encoded before being passed to the API.
     *
     * (As of version 1.xx)
     *
     */
    buildargs?: string;
    /**
     * ShmSize is the "size" value to use when mounting an shmfs on the container's /dev/shm directory.
     * Default is 64MB
     * (As of version 1.xx)
     *
     */
    shmsize?: number;
    /**
     * Silently ignored.
     * Squash the resulting images layers into a single layer
     * (As of version 1.xx)
     *
     */
    squash?: boolean;
    /**
     * JSON map of key, value pairs to set as labels on the new image
     * (As of version 1.xx)
     *
     */
    labels?: string;
    /**
     * Add an intermediate image *label* (e.g. label=*value*) to the intermediate image metadata.
     */
    layerLabel?: Array<string>;
    /**
     * Cache intermediate layers during build.
     * (As of version 1.xx)
     *
     */
    layers?: boolean;
    /**
     * Sets the networking mode for the run commands during build.
     * Supported standard values are:
     * * `bridge` limited to containers within a single host, port mapping required for external access
     * * `host` no isolation between host and containers on this network
     * * `none` disable all networking for this container
     * * container:<nameOrID> share networking with given container
     * ---All other values are assumed to be a custom network's name
     * (As of version 1.xx)
     *
     */
    networkmode?: string;
    /**
     * Platform format os[/arch[/variant]]
     * (As of version 1.xx)
     *
     */
    platform?: string;
    /**
     * Target build stage
     * (As of version 1.xx)
     *
     */
    target?: string;
    /**
     * output configuration TBD
     * (As of version 1.xx)
     *
     */
    outputs?: string;
    /**
     * Inject http proxy environment variables into container
     * (As of version 2.0.0)
     *
     */
    httpproxy?: boolean;
    /**
     * Unset environment variables from the final image.
     */
    unsetenv?: Array<string>;
    /**
     * Unset the image label, causing the label not to be inherited from the base image.
     */
    unsetlabel?: Array<string>;
    /**
     * Extra volumes that should be mounted in the build container.
     */
    volume?: Array<string>;
  };
  url: '/libpod/build';
};

export type ImageBuildLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageBuildLibpodError = ImageBuildLibpodErrors[keyof ImageBuildLibpodErrors];

export type ImageBuildLibpodResponses = {
  /**
   * OK (As of version 1.xx)
   */
  200: {
    /**
     * output from build process
     */
    stream: string;
  };
};

export type ImageBuildLibpodResponse = ImageBuildLibpodResponses[keyof ImageBuildLibpodResponses];

export type ImageCommitLibpodData = {
  body?: never;
  path?: never;
  query: {
    /**
     * the name or ID of a container
     */
    container: string;
    /**
     * author of the image
     */
    author?: string;
    /**
     * instructions to apply while committing in Dockerfile format (i.e. "CMD=/bin/foo")
     */
    changes?: Array<string>;
    /**
     * commit message
     */
    comment?: string;
    /**
     * format of the image manifest and metadata (default "oci")
     */
    format?: string;
    /**
     * pause the container before committing it
     */
    pause?: boolean;
    /**
     * squash the container before committing it
     */
    squash?: boolean;
    /**
     * the repository name for the created image
     */
    repo?: string;
    /**
     * output from commit process
     */
    stream?: boolean;
    /**
     * tag name for the created image
     */
    tag?: string;
  };
  url: '/libpod/commit';
};

export type ImageCommitLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageCommitLibpodError = ImageCommitLibpodErrors[keyof ImageCommitLibpodErrors];

export type ImageCommitLibpodResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ContainerDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * additionally remove containers that depend on the container to be removed
     */
    depend?: boolean;
    /**
     * force stop container if running
     */
    force?: boolean;
    /**
     * ignore errors when the container to be removed does not existxo
     */
    ignore?: boolean;
    /**
     * number of seconds to wait before killing container when force removing
     */
    timeout?: number;
    /**
     * delete volumes
     */
    v?: boolean;
  };
  url: '/libpod/containers/{name}';
};

export type ContainerDeleteLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerDeleteLibpodError = ContainerDeleteLibpodErrors[keyof ContainerDeleteLibpodErrors];

export type ContainerDeleteLibpodResponses = {
  /**
   * Remove Containers
   */
  200: Array<LibpodContainersRmReport>;
  /**
   * no error
   */
  204: unknown;
};

export type ContainerDeleteLibpodResponse = ContainerDeleteLibpodResponses[keyof ContainerDeleteLibpodResponses];

export type ContainerArchiveLibpodData = {
  body?: never;
  path: {
    /**
     * container name or id
     */
    name: string;
  };
  query: {
    /**
     * Path to a directory in the container to extract
     */
    path: string;
    /**
     * JSON encoded map[string]string to translate paths
     */
    rename?: string;
  };
  url: '/libpod/containers/{name}/archive';
};

export type ContainerArchiveLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerArchiveLibpodError = ContainerArchiveLibpodErrors[keyof ContainerArchiveLibpodErrors];

export type ContainerArchiveLibpodResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ContainerArchiveLibpodResponse = ContainerArchiveLibpodResponses[keyof ContainerArchiveLibpodResponses];

export type PutContainerArchiveLibpodData = {
  /**
   * tarfile of files to copy into the container
   */
  body?: string;
  path: {
    /**
     * container name or id
     */
    name: string;
  };
  query: {
    /**
     * Path to a directory in the container to extract
     */
    path: string;
    /**
     * pause the container while copying (defaults to true)
     */
    pause?: boolean;
  };
  url: '/libpod/containers/{name}/archive';
};

export type PutContainerArchiveLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * the container rootfs is read-only
   */
  403: unknown;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PutContainerArchiveLibpodError = PutContainerArchiveLibpodErrors[keyof PutContainerArchiveLibpodErrors];

export type PutContainerArchiveLibpodResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type ContainerAttachLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * keys to use for detaching from the container
     */
    detachKeys?: string;
    /**
     * Stream all logs from the container across the connection. Happens before streaming attach (if requested). At least one of logs or stream must be set
     */
    logs?: boolean;
    /**
     * Attach to the container. If unset, and logs is set, only the container's logs will be sent. At least one of stream or logs must be set
     */
    stream?: boolean;
    /**
     * Attach to container STDOUT
     */
    stdout?: boolean;
    /**
     * Attach to container STDERR
     */
    stderr?: boolean;
    /**
     * Attach to container STDIN
     */
    stdin?: boolean;
  };
  url: '/libpod/containers/{name}/attach';
};

export type ContainerAttachLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerAttachLibpodError = ContainerAttachLibpodErrors[keyof ContainerAttachLibpodErrors];

export type ContainerChangesLibpodData = {
  body?: never;
  path: {
    /**
     * the name or id of the container
     */
    name: string;
  };
  query?: {
    /**
     * specify a second layer which is used to compare against it instead of the parent layer
     */
    parent?: string;
    /**
     * select what you want to match, default is all
     */
    diffType?: 'all' | 'container' | 'image';
  };
  url: '/libpod/containers/{name}/changes';
};

export type ContainerChangesLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerChangesLibpodError = ContainerChangesLibpodErrors[keyof ContainerChangesLibpodErrors];

export type ContainerChangesLibpodResponses = {
  /**
   * Array of Changes
   */
  200: unknown;
};

export type ContainerCheckpointLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * keep all temporary checkpoint files
     */
    keep?: boolean;
    /**
     * leave the container running after writing checkpoint to disk
     */
    leaveRunning?: boolean;
    /**
     * checkpoint a container with established TCP connections
     */
    tcpEstablished?: boolean;
    /**
     * export the checkpoint image to a tar.gz
     */
    export?: boolean;
    /**
     * do not include root file-system changes when exporting. can only be used with export
     */
    ignoreRootFS?: boolean;
    /**
     * do not include associated volumes. can only be used with export
     */
    ignoreVolumes?: boolean;
    /**
     * dump the container's memory information only, leaving the container running. only works on runc 1.0-rc or higher
     */
    preCheckpoint?: boolean;
    /**
     * check out the container with previous criu image files in pre-dump. only works on runc 1.0-rc or higher
     */
    withPrevious?: boolean;
    /**
     * checkpoint a container with filelocks
     */
    fileLocks?: boolean;
    /**
     * add checkpoint statistics to the returned CheckpointReport
     */
    printStats?: boolean;
  };
  url: '/libpod/containers/{name}/checkpoint';
};

export type ContainerCheckpointLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerCheckpointLibpodError = ContainerCheckpointLibpodErrors[keyof ContainerCheckpointLibpodErrors];

export type ContainerCheckpointLibpodResponses = {
  /**
   * tarball is returned in body if exported
   */
  200: unknown;
};

export type ContainerExecLibpodData = {
  /**
   * Attributes for create
   */
  body?: {
    /**
     * Attach to stderr of the exec command
     */
    AttachStderr?: boolean;
    /**
     * Attach to stdin of the exec command
     */
    AttachStdin?: boolean;
    /**
     * Attach to stdout of the exec command
     */
    AttachStdout?: boolean;
    /**
     * Command to run, as a string or array of strings.
     */
    Cmd?: Array<string>;
    /**
     * "Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _."
     *
     */
    DetachKeys?: string;
    /**
     * A list of environment variables in the form ["VAR=value", ...]
     */
    Env?: Array<string>;
    /**
     * Runs the exec process with extended privileges
     */
    Privileged?: boolean;
    /**
     * Allocate a pseudo-TTY
     */
    Tty?: boolean;
    /**
     * "The user, and optionally, group to run the exec process inside the container. Format is one of: user, user:group, uid, or uid:gid."
     *
     */
    User?: string;
    /**
     * The working directory for the exec process inside the container.
     */
    WorkingDir?: string;
  };
  path: {
    /**
     * name of container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/exec';
};

export type ContainerExecLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * container is paused
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerExecLibpodError = ContainerExecLibpodErrors[keyof ContainerExecLibpodErrors];

export type ContainerExecLibpodResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ContainerExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/exists';
};

export type ContainerExistsLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerExistsLibpodError = ContainerExistsLibpodErrors[keyof ContainerExistsLibpodErrors];

export type ContainerExistsLibpodResponses = {
  /**
   * container exists
   */
  204: unknown;
};

export type ContainerExportLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/export';
};

export type ContainerExportLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerExportLibpodError = ContainerExportLibpodErrors[keyof ContainerExportLibpodErrors];

export type ContainerExportLibpodResponses = {
  /**
   * tarball is returned in body
   */
  200: unknown;
};

export type ContainerHealthcheckLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/healthcheck';
};

export type ContainerHealthcheckLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * container has no healthcheck or is not running
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerHealthcheckLibpodError = ContainerHealthcheckLibpodErrors[keyof ContainerHealthcheckLibpodErrors];

export type ContainerHealthcheckLibpodResponses = {
  /**
   * Healthcheck Results
   */
  200: HealthCheckResults;
};

export type ContainerHealthcheckLibpodResponse =
  ContainerHealthcheckLibpodResponses[keyof ContainerHealthcheckLibpodResponses];

export type ContainerInitLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/init';
};

export type ContainerInitLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerInitLibpodError = ContainerInitLibpodErrors[keyof ContainerInitLibpodErrors];

export type ContainerInitLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * display filesystem usage
     */
    size?: boolean;
  };
  url: '/libpod/containers/{name}/json';
};

export type ContainerInspectLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerInspectLibpodError = ContainerInspectLibpodErrors[keyof ContainerInspectLibpodErrors];

export type ContainerInspectLibpodResponses = {
  /**
   * Inspect container
   */
  200: InspectContainerData;
};

export type ContainerInspectLibpodResponse = ContainerInspectLibpodResponses[keyof ContainerInspectLibpodResponses];

export type ContainerKillLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * signal to be sent to container, either by integer or SIG_ name
     */
    signal?: string;
  };
  url: '/libpod/containers/{name}/kill';
};

export type ContainerKillLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerKillLibpodError = ContainerKillLibpodErrors[keyof ContainerKillLibpodErrors];

export type ContainerKillLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerLogsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Keep connection after returning logs.
     */
    follow?: boolean;
    /**
     * Return logs from stdout
     */
    stdout?: boolean;
    /**
     * Return logs from stderr
     */
    stderr?: boolean;
    /**
     * Only return logs since this time, as a UNIX timestamp
     */
    since?: string;
    /**
     * Only return logs before this time, as a UNIX timestamp
     */
    until?: string;
    /**
     * Add timestamps to every log line
     */
    timestamps?: boolean;
    /**
     * Only return this number of log lines from the end of the logs
     */
    tail?: string;
  };
  url: '/libpod/containers/{name}/logs';
};

export type ContainerLogsLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerLogsLibpodError = ContainerLogsLibpodErrors[keyof ContainerLogsLibpodErrors];

export type ContainerLogsLibpodResponses = {
  /**
   * logs returned as a stream in response body.
   */
  200: unknown;
};

export type ContainerMountLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/mount';
};

export type ContainerMountLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerMountLibpodError = ContainerMountLibpodErrors[keyof ContainerMountLibpodErrors];

export type ContainerMountLibpodResponses = {
  /**
   * id
   */
  200: string;
};

export type ContainerMountLibpodResponse = ContainerMountLibpodResponses[keyof ContainerMountLibpodResponses];

export type ContainerPauseLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/pause';
};

export type ContainerPauseLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerPauseLibpodError = ContainerPauseLibpodErrors[keyof ContainerPauseLibpodErrors];

export type ContainerPauseLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerRenameLibpodData = {
  body?: never;
  path: {
    /**
     * Full or partial ID or full name of the container to rename
     */
    name: string;
  };
  query: {
    /**
     * New name for the container
     */
    name: string;
  };
  url: '/libpod/containers/{name}/rename';
};

export type ContainerRenameLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerRenameLibpodError = ContainerRenameLibpodErrors[keyof ContainerRenameLibpodErrors];

export type ContainerRenameLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerResizeLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Height to set for the terminal, in characters
     */
    h?: number;
    /**
     * Width to set for the terminal, in characters
     */
    w?: number;
  };
  url: '/libpod/containers/{name}/resize';
};

export type ContainerResizeLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerResizeLibpodError = ContainerResizeLibpodErrors[keyof ContainerResizeLibpodErrors];

export type ContainerResizeLibpodResponses = {
  /**
   * Success
   */
  200: {
    [key: string]: unknown;
  };
};

export type ContainerResizeLibpodResponse = ContainerResizeLibpodResponses[keyof ContainerResizeLibpodResponses];

export type ContainerRestartLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * number of seconds to wait before killing container
     */
    t?: number;
  };
  url: '/libpod/containers/{name}/restart';
};

export type ContainerRestartLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerRestartLibpodError = ContainerRestartLibpodErrors[keyof ContainerRestartLibpodErrors];

export type ContainerRestartLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerRestoreLibpodData = {
  body?: never;
  path: {
    /**
     * the name or id of the container
     */
    name: string;
  };
  query?: {
    /**
     * the name of the container when restored from a tar. can only be used with import
     */
    name?: string;
    /**
     * keep all temporary checkpoint files
     */
    keep?: boolean;
    /**
     * checkpoint a container with established TCP connections
     */
    tcpEstablished?: boolean;
    /**
     * import the restore from a checkpoint tar.gz
     */
    import?: boolean;
    /**
     * do not include root file-system changes when exporting. can only be used with import
     */
    ignoreRootFS?: boolean;
    /**
     * do not restore associated volumes. can only be used with import
     */
    ignoreVolumes?: boolean;
    /**
     * ignore IP address if set statically
     */
    ignoreStaticIP?: boolean;
    /**
     * ignore MAC address if set statically
     */
    ignoreStaticMAC?: boolean;
    /**
     * restore a container with file locks
     */
    fileLocks?: boolean;
    /**
     * add restore statistics to the returned RestoreReport
     */
    printStats?: boolean;
    /**
     * pod to restore into
     */
    pod?: string;
  };
  url: '/libpod/containers/{name}/restore';
};

export type ContainerRestoreLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerRestoreLibpodError = ContainerRestoreLibpodErrors[keyof ContainerRestoreLibpodErrors];

export type ContainerRestoreLibpodResponses = {
  /**
   * tarball is returned in body if exported
   */
  200: unknown;
};

export type ContainerStartLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _.
     */
    detachKeys?: string;
  };
  url: '/libpod/containers/{name}/start';
};

export type ContainerStartLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerStartLibpodError = ContainerStartLibpodErrors[keyof ContainerStartLibpodErrors];

export type ContainerStartLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerStatsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Stream the output
     */
    stream?: boolean;
  };
  url: '/libpod/containers/{name}/stats';
};

export type ContainerStatsLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerStatsLibpodError = ContainerStatsLibpodErrors[keyof ContainerStatsLibpodErrors];

export type ContainerStatsLibpodResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type ContainerStopLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * number of seconds to wait before killing container
     */
    timeout?: number;
    /**
     * do not return error if container is already stopped
     */
    Ignore?: boolean;
  };
  url: '/libpod/containers/{name}/stop';
};

export type ContainerStopLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerStopLibpodError = ContainerStopLibpodErrors[keyof ContainerStopLibpodErrors];

export type ContainerStopLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerTopLibpodData = {
  body?: never;
  path: {
    /**
     * Name of container to query for processes (As of version 1.xx)
     */
    name: string;
  };
  query?: {
    /**
     * when true, repeatedly stream the latest output (As of version 4.0)
     */
    stream?: boolean;
    /**
     * if streaming, delay in seconds between updates. Must be >1. (As of version 4.0)
     */
    delay?: number;
    /**
     * arguments to pass to ps such as aux.
     *
     */
    ps_args?: Array<string>;
  };
  url: '/libpod/containers/{name}/top';
};

export type ContainerTopLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerTopLibpodError = ContainerTopLibpodErrors[keyof ContainerTopLibpodErrors];

export type ContainerTopLibpodResponses = {
  /**
   * List processes in container
   */
  200: ContainerTopOkBody;
};

export type ContainerTopLibpodResponse = ContainerTopLibpodResponses[keyof ContainerTopLibpodResponses];

export type ContainerUnmountLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/unmount';
};

export type ContainerUnmountLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerUnmountLibpodError = ContainerUnmountLibpodErrors[keyof ContainerUnmountLibpodErrors];

export type ContainerUnmountLibpodResponses = {
  /**
   * ok
   */
  204: unknown;
};

export type ContainerUnpauseLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/containers/{name}/unpause';
};

export type ContainerUnpauseLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerUnpauseLibpodError = ContainerUnpauseLibpodErrors[keyof ContainerUnpauseLibpodErrors];

export type ContainerUnpauseLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type ContainerUpdateLibpodData = {
  /**
   * attributes for updating the container
   */
  body?: UpdateEntities;
  path: {
    /**
     * Full or partial ID or full name of the container to update
     */
    name: string;
  };
  query?: {
    /**
     * New restart policy for the container.
     */
    restartPolicy?: string;
    /**
     * New amount of retries for the container's restart policy. Only allowed if restartPolicy is set to on-failure
     */
    restartRetries?: number;
  };
  url: '/libpod/containers/{name}/update';
};

export type ContainerUpdateLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerUpdateLibpodError = ContainerUpdateLibpodErrors[keyof ContainerUpdateLibpodErrors];

export type ContainerUpdateLibpodResponses = {
  /**
   * Update container
   */
  201: {
    ID?: string;
  };
};

export type ContainerUpdateLibpodResponse = ContainerUpdateLibpodResponses[keyof ContainerUpdateLibpodResponses];

export type ContainerWaitLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * Conditions to wait for. If no condition provided the 'exited' condition is assumed.
     */
    condition?: Array<
      | 'configured'
      | 'created'
      | 'exited'
      | 'healthy'
      | 'initialized'
      | 'paused'
      | 'removing'
      | 'running'
      | 'stopped'
      | 'stopping'
      | 'unhealthy'
    >;
    /**
     * Time Interval to wait before polling for completion.
     */
    interval?: string;
  };
  url: '/libpod/containers/{name}/wait';
};

export type ContainerWaitLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerWaitLibpodError = ContainerWaitLibpodErrors[keyof ContainerWaitLibpodErrors];

export type ContainerWaitLibpodResponses = {
  /**
   * Status code
   */
  200: number;
};

export type ContainerWaitLibpodResponse = ContainerWaitLibpodResponses[keyof ContainerWaitLibpodResponses];

export type ContainerCreateLibpodData = {
  /**
   * attributes for creating a container
   */
  body: SpecGenerator;
  path?: never;
  query?: never;
  url: '/libpod/containers/create';
};

export type ContainerCreateLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerCreateLibpodError = ContainerCreateLibpodErrors[keyof ContainerCreateLibpodErrors];

export type ContainerCreateLibpodResponses = {
  /**
   * Create container
   */
  201: ContainerCreateResponse;
};

export type ContainerCreateLibpodResponse = ContainerCreateLibpodResponses[keyof ContainerCreateLibpodResponses];

export type ContainerListLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Return all containers. By default, only running containers are shown
     */
    all?: boolean;
    /**
     * Return this number of most recently created containers, including non-running ones.
     */
    limit?: number;
    /**
     * Include namespace information
     */
    namespace?: boolean;
    /**
     * Ignored. Previously included details on pod name and ID that are currently included by default.
     */
    pod?: boolean;
    /**
     * Return the size of container as fields SizeRw and SizeRootFs.
     */
    size?: boolean;
    /**
     * Sync container state with OCI runtime
     */
    sync?: boolean;
    /**
     * A JSON encoded value of the filters (a `map[string][]string`) to process on the containers list. Available filters:
     * - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`)
     * - `before`=(`<container id>` or `<container name>`)
     * - `expose`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`)
     * - `exited=<int>` containers with exit code of `<int>`
     * - `health`=(`starting`, `healthy`, `unhealthy` or `none`)
     * - `id=<ID>` a container's ID
     * - `is-task`=(`true` or `false`)
     * - `label`=(`key` or `"key=value"`) of a container label
     * - `name=<name>` a container's name
     * - `network`=(`<network id>` or `<network name>`)
     * - `pod`=(`<pod id>` or `<pod name>`)
     * - `publish`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`)
     * - `since`=(`<container id>` or `<container name>`)
     * - `status`=(`created`, `restarting`, `running`, `removing`, `paused`, `exited` or `dead`)
     * - `volume`=(`<volume name>` or `<mount point destination>`)
     *
     */
    filters?: string;
  };
  url: '/libpod/containers/json';
};

export type ContainerListLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerListLibpodError = ContainerListLibpodErrors[keyof ContainerListLibpodErrors];

export type ContainerListLibpodResponses = {
  /**
   * List Containers
   */
  200: Array<ListContainer>;
};

export type ContainerListLibpodResponse = ContainerListLibpodResponses[keyof ContainerListLibpodResponses];

export type ContainerPruneLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:
     * - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/libpod/containers/prune';
};

export type ContainerPruneLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerPruneLibpodError = ContainerPruneLibpodErrors[keyof ContainerPruneLibpodErrors];

export type ContainerPruneLibpodResponses = {
  /**
   * Prune Containers
   */
  200: Array<ContainersPruneReportLibpod>;
};

export type ContainerPruneLibpodResponse = ContainerPruneLibpodResponses[keyof ContainerPruneLibpodResponses];

export type ContainerShowMountedLibpodData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/containers/showmounted';
};

export type ContainerShowMountedLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainerShowMountedLibpodError = ContainerShowMountedLibpodErrors[keyof ContainerShowMountedLibpodErrors];

export type ContainerShowMountedLibpodResponses = {
  /**
   * mounted containers
   */
  200: {
    [key: string]: string;
  };
};

export type ContainerShowMountedLibpodResponse =
  ContainerShowMountedLibpodResponses[keyof ContainerShowMountedLibpodResponses];

export type ContainersStatsAllLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * names or IDs of containers
     */
    containers?: Array<string>;
    /**
     * Stream the output
     */
    stream?: boolean;
    /**
     * Time in seconds between stats reports
     */
    interval?: number;
  };
  url: '/libpod/containers/stats';
};

export type ContainersStatsAllLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ContainersStatsAllLibpodError = ContainersStatsAllLibpodErrors[keyof ContainersStatsAllLibpodErrors];

export type ContainersStatsAllLibpodResponses = {
  /**
   * Get stats for one or more containers
   */
  200: ContainerStats;
};

export type ContainersStatsAllLibpodResponse =
  ContainersStatsAllLibpodResponses[keyof ContainersStatsAllLibpodResponses];

export type SystemEventsLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * start streaming events from this time
     */
    since?: string;
    /**
     * stop streaming events later than this
     */
    until?: string;
    /**
     * JSON encoded map[string][]string of constraints
     */
    filters?: string;
    /**
     * when false, do not follow events
     */
    stream?: boolean;
  };
  url: '/libpod/events';
};

export type SystemEventsLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemEventsLibpodError = SystemEventsLibpodErrors[keyof SystemEventsLibpodErrors];

export type SystemEventsLibpodResponses = {
  /**
   * returns a string of json data describing an event
   */
  200: unknown;
};

export type ExecInspectLibpodData = {
  body?: never;
  path: {
    /**
     * Exec instance ID
     */
    id: string;
  };
  query?: never;
  url: '/libpod/exec/{id}/json';
};

export type ExecInspectLibpodErrors = {
  /**
   * No such exec instance
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ExecInspectLibpodError = ExecInspectLibpodErrors[keyof ExecInspectLibpodErrors];

export type ExecInspectLibpodResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type ExecResizeLibpodData = {
  body?: never;
  path: {
    /**
     * Exec instance ID
     */
    id: string;
  };
  query?: {
    /**
     * Height of the TTY session in characters
     */
    h?: number;
    /**
     * Width of the TTY session in characters
     */
    w?: number;
  };
  url: '/libpod/exec/{id}/resize';
};

export type ExecResizeLibpodErrors = {
  /**
   * No such exec instance
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ExecResizeLibpodError = ExecResizeLibpodErrors[keyof ExecResizeLibpodErrors];

export type ExecResizeLibpodResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ExecStartLibpodData = {
  /**
   * Attributes for start
   */
  body?: {
    /**
     * Detach from the command.
     */
    Detach?: boolean;
    /**
     * Allocate a pseudo-TTY.
     */
    Tty?: boolean;
    /**
     * Height of the TTY session in characters. Tty must be set to true to use it.
     */
    h?: number;
    /**
     * Width of the TTY session in characters. Tty must be set to true to use it.
     */
    w?: number;
  };
  path: {
    /**
     * Exec instance ID
     */
    id: string;
  };
  query?: never;
  url: '/libpod/exec/{id}/start';
};

export type ExecStartLibpodErrors = {
  /**
   * No such exec instance
   */
  404: ErrorModel;
  /**
   * container is not running.
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ExecStartLibpodError = ExecStartLibpodErrors[keyof ExecStartLibpodErrors];

export type ExecStartLibpodResponses = {
  /**
   * no error
   */
  200: unknown;
};

export type GenerateSystemdLibpodData = {
  body?: never;
  path: {
    /**
     * Name or ID of the container or pod.
     */
    name: string;
  };
  query?: {
    /**
     * Use container/pod names instead of IDs.
     */
    useName?: boolean;
    /**
     * Create a new container instead of starting an existing one.
     */
    new?: boolean;
    /**
     * Do not generate the header including the Podman version and the timestamp.
     */
    noHeader?: boolean;
    /**
     * Start timeout in seconds.
     */
    startTimeout?: number;
    /**
     * Stop timeout in seconds.
     */
    stopTimeout?: number;
    /**
     * Systemd restart-policy.
     */
    restartPolicy?: 'no' | 'on-success' | 'on-failure' | 'on-abnormal' | 'on-watchdog' | 'on-abort' | 'always';
    /**
     * Systemd unit name prefix for containers.
     */
    containerPrefix?: string;
    /**
     * Systemd unit name prefix for pods.
     */
    podPrefix?: string;
    /**
     * Systemd unit name separator between name/id and prefix.
     */
    separator?: string;
    /**
     * Configures the time to sleep before restarting a service.
     */
    restartSec?: number;
    /**
     * Systemd Wants list for the container or pods.
     */
    wants?: Array<string>;
    /**
     * Systemd After list for the container or pods.
     */
    after?: Array<string>;
    /**
     * Systemd Requires list for the container or pods.
     */
    requires?: Array<string>;
    /**
     * Set environment variables to the systemd unit files.
     */
    additionalEnvVariables?: Array<string>;
  };
  url: '/libpod/generate/{name}/systemd';
};

export type GenerateSystemdLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type GenerateSystemdLibpodError = GenerateSystemdLibpodErrors[keyof GenerateSystemdLibpodErrors];

export type GenerateSystemdLibpodResponses = {
  /**
   * no error
   */
  200: {
    [key: string]: string;
  };
};

export type GenerateSystemdLibpodResponse = GenerateSystemdLibpodResponses[keyof GenerateSystemdLibpodResponses];

export type GenerateKubeLibpodData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Name or ID of the container or pod.
     */
    names: Array<string>;
    /**
     * Generate YAML for a Kubernetes service object.
     */
    service?: boolean;
    /**
     * Generate YAML for the given Kubernetes kind.
     */
    type?: string;
    /**
     * Set the replica number for Deployment kind.
     */
    replicas?: number;
    /**
     * don't truncate annotations to the Kubernetes maximum length of 63 characters
     */
    noTrunc?: boolean;
    /**
     * add podman-only reserved annotations in generated YAML file (cannot be used by Kubernetes)
     */
    podmanOnly?: boolean;
  };
  url: '/libpod/generate/kube';
};

export type GenerateKubeLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type GenerateKubeLibpodError = GenerateKubeLibpodErrors[keyof GenerateKubeLibpodErrors];

export type GenerateKubeLibpodResponses = {
  /**
   * Kubernetes YAML file describing pod
   */
  200: Blob | File;
};

export type GenerateKubeLibpodResponse = GenerateKubeLibpodResponses[keyof GenerateKubeLibpodResponses];

export type ImageDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * name or ID of image to remove
     */
    name: string;
  };
  query?: {
    /**
     * remove the image even if used by containers or has other tags
     */
    force?: boolean;
  };
  url: '/libpod/images/{name}';
};

export type ImageDeleteLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageDeleteLibpodError = ImageDeleteLibpodErrors[keyof ImageDeleteLibpodErrors];

export type ImageDeleteLibpodResponses = {
  /**
   * Image Remove
   */
  200: LibpodImagesRemoveReport;
};

export type ImageDeleteLibpodResponse = ImageDeleteLibpodResponses[keyof ImageDeleteLibpodResponses];

export type ImageChangesLibpodData = {
  body?: never;
  path: {
    /**
     * the name or id of the image
     */
    name: string;
  };
  query?: {
    /**
     * specify a second layer which is used to compare against it instead of the parent layer
     */
    parent?: string;
    /**
     * select what you want to match, default is all
     */
    diffType?: 'all' | 'container' | 'image';
  };
  url: '/libpod/images/{name}/changes';
};

export type ImageChangesLibpodErrors = {
  /**
   * No such container
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageChangesLibpodError = ImageChangesLibpodErrors[keyof ImageChangesLibpodErrors];

export type ImageChangesLibpodResponses = {
  /**
   * Array of Changes
   */
  200: unknown;
};

export type ImageExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/images/{name}/exists';
};

export type ImageExistsLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageExistsLibpodError = ImageExistsLibpodErrors[keyof ImageExistsLibpodErrors];

export type ImageExistsLibpodResponses = {
  /**
   * image exists
   */
  204: unknown;
};

export type ImageGetLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * format for exported image
     */
    format?: string;
    /**
     * use compression on image
     */
    compress?: boolean;
  };
  url: '/libpod/images/{name}/get';
};

export type ImageGetLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageGetLibpodError = ImageGetLibpodErrors[keyof ImageGetLibpodErrors];

export type ImageGetLibpodResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImageGetLibpodResponse = ImageGetLibpodResponses[keyof ImageGetLibpodResponses];

export type ImageHistoryLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/images/{name}/history';
};

export type ImageHistoryLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageHistoryLibpodError = ImageHistoryLibpodErrors[keyof ImageHistoryLibpodErrors];

export type ImageHistoryLibpodResponses = {
  /**
   * Image History
   */
  200: HistoryResponse;
};

export type ImageHistoryLibpodResponse = ImageHistoryLibpodResponses[keyof ImageHistoryLibpodResponses];

export type ImageInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: never;
  url: '/libpod/images/{name}/json';
};

export type ImageInspectLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageInspectLibpodError = ImageInspectLibpodErrors[keyof ImageInspectLibpodErrors];

export type ImageInspectLibpodResponses = {
  /**
   * Inspect Image
   */
  200: ImageData;
};

export type ImageInspectLibpodResponse = ImageInspectLibpodResponses[keyof ImageInspectLibpodResponses];

export type ImagePushLibpodData = {
  body?: never;
  headers?: {
    /**
     * A base64-encoded auth configuration.
     */
    'X-Registry-Auth'?: string;
  };
  path: {
    /**
     * Name of image to push.
     */
    name: string;
  };
  query?: {
    /**
     * Allows for pushing the image to a different destination than the image refers to.
     */
    destination?: string;
    /**
     * Enforce compressing the layers with the specified --compression and do not reuse differently compressed blobs on the registry.
     */
    forceCompressionFormat?: boolean;
    /**
     * Compression format used to compress image layers.
     */
    compressionFormat?: string;
    /**
     * Compression level used to compress image layers.
     */
    compressionLevel?: number;
    /**
     * Require TLS verification.
     */
    tlsVerify?: boolean;
    /**
     * Silences extra stream data on push.
     */
    quiet?: boolean;
    /**
     * Manifest type (oci, v2s1, or v2s2) to use when pushing an image. Default is manifest type of source, with fallbacks.
     */
    format?: string;
    /**
     * All indicates whether to push all images related to the image list.
     */
    all?: boolean;
    /**
     * Discard any pre-existing signatures in the image.
     */
    removeSignatures?: boolean;
    /**
     * Number of times to retry push in case of failure.
     */
    retry?: number;
    /**
     * Delay between retries in case of push failures. Duration format such as "412ms", or "3.5h".
     */
    retryDelay?: string;
  };
  url: '/libpod/images/{name}/push';
};

export type ImagePushLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImagePushLibpodError = ImagePushLibpodErrors[keyof ImagePushLibpodErrors];

export type ImagePushLibpodResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImagePushLibpodResponse = ImagePushLibpodResponses[keyof ImagePushLibpodResponses];

export type ImageResolveLibpodData = {
  body?: never;
  path: {
    /**
     * the (short) name to resolve
     */
    name: string;
  };
  query?: never;
  url: '/libpod/images/{name}/resolve';
};

export type ImageResolveLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageResolveLibpodError = ImageResolveLibpodErrors[keyof ImageResolveLibpodErrors];

export type ImageResolveLibpodResponses = {
  /**
   * resolved image names
   */
  204: unknown;
};

export type ImageTagLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * the repository to tag in
     */
    repo?: string;
    /**
     * the name of the new tag
     */
    tag?: string;
  };
  url: '/libpod/images/{name}/tag';
};

export type ImageTagLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageTagLibpodError = ImageTagLibpodErrors[keyof ImageTagLibpodErrors];

export type ImageTagLibpodResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ImageTreeLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * show all child images and layers of the specified image
     */
    whatrequires?: boolean;
  };
  url: '/libpod/images/{name}/tree';
};

export type ImageTreeLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageTreeLibpodError = ImageTreeLibpodErrors[keyof ImageTreeLibpodErrors];

export type ImageTreeLibpodResponses = {
  /**
   * Image Tree
   */
  200: ImageTreeReport;
};

export type ImageTreeLibpodResponse = ImageTreeLibpodResponses[keyof ImageTreeLibpodResponses];

export type ImageUntagLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the container
     */
    name: string;
  };
  query?: {
    /**
     * the repository to untag
     */
    repo?: string;
    /**
     * the name of the tag to untag
     */
    tag?: string;
  };
  url: '/libpod/images/{name}/untag';
};

export type ImageUntagLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageUntagLibpodError = ImageUntagLibpodErrors[keyof ImageUntagLibpodErrors];

export type ImageUntagLibpodResponses = {
  /**
   * no error
   */
  201: unknown;
};

export type ImageExportLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * format for exported image (only docker-archive is supported)
     */
    format?: string;
    /**
     * references to images to export
     */
    references?: Array<string>;
    /**
     * use compression on image
     */
    compress?: boolean;
    /**
     * accept uncompressed layers when copying OCI images
     */
    ociAcceptUncompressedLayers?: boolean;
  };
  url: '/libpod/images/export';
};

export type ImageExportLibpodErrors = {
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageExportLibpodError = ImageExportLibpodErrors[keyof ImageExportLibpodErrors];

export type ImageExportLibpodResponses = {
  /**
   * no error
   */
  200: Blob | File;
};

export type ImageExportLibpodResponse = ImageExportLibpodResponses[keyof ImageExportLibpodResponses];

export type ImageImportLibpodData = {
  /**
   * tarball for imported image
   */
  body: Blob | File;
  headers?: {
    'Content-Type'?: 'application/x-tar';
  };
  path?: never;
  query?: {
    /**
     * Apply the following possible instructions to the created image: CMD | ENTRYPOINT | ENV | EXPOSE | LABEL | STOPSIGNAL | USER | VOLUME | WORKDIR.  JSON encoded string
     */
    changes?: Array<string>;
    /**
     * Set commit message for imported image
     */
    message?: string;
    /**
     * Optional Name[:TAG] for the image
     */
    reference?: string;
    /**
     * Load image from the specified URL
     */
    url?: string;
  };
  url: '/libpod/images/import';
};

export type ImageImportLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageImportLibpodError = ImageImportLibpodErrors[keyof ImageImportLibpodErrors];

export type ImageImportLibpodResponses = {
  /**
   * Image Import
   */
  200: ImageImportReport;
};

export type ImageImportLibpodResponse = ImageImportLibpodResponses[keyof ImageImportLibpodResponses];

export type ImageListLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Show all images. Only images from a final layer (no children) are shown by default.
     */
    all?: boolean;
    /**
     * A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
     * - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
     * - `dangling=true`
     * - `label=key` or `label="key=value"` of an image label
     * - `reference`=(`<image-name>[:<tag>]`)
     * - `id`=(`<image-id>`)
     * - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
     *
     */
    filters?: string;
  };
  url: '/libpod/images/json';
};

export type ImageListLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageListLibpodError = ImageListLibpodErrors[keyof ImageListLibpodErrors];

export type ImageListLibpodResponses = {
  /**
   * Image summary for libpod API
   */
  200: Array<LibpodImageSummary>;
};

export type ImageListLibpodResponse = ImageListLibpodResponses[keyof ImageListLibpodResponses];

export type ImageLoadLibpodData = {
  /**
   * tarball of container image
   */
  body: string;
  path?: never;
  query?: never;
  url: '/libpod/images/load';
};

export type ImageLoadLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageLoadLibpodError = ImageLoadLibpodErrors[keyof ImageLoadLibpodErrors];

export type ImageLoadLibpodResponses = {
  /**
   * Image Load
   */
  200: ImageLoadReport;
};

export type ImageLoadLibpodResponse = ImageLoadLibpodResponses[keyof ImageLoadLibpodResponses];

export type ImagePruneLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Remove all images not in use by containers, not just dangling ones
     *
     */
    all?: boolean;
    /**
     * Remove images even when they are used by external containers (e.g, by build containers)
     *
     */
    external?: boolean;
    /**
     * Remove persistent build cache created by build instructions such as `--mount=type=cache`.
     *
     */
    buildcache?: boolean;
    /**
     * filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:
     * - `dangling=<boolean>` When set to `true` (or `1`), prune only
     * unused *and* untagged images. When set to `false`
     * (or `0`), all unused images are pruned.
     * - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/libpod/images/prune';
};

export type ImagePruneLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImagePruneLibpodError = ImagePruneLibpodErrors[keyof ImagePruneLibpodErrors];

export type ImagePruneLibpodResponses = {
  /**
   * Image Prune
   */
  200: Array<PruneReport>;
};

export type ImagePruneLibpodResponse = ImagePruneLibpodResponses[keyof ImagePruneLibpodResponses];

export type ImagePullLibpodData = {
  body?: never;
  headers?: {
    /**
     * base-64 encoded auth config. Must include the following four values: username, password, email and server address OR simply just an identity token.
     */
    'X-Registry-Auth'?: string;
  };
  path?: never;
  query?: {
    /**
     * Mandatory reference to the image (e.g., quay.io/image/name:tag)
     */
    reference?: string;
    /**
     * silences extra stream data on pull
     */
    quiet?: boolean;
    /**
     * Return the same JSON payload as the Docker-compat endpoint.
     */
    compatMode?: boolean;
    /**
     * Pull image for the specified architecture.
     */
    Arch?: string;
    /**
     * Pull image for the specified operating system.
     */
    OS?: string;
    /**
     * Pull image for the specified variant.
     */
    Variant?: string;
    /**
     * Pull policy, "always" (default), "missing", "newer", "never".
     */
    policy?: string;
    /**
     * Require TLS verification.
     */
    tlsVerify?: boolean;
    /**
     * Pull all tagged images in the repository.
     */
    allTags?: boolean;
  };
  url: '/libpod/images/pull';
};

export type ImagePullLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImagePullLibpodError = ImagePullLibpodErrors[keyof ImagePullLibpodErrors];

export type ImagePullLibpodResponses = {
  /**
   * Image Pull
   */
  200: LibpodImagesPullReport;
};

export type ImagePullLibpodResponse = ImagePullLibpodResponses[keyof ImagePullLibpodResponses];

export type ImageDeleteAllLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Images IDs or names to remove.
     */
    images?: Array<string>;
    /**
     * Remove all images.
     */
    all?: boolean;
    /**
     * Force image removal (including containers using the images).
     */
    force?: boolean;
    /**
     * Ignore if a specified image does not exist and do not throw an error.
     */
    ignore?: boolean;
    /**
     * Resolves to manifest list instead of image.
     */
    lookupManifest?: boolean;
  };
  url: '/libpod/images/remove';
};

export type ImageDeleteAllLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageDeleteAllLibpodError = ImageDeleteAllLibpodErrors[keyof ImageDeleteAllLibpodErrors];

export type ImageDeleteAllLibpodResponses = {
  /**
   * Image Remove
   */
  200: LibpodImagesRemoveReport;
};

export type ImageDeleteAllLibpodResponse = ImageDeleteAllLibpodResponses[keyof ImageDeleteAllLibpodResponses];

export type ImageScpLibpodData = {
  body?: never;
  path: {
    /**
     * source connection/image
     */
    name: string;
  };
  query?: {
    /**
     * dest connection/image
     */
    destination?: string;
    /**
     * quiet output
     */
    quiet?: boolean;
  };
  url: '/libpod/images/scp/{name}';
};

export type ImageScpLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageScpLibpodError = ImageScpLibpodErrors[keyof ImageScpLibpodErrors];

export type ImageScpLibpodResponses = {
  /**
   * Image Scp
   */
  200: ScpReport;
};

export type ImageScpLibpodResponse = ImageScpLibpodResponses[keyof ImageScpLibpodResponses];

export type ImageSearchLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * term to search
     */
    term?: string;
    /**
     * maximum number of results
     */
    limit?: number;
    /**
     * A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
     * - `is-automated=(true|false)`
     * - `is-official=(true|false)`
     * - `stars=<number>` Matches images that have at least 'number' stars.
     *
     */
    filters?: string;
    /**
     * Require HTTPS and verify signatures when contacting registries.
     */
    tlsVerify?: boolean;
    /**
     * list the available tags in the repository
     */
    listTags?: boolean;
  };
  url: '/libpod/images/search';
};

export type ImageSearchLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ImageSearchLibpodError = ImageSearchLibpodErrors[keyof ImageSearchLibpodErrors];

export type ImageSearchLibpodResponses = {
  /**
   * Registry Search
   */
  200: {
    /**
     * Automated indicates if the image was created by an automated build.
     */
    Automated?: string;
    /**
     * Description of the image.
     */
    Description?: string;
    /**
     * Index is the image index
     */
    Index?: string;
    /**
     * Name is the canonical name of the image
     */
    Name?: string;
    /**
     * Official indicates if it's an official image.
     */
    Official?: string;
    /**
     * Stars is the number of stars of the image.
     */
    Stars?: number;
    /**
     * Tag is the image tag
     */
    Tag?: string;
  };
};

export type ImageSearchLibpodResponse = ImageSearchLibpodResponses[keyof ImageSearchLibpodResponses];

export type SystemInfoLibpodData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/info';
};

export type SystemInfoLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemInfoLibpodError = SystemInfoLibpodErrors[keyof SystemInfoLibpodErrors];

export type SystemInfoLibpodResponses = {
  /**
   * Info
   */
  200: LibpodInfo;
};

export type SystemInfoLibpodResponse = SystemInfoLibpodResponses[keyof SystemInfoLibpodResponses];

export type KubeApplyLibpodData = {
  /**
   * Kubernetes YAML file.
   */
  body?: string;
  path?: never;
  query?: {
    /**
     * Path to the CA cert file for the Kubernetes cluster.
     */
    caCertFile?: string;
    /**
     * Path to the kubeconfig file for the Kubernetes cluster.
     */
    kubeConfig?: string;
    /**
     * The namespace to deploy the workload to on the Kubernetes cluster.
     */
    namespace?: string;
    /**
     * Create a service object for the container being deployed.
     */
    service?: boolean;
    /**
     * Path to the Kubernetes yaml file to deploy.
     */
    file?: string;
  };
  url: '/libpod/kube/apply';
};

export type KubeApplyLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type KubeApplyLibpodError = KubeApplyLibpodErrors[keyof KubeApplyLibpodErrors];

export type KubeApplyLibpodResponses = {
  /**
   * Kubernetes YAML file successfully deployed to cluster
   */
  200: Blob | File;
};

export type KubeApplyLibpodResponse = KubeApplyLibpodResponses[keyof KubeApplyLibpodResponses];

export type ManifestDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * The name or ID of the  list to be deleted
     */
    name: string;
  };
  query?: {
    /**
     * Ignore if a specified manifest does not exist and do not throw an error.
     */
    ignore?: boolean;
  };
  url: '/libpod/manifests/{name}';
};

export type ManifestDeleteLibpodErrors = {
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestDeleteLibpodError = ManifestDeleteLibpodErrors[keyof ManifestDeleteLibpodErrors];

export type ManifestDeleteLibpodResponses = {
  /**
   * Image Remove
   */
  200: LibpodImagesRemoveReport;
};

export type ManifestDeleteLibpodResponse = ManifestDeleteLibpodResponses[keyof ManifestDeleteLibpodResponses];

export type ManifestCreateLibpodData = {
  /**
   * options for new manifest
   */
  body?: ManifestModifyOptions;
  path: {
    /**
     * manifest list or index name to create
     */
    name: string;
  };
  query: {
    /**
     * One or more names of an image or a manifest list. Repeat parameter as needed.
     *
     * Support for multiple images, as of version 4.0.0
     * Alias of `image` is support for compatibility with < 4.0.0
     * Response status code is 200 with < 4.0.0 for compatibility
     *
     */
    images: string;
    /**
     * add all contents if given list
     */
    all?: boolean;
    /**
     * modify an existing list if one with the desired name already exists
     */
    amend?: boolean;
  };
  url: '/libpod/manifests/{name}';
};

export type ManifestCreateLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such image
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestCreateLibpodError = ManifestCreateLibpodErrors[keyof ManifestCreateLibpodErrors];

export type ManifestCreateLibpodResponses = {
  201: IdResponse;
};

export type ManifestCreateLibpodResponse = ManifestCreateLibpodResponses[keyof ManifestCreateLibpodResponses];

export type ManifestModifyLibpodData = {
  /**
   * options for mutating a manifest
   */
  body: ManifestModifyOptions;
  path: {
    /**
     * the name or ID of the manifest
     */
    name: string;
  };
  query?: {
    /**
     * Require HTTPS and verify signatures when contacting registries.
     */
    tlsVerify?: boolean;
  };
  url: '/libpod/manifests/{name}';
};

export type ManifestModifyLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Operation had partial success, both Images and Errors may have members
   */
  409: ManifestModifyReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestModifyLibpodError = ManifestModifyLibpodErrors[keyof ManifestModifyLibpodErrors];

export type ManifestModifyLibpodResponses = {
  200: ManifestModifyReport;
};

export type ManifestModifyLibpodResponse = ManifestModifyLibpodResponses[keyof ManifestModifyLibpodResponses];

export type ManifestAddLibpodData = {
  /**
   * options for creating a manifest
   */
  body?: ManifestAddOptions;
  path: {
    /**
     * the name or ID of the manifest
     */
    name: string;
  };
  query?: never;
  url: '/libpod/manifests/{name}/add';
};

export type ManifestAddLibpodErrors = {
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Bad parameter in request
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestAddLibpodError = ManifestAddLibpodErrors[keyof ManifestAddLibpodErrors];

export type ManifestAddLibpodResponses = {
  200: IdResponse;
};

export type ManifestAddLibpodResponse = ManifestAddLibpodResponses[keyof ManifestAddLibpodResponses];

export type ManifestExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the manifest list
     */
    name: string;
  };
  query?: never;
  url: '/libpod/manifests/{name}/exists';
};

export type ManifestExistsLibpodErrors = {
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestExistsLibpodError = ManifestExistsLibpodErrors[keyof ManifestExistsLibpodErrors];

export type ManifestExistsLibpodResponses = {
  /**
   * manifest list exists
   */
  204: unknown;
};

export type ManifestInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the manifest list
     */
    name: string;
  };
  query?: {
    /**
     * Require HTTPS and verify signatures when contacting registries.
     */
    tlsVerify?: boolean;
  };
  url: '/libpod/manifests/{name}/json';
};

export type ManifestInspectLibpodErrors = {
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestInspectLibpodError = ManifestInspectLibpodErrors[keyof ManifestInspectLibpodErrors];

export type ManifestInspectLibpodResponses = {
  /**
   * Inspect Manifest
   */
  200: Schema2ListPublic;
};

export type ManifestInspectLibpodResponse = ManifestInspectLibpodResponses[keyof ManifestInspectLibpodResponses];

export type ManifestPushV3LibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the manifest
     */
    name: string;
  };
  query: {
    /**
     * the destination for the manifest
     */
    destination: string;
    /**
     * push all images
     */
    all?: boolean;
  };
  url: '/libpod/manifests/{name}/push';
};

export type ManifestPushV3LibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestPushV3LibpodError = ManifestPushV3LibpodErrors[keyof ManifestPushV3LibpodErrors];

export type ManifestPushV3LibpodResponses = {
  200: IdResponse;
};

export type ManifestPushV3LibpodResponse = ManifestPushV3LibpodResponses[keyof ManifestPushV3LibpodResponses];

export type ManifestPushLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the manifest list
     */
    name: string;
    /**
     * the registry for the manifest list
     */
    destination: string;
  };
  query?: {
    /**
     * add existing instances with requested compression algorithms to manifest list
     */
    addCompression?: Array<string>;
    /**
     * Enforce compressing the layers with the specified --compression and do not reuse differently compressed blobs on the registry.
     */
    forceCompressionFormat?: boolean;
    /**
     * push all images
     */
    all?: boolean;
    /**
     * Require HTTPS and verify signatures when contacting registries.
     */
    tlsVerify?: boolean;
    /**
     * silences extra stream data on push
     */
    quiet?: boolean;
  };
  url: '/libpod/manifests/{name}/registry/{destination}';
};

export type ManifestPushLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such manifest
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type ManifestPushLibpodError = ManifestPushLibpodErrors[keyof ManifestPushLibpodErrors];

export type ManifestPushLibpodResponses = {
  200: IdResponse;
};

export type ManifestPushLibpodResponse = ManifestPushLibpodResponses[keyof ManifestPushLibpodResponses];

export type NetworkDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: {
    /**
     * remove containers associated with network
     */
    force?: boolean;
  };
  url: '/libpod/networks/{name}';
};

export type NetworkDeleteLibpodErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkDeleteLibpodError = NetworkDeleteLibpodErrors[keyof NetworkDeleteLibpodErrors];

export type NetworkDeleteLibpodResponses = {
  /**
   * Network Delete
   */
  200: Array<NetworkRmReport>;
};

export type NetworkDeleteLibpodResponse = NetworkDeleteLibpodResponses[keyof NetworkDeleteLibpodResponses];

export type NetworkConnectLibpodData = {
  /**
   * attributes for connecting a container to a network
   */
  body?: NetworkConnectRequestLibpod;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: never;
  url: '/libpod/networks/{name}/connect';
};

export type NetworkConnectLibpodErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkConnectLibpodError = NetworkConnectLibpodErrors[keyof NetworkConnectLibpodErrors];

export type NetworkConnectLibpodResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type NetworkDisconnectLibpodData = {
  /**
   * attributes for disconnecting a container from a network
   */
  body?: NetworkDisconnectRequest;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: never;
  url: '/libpod/networks/{name}/disconnect';
};

export type NetworkDisconnectLibpodErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkDisconnectLibpodError = NetworkDisconnectLibpodErrors[keyof NetworkDisconnectLibpodErrors];

export type NetworkDisconnectLibpodResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type NetworkExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the network
     */
    name: string;
  };
  query?: never;
  url: '/libpod/networks/{name}/exists';
};

export type NetworkExistsLibpodErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkExistsLibpodError = NetworkExistsLibpodErrors[keyof NetworkExistsLibpodErrors];

export type NetworkExistsLibpodResponses = {
  /**
   * network exists
   */
  204: unknown;
};

export type NetworkInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: never;
  url: '/libpod/networks/{name}/json';
};

export type NetworkInspectLibpodErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkInspectLibpodError = NetworkInspectLibpodErrors[keyof NetworkInspectLibpodErrors];

export type NetworkInspectLibpodResponses = {
  /**
   * Network inspect
   */
  200: NetworkInspectReport;
};

export type NetworkInspectLibpodResponse = NetworkInspectLibpodResponses[keyof NetworkInspectLibpodResponses];

export type NetworkUpdateLibpodData = {
  /**
   * attributes for updating a netavark network
   */
  body?: NetworkUpdateRequestLibpod;
  path: {
    /**
     * the name or ID of the network
     */
    name: string;
  };
  query?: never;
  url: '/libpod/networks/{name}/update';
};

export type NetworkUpdateLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkUpdateLibpodError = NetworkUpdateLibpodErrors[keyof NetworkUpdateLibpodErrors];

export type NetworkUpdateLibpodResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type NetworkCreateLibpodData = {
  /**
   * attributes for creating a network
   */
  body?: NetworkCreateLibpod;
  path?: never;
  query?: never;
  url: '/libpod/networks/create';
};

export type NetworkCreateLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Conflict error in operation
   */
  409: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkCreateLibpodError = NetworkCreateLibpodErrors[keyof NetworkCreateLibpodErrors];

export type NetworkCreateLibpodResponses = {
  /**
   * Network create
   */
  200: Network;
};

export type NetworkCreateLibpodResponse = NetworkCreateLibpodResponses[keyof NetworkCreateLibpodResponses];

export type NetworkListLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a `map[string][]string`) to process on the network list. Available filters:
     * - `name=[name]` Matches network name (accepts regex).
     * - `id=[id]` Matches for full or partial ID.
     * - `driver=[driver]` Only bridge is supported.
     * - `label=[key]` or `label=[key=value]` Matches networks based on the presence of a label alone or a label and a value.
     * - `until=[timestamp]` Matches all networks that were created before the given timestamp.
     *
     */
    filters?: string;
  };
  url: '/libpod/networks/json';
};

export type NetworkListLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkListLibpodError = NetworkListLibpodErrors[keyof NetworkListLibpodErrors];

export type NetworkListLibpodResponses = {
  /**
   * Network list
   */
  200: Array<Network>;
};

export type NetworkListLibpodResponse = NetworkListLibpodResponses[keyof NetworkListLibpodResponses];

export type NetworkPruneLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filters to process on the prune list, encoded as JSON (a `map[string][]string`).
     * Available filters:
     * - `until=<timestamp>` Prune networks created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/libpod/networks/prune';
};

export type NetworkPruneLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkPruneLibpodError = NetworkPruneLibpodErrors[keyof NetworkPruneLibpodErrors];

export type NetworkPruneLibpodResponses = {
  /**
   * Network prune
   */
  200: Array<NetworkPruneReport>;
};

export type NetworkPruneLibpodResponse = NetworkPruneLibpodResponses[keyof NetworkPruneLibpodResponses];

export type PlayKubeDownLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Remove volumes.
     */
    force?: boolean;
  };
  url: '/libpod/play/kube';
};

export type PlayKubeDownLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PlayKubeDownLibpodError = PlayKubeDownLibpodErrors[keyof PlayKubeDownLibpodErrors];

export type PlayKubeDownLibpodResponses = {
  /**
   * PlayKube response
   */
  200: PlayKubeReport;
};

export type PlayKubeDownLibpodResponse = PlayKubeDownLibpodResponses[keyof PlayKubeDownLibpodResponses];

export type PlayKubeLibpodData = {
  /**
   * Kubernetes YAML file.
   */
  body?: string;
  headers?: {
    'Content-Type'?: 'plain/text' | 'application/x-tar';
  };
  path?: never;
  query?: {
    /**
     * JSON encoded value of annotations (a map[string]string).
     */
    annotations?: string;
    /**
     * Logging driver for the containers in the pod.
     */
    logDriver?: string;
    /**
     * logging driver options
     */
    logOptions?: Array<string>;
    /**
     * USe the network mode or specify an array of networks.
     */
    network?: Array<string>;
    /**
     * do not setup /etc/hosts file in container
     */
    noHosts?: boolean;
    /**
     * use annotations that are not truncated to the Kubernetes maximum length of 63 characters
     */
    noTrunc?: boolean;
    /**
     * publish a container's port, or a range of ports, to the host
     */
    publishPorts?: Array<string>;
    /**
     * Whether to publish all ports defined in the K8S YAML file (containerPort, hostPort), if false only hostPort will be published
     */
    publishAllPorts?: boolean;
    /**
     * replace existing pods and containers
     */
    replace?: boolean;
    /**
     * Starts a service container before all pods.
     */
    serviceContainer?: boolean;
    /**
     * Start the pod after creating it.
     */
    start?: boolean;
    /**
     * Static IPs used for the pods.
     */
    staticIPs?: Array<string>;
    /**
     * Static MACs used for the pods.
     */
    staticMACs?: Array<string>;
    /**
     * Require HTTPS and verify signatures when contacting registries.
     */
    tlsVerify?: boolean;
    /**
     * Set the user namespace mode for the pods.
     */
    userns?: string;
    /**
     * Clean up all objects created when a SIGTERM is received or pods exit.
     */
    wait?: boolean;
    /**
     * Build the images with corresponding context.
     */
    build?: boolean;
  };
  url: '/libpod/play/kube';
};

export type PlayKubeLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PlayKubeLibpodError = PlayKubeLibpodErrors[keyof PlayKubeLibpodErrors];

export type PlayKubeLibpodResponses = {
  /**
   * PlayKube response
   */
  200: PlayKubeReport;
};

export type PlayKubeLibpodResponse = PlayKubeLibpodResponses[keyof PlayKubeLibpodResponses];

export type PodDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: {
    /**
     * force removal of a running pod by first stopping all containers, then removing all containers in the pod
     */
    force?: boolean;
  };
  url: '/libpod/pods/{name}';
};

export type PodDeleteLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodDeleteLibpodError = PodDeleteLibpodErrors[keyof PodDeleteLibpodErrors];

export type PodDeleteLibpodResponses = {
  /**
   * Rm pod
   */
  200: PodRmReport;
};

export type PodDeleteLibpodResponse = PodDeleteLibpodResponses[keyof PodDeleteLibpodResponses];

export type PodExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: never;
  url: '/libpod/pods/{name}/exists';
};

export type PodExistsLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodExistsLibpodError = PodExistsLibpodErrors[keyof PodExistsLibpodErrors];

export type PodExistsLibpodResponses = {
  /**
   * pod exists
   */
  204: unknown;
};

export type PodInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: never;
  url: '/libpod/pods/{name}/json';
};

export type PodInspectLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodInspectLibpodError = PodInspectLibpodErrors[keyof PodInspectLibpodErrors];

export type PodInspectLibpodResponses = {
  /**
   * Inspect pod
   */
  200: InspectPodData;
};

export type PodInspectLibpodResponse = PodInspectLibpodResponses[keyof PodInspectLibpodResponses];

export type PodKillLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: {
    /**
     * signal to be sent to pod
     */
    signal?: string;
  };
  url: '/libpod/pods/{name}/kill';
};

export type PodKillLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Kill Pod
   */
  409: PodKillReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodKillLibpodError = PodKillLibpodErrors[keyof PodKillLibpodErrors];

export type PodKillLibpodResponses = {
  /**
   * Kill Pod
   */
  200: PodKillReport;
};

export type PodKillLibpodResponse = PodKillLibpodResponses[keyof PodKillLibpodResponses];

export type PodPauseLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: never;
  url: '/libpod/pods/{name}/pause';
};

export type PodPauseLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Pause pod
   */
  409: PodPauseReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodPauseLibpodError = PodPauseLibpodErrors[keyof PodPauseLibpodErrors];

export type PodPauseLibpodResponses = {
  /**
   * Pause pod
   */
  200: PodPauseReport;
};

export type PodPauseLibpodResponse = PodPauseLibpodResponses[keyof PodPauseLibpodResponses];

export type PodRestartLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: never;
  url: '/libpod/pods/{name}/restart';
};

export type PodRestartLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Restart pod
   */
  409: PodRestartReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodRestartLibpodError = PodRestartLibpodErrors[keyof PodRestartLibpodErrors];

export type PodRestartLibpodResponses = {
  /**
   * Restart pod
   */
  200: PodRestartReport;
};

export type PodRestartLibpodResponse = PodRestartLibpodResponses[keyof PodRestartLibpodResponses];

export type PodStartLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: never;
  url: '/libpod/pods/{name}/start';
};

export type PodStartLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Start pod
   */
  409: PodStartReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodStartLibpodError = PodStartLibpodErrors[keyof PodStartLibpodErrors];

export type PodStartLibpodResponses = {
  /**
   * Start pod
   */
  200: PodStartReport;
};

export type PodStartLibpodResponse = PodStartLibpodResponses[keyof PodStartLibpodResponses];

export type PodStopLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: {
    /**
     * timeout
     */
    t?: number;
  };
  url: '/libpod/pods/{name}/stop';
};

export type PodStopLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Stop pod
   */
  409: PodStopReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodStopLibpodError = PodStopLibpodErrors[keyof PodStopLibpodErrors];

export type PodStopLibpodResponses = {
  /**
   * Stop pod
   */
  200: PodStopReport;
};

export type PodStopLibpodResponse = PodStopLibpodResponses[keyof PodStopLibpodResponses];

export type PodTopLibpodData = {
  body?: never;
  path: {
    /**
     * Name of pod to query for processes
     */
    name: string;
  };
  query?: {
    /**
     * when true, repeatedly stream the latest output (As of version 4.0)
     */
    stream?: boolean;
    /**
     * if streaming, delay in seconds between updates. Must be >1. (As of version 4.0)
     */
    delay?: number;
    /**
     * arguments to pass to ps such as aux.
     *
     */
    ps_args?: string;
  };
  url: '/libpod/pods/{name}/top';
};

export type PodTopLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodTopLibpodError = PodTopLibpodErrors[keyof PodTopLibpodErrors];

export type PodTopLibpodResponses = {
  /**
   * List processes in pod
   */
  200: PodTopOkBody;
};

export type PodTopLibpodResponse = PodTopLibpodResponses[keyof PodTopLibpodResponses];

export type PodUnpauseLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the pod
     */
    name: string;
  };
  query?: never;
  url: '/libpod/pods/{name}/unpause';
};

export type PodUnpauseLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Unpause pod
   */
  409: PodUnpauseReport;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodUnpauseLibpodError = PodUnpauseLibpodErrors[keyof PodUnpauseLibpodErrors];

export type PodUnpauseLibpodResponses = {
  /**
   * Unpause pod
   */
  200: PodUnpauseReport;
};

export type PodUnpauseLibpodResponse = PodUnpauseLibpodResponses[keyof PodUnpauseLibpodResponses];

export type PodCreateLibpodData = {
  /**
   * attributes for creating a pod
   */
  body?: PodSpecGenerator;
  path?: never;
  query?: never;
  url: '/libpod/pods/create';
};

export type PodCreateLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * message describing error
   */
  409: string;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodCreateLibpodError = PodCreateLibpodErrors[keyof PodCreateLibpodErrors];

export type PodCreateLibpodResponses = {
  201: IdResponse;
};

export type PodCreateLibpodResponse = PodCreateLibpodResponses[keyof PodCreateLibpodResponses];

export type PodListLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a map[string][]string) to process on the pods list. Available filters:
     * - `id=<pod-id>` Matches all of pod id.
     * - `label=<key>` or `label=<key>:<value>` Matches pods based on the presence of a label alone or a label and a value.
     * - `name=<pod-name>` Matches all of pod name.
     * - `until=<timestamp>` List pods created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `status=<pod-status>` Pod's status: `stopped`, `running`, `paused`, `exited`, `dead`, `created`, `degraded`.
     * - `network=<pod-network>` Name or full ID of network.
     * - `ctr-names=<pod-ctr-names>` Container name within the pod.
     * - `ctr-ids=<pod-ctr-ids>` Container ID within the pod.
     * - `ctr-status=<pod-ctr-status>` Container status within the pod.
     * - `ctr-number=<pod-ctr-number>` Number of containers in the pod.
     *
     */
    filters?: string;
  };
  url: '/libpod/pods/json';
};

export type PodListLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodListLibpodError = PodListLibpodErrors[keyof PodListLibpodErrors];

export type PodListLibpodResponses = {
  /**
   * List pods
   */
  200: Array<ListPodsReport>;
};

export type PodListLibpodResponse = PodListLibpodResponses[keyof PodListLibpodResponses];

export type PodPruneLibpodData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/pods/prune';
};

export type PodPruneLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * pod already exists
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodPruneLibpodError = PodPruneLibpodErrors[keyof PodPruneLibpodErrors];

export type PodPruneLibpodResponses = {
  /**
   * Prune pod
   */
  200: PodPruneReport;
};

export type PodPruneLibpodResponse = PodPruneLibpodResponses[keyof PodPruneLibpodResponses];

export type PodStatsAllLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Provide statistics for all running pods.
     */
    all?: boolean;
    /**
     * Names or IDs of pods.
     */
    namesOrIDs?: Array<string>;
  };
  url: '/libpod/pods/stats';
};

export type PodStatsAllLibpodErrors = {
  /**
   * No such pod
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type PodStatsAllLibpodError = PodStatsAllLibpodErrors[keyof PodStatsAllLibpodErrors];

export type PodStatsAllLibpodResponses = {
  /**
   * Pod Statistics
   */
  200: Array<PodStatsReport>;
};

export type PodStatsAllLibpodResponse = PodStatsAllLibpodResponses[keyof PodStatsAllLibpodResponses];

export type SecretDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the secret
     */
    name: string;
  };
  query?: {
    /**
     * Remove all secrets
     */
    all?: boolean;
  };
  url: '/libpod/secrets/{name}';
};

export type SecretDeleteLibpodErrors = {
  /**
   * No such secret
   */
  404: {
    /**
     * API root cause formatted for automated parsing
     */
    cause?: string;
    /**
     * human error message, formatted for a human to read
     */
    message?: string;
    /**
     * HTTP response code
     */
    response?: number;
  };
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretDeleteLibpodError = SecretDeleteLibpodErrors[keyof SecretDeleteLibpodErrors];

export type SecretDeleteLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type SecretExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the secret
     */
    name: string;
  };
  query?: never;
  url: '/libpod/secrets/{name}/exists';
};

export type SecretExistsLibpodErrors = {
  /**
   * No such secret
   */
  404: {
    /**
     * API root cause formatted for automated parsing
     */
    cause?: string;
    /**
     * human error message, formatted for a human to read
     */
    message?: string;
    /**
     * HTTP response code
     */
    response?: number;
  };
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretExistsLibpodError = SecretExistsLibpodErrors[keyof SecretExistsLibpodErrors];

export type SecretExistsLibpodResponses = {
  /**
   * secret exists
   */
  204: unknown;
};

export type SecretInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the secret
     */
    name: string;
  };
  query?: {
    /**
     * Display Secret
     */
    showsecret?: boolean;
  };
  url: '/libpod/secrets/{name}/json';
};

export type SecretInspectLibpodErrors = {
  /**
   * No such secret
   */
  404: {
    /**
     * API root cause formatted for automated parsing
     */
    cause?: string;
    /**
     * human error message, formatted for a human to read
     */
    message?: string;
    /**
     * HTTP response code
     */
    response?: number;
  };
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretInspectLibpodError = SecretInspectLibpodErrors[keyof SecretInspectLibpodErrors];

export type SecretInspectLibpodResponses = {
  /**
   * Secret inspect response
   */
  200: SecretInfoReport;
};

export type SecretInspectLibpodResponse = SecretInspectLibpodResponses[keyof SecretInspectLibpodResponses];

export type SecretCreateLibpodData = {
  /**
   * Secret
   */
  body?: string;
  path?: never;
  query: {
    /**
     * User-defined name of the secret.
     */
    name: string;
    /**
     * Secret driver
     */
    driver?: string;
    /**
     * Secret driver options
     */
    driveropts?: string;
    /**
     * Labels on the secret
     */
    labels?: string;
  };
  url: '/libpod/secrets/create';
};

export type SecretCreateLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretCreateLibpodError = SecretCreateLibpodErrors[keyof SecretCreateLibpodErrors];

export type SecretCreateLibpodResponses = {
  /**
   * Secret create response
   */
  201: {
    ID?: string;
  };
};

export type SecretCreateLibpodResponse = SecretCreateLibpodResponses[keyof SecretCreateLibpodResponses];

export type SecretListLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a `map[string][]string`) to process on the secrets list. Currently available filters:
     * - `name=[name]` Matches secrets name (accepts regex).
     * - `id=[id]` Matches for full or partial ID.
     *
     */
    filters?: string;
  };
  url: '/libpod/secrets/json';
};

export type SecretListLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretListLibpodError = SecretListLibpodErrors[keyof SecretListLibpodErrors];

export type SecretListLibpodResponses = {
  /**
   * Secret list response
   */
  200: Array<SecretInfoReport>;
};

export type SecretListLibpodResponse = SecretListLibpodResponses[keyof SecretListLibpodResponses];

export type SystemCheckLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Skip time-consuming checks
     */
    quick?: boolean;
    /**
     * Remove inconsistent images
     */
    repair?: boolean;
    /**
     * Remove inconsistent containers and images
     */
    repair_lossy?: boolean;
    /**
     * Maximum allowed age of unreferenced layers
     */
    unreferenced_layer_max_age?: string;
  };
  url: '/libpod/system/check';
};

export type SystemCheckLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemCheckLibpodError = SystemCheckLibpodErrors[keyof SystemCheckLibpodErrors];

export type SystemCheckLibpodResponses = {
  /**
   * Check
   */
  200: SystemCheckReport;
};

export type SystemCheckLibpodResponse = SystemCheckLibpodResponses[keyof SystemCheckLibpodResponses];

export type SystemDataUsageLibpodData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/system/df';
};

export type SystemDataUsageLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemDataUsageLibpodError = SystemDataUsageLibpodErrors[keyof SystemDataUsageLibpodErrors];

export type SystemDataUsageLibpodResponses = {
  /**
   * Disk usage
   */
  200: SystemDfReport;
};

export type SystemDataUsageLibpodResponse = SystemDataUsageLibpodResponses[keyof SystemDataUsageLibpodResponses];

export type SystemPruneLibpodData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/system/prune';
};

export type SystemPruneLibpodErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemPruneLibpodError = SystemPruneLibpodErrors[keyof SystemPruneLibpodErrors];

export type SystemPruneLibpodResponses = {
  /**
   * System Prune results
   */
  200: SystemPruneReport;
};

export type SystemPruneLibpodResponse = SystemPruneLibpodResponses[keyof SystemPruneLibpodResponses];

export type SystemVersionLibpodData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/libpod/version';
};

export type SystemVersionLibpodResponses = {
  /**
   * Version
   */
  200: SystemComponentVersion;
};

export type SystemVersionLibpodResponse = SystemVersionLibpodResponses[keyof SystemVersionLibpodResponses];

export type VolumeDeleteLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the volume
     */
    name: string;
  };
  query?: {
    /**
     * force removal
     */
    force?: boolean;
  };
  url: '/libpod/volumes/{name}';
};

export type VolumeDeleteLibpodErrors = {
  /**
   * No such volume
   */
  404: ErrorModel;
  /**
   * Volume is in use and cannot be removed
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeDeleteLibpodError = VolumeDeleteLibpodErrors[keyof VolumeDeleteLibpodErrors];

export type VolumeDeleteLibpodResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type VolumeExistsLibpodData = {
  body?: never;
  path: {
    /**
     * the name of the volume
     */
    name: string;
  };
  query?: never;
  url: '/libpod/volumes/{name}/exists';
};

export type VolumeExistsLibpodErrors = {
  /**
   * No such volume
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeExistsLibpodError = VolumeExistsLibpodErrors[keyof VolumeExistsLibpodErrors];

export type VolumeExistsLibpodResponses = {
  /**
   * volume exists
   */
  204: unknown;
};

export type VolumeInspectLibpodData = {
  body?: never;
  path: {
    /**
     * the name or ID of the volume
     */
    name: string;
  };
  query?: never;
  url: '/libpod/volumes/{name}/json';
};

export type VolumeInspectLibpodErrors = {
  /**
   * No such volume
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeInspectLibpodError = VolumeInspectLibpodErrors[keyof VolumeInspectLibpodErrors];

export type VolumeInspectLibpodResponses = {
  /**
   * Volume details
   */
  200: VolumeConfigResponse;
};

export type VolumeInspectLibpodResponse = VolumeInspectLibpodResponses[keyof VolumeInspectLibpodResponses];

export type VolumeCreateLibpodData = {
  /**
   * attributes for creating a volume
   */
  body?: VolumeCreateOptions;
  path?: never;
  query?: never;
  url: '/libpod/volumes/create';
};

export type VolumeCreateLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeCreateLibpodError = VolumeCreateLibpodErrors[keyof VolumeCreateLibpodErrors];

export type VolumeCreateLibpodResponses = {
  /**
   * Volume details
   */
  201: VolumeConfigResponse;
};

export type VolumeCreateLibpodResponse = VolumeCreateLibpodResponses[keyof VolumeCreateLibpodResponses];

export type VolumeListLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a map[string][]string) to process on the volumes list. Available filters:
     * - driver=<volume-driver-name> Matches volumes based on their driver.
     * - label=<key> or label=<key>:<value> Matches volumes based on the presence of a label alone or a label and a value.
     * - name=<volume-name> Matches all of volume name.
     * - opt=<driver-option> Matches a storage driver options
     * - `until=<timestamp>` List volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     *
     */
    filters?: string;
  };
  url: '/libpod/volumes/json';
};

export type VolumeListLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeListLibpodError = VolumeListLibpodErrors[keyof VolumeListLibpodErrors];

export type VolumeListLibpodResponses = {
  /**
   * Volume list
   */
  200: Array<VolumeConfigResponse>;
};

export type VolumeListLibpodResponse = VolumeListLibpodResponses[keyof VolumeListLibpodResponses];

export type VolumePruneLibpodData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of filters (a map[string][]string) to match volumes against before pruning.
     * Available filters:
     * - `until=<timestamp>` Prune volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/libpod/volumes/prune';
};

export type VolumePruneLibpodErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumePruneLibpodError = VolumePruneLibpodErrors[keyof VolumePruneLibpodErrors];

export type VolumePruneLibpodResponses = {
  /**
   * Volume Prune
   */
  200: Array<PruneReport>;
};

export type VolumePruneLibpodResponse = VolumePruneLibpodResponses[keyof VolumePruneLibpodResponses];

export type NetworkListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a `map[string][]string`) to process on the network list. Currently available filters:
     * - `name=[name]` Matches network name (accepts regex).
     * - `id=[id]` Matches for full or partial ID.
     * - `driver=[driver]` Only bridge is supported.
     * - `label=[key]` or `label=[key=value]` Matches networks based on the presence of a label alone or a label and a value.
     *
     */
    filters?: string;
  };
  url: '/networks';
};

export type NetworkListErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkListError = NetworkListErrors[keyof NetworkListErrors];

export type NetworkListResponses = {
  /**
   * Network list
   */
  200: Array<Inspect>;
};

export type NetworkListResponse = NetworkListResponses[keyof NetworkListResponses];

export type NetworkDeleteData = {
  body?: never;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: never;
  url: '/networks/{name}';
};

export type NetworkDeleteErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkDeleteError = NetworkDeleteErrors[keyof NetworkDeleteErrors];

export type NetworkDeleteResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type NetworkInspectData = {
  body?: never;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: {
    /**
     * Detailed inspect output for troubleshooting
     */
    verbose?: boolean;
    /**
     * Filter the network by scope (swarm, global, or local)
     */
    scope?: string;
  };
  url: '/networks/{name}';
};

export type NetworkInspectErrors = {
  /**
   * No such network
   */
  404: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkInspectError = NetworkInspectErrors[keyof NetworkInspectErrors];

export type NetworkInspectResponses = {
  /**
   * Network inspect
   */
  200: Inspect;
};

export type NetworkInspectResponse = NetworkInspectResponses[keyof NetworkInspectResponses];

export type NetworkConnectData = {
  /**
   * attributes for connecting a container to a network
   */
  body?: NetworkConnectRequest;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: never;
  url: '/networks/{name}/connect';
};

export type NetworkConnectErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Network is already connected and container is running or transitioning to the running state ('initialized')
   */
  403: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkConnectError = NetworkConnectErrors[keyof NetworkConnectErrors];

export type NetworkConnectResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type NetworkDisconnectData = {
  /**
   * attributes for disconnecting a container from a network
   */
  body?: NetworkDisconnectRequest;
  path: {
    /**
     * the name of the network
     */
    name: string;
  };
  query?: never;
  url: '/networks/{name}/disconnect';
};

export type NetworkDisconnectErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkDisconnectError = NetworkDisconnectErrors[keyof NetworkDisconnectErrors];

export type NetworkDisconnectResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type NetworkCreateData = {
  /**
   * attributes for creating a network
   */
  body?: NetworkCreate;
  path?: never;
  query?: never;
  url: '/networks/create';
};

export type NetworkCreateErrors = {
  /**
   * Bad parameter in request
   */
  400: ErrorModel;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkCreateError = NetworkCreateErrors[keyof NetworkCreateErrors];

export type NetworkCreateResponses = {
  /**
   * network created
   */
  201: {
    Id?: string;
    Warning?: string;
  };
};

export type NetworkCreateResponse = NetworkCreateResponses[keyof NetworkCreateResponses];

export type NetworkPruneData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filters to process on the prune list, encoded as JSON (a map[string][]string).
     * Available filters:
     * - `until=<timestamp>` Prune networks created before this timestamp. The <timestamp> can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/networks/prune';
};

export type NetworkPruneErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type NetworkPruneError = NetworkPruneErrors[keyof NetworkPruneErrors];

export type NetworkPruneResponses = {
  /**
   * OK
   */
  200: {
    NetworksDeleted?: Array<string>;
  };
};

export type NetworkPruneResponse = NetworkPruneResponses[keyof NetworkPruneResponses];

export type SecretListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a `map[string][]string`) to process on the secrets list. Currently available filters:
     * - `name=[name]` Matches secrets name (accepts regex).
     * - `id=[id]` Matches for full or partial ID.
     *
     */
    filters?: string;
  };
  url: '/secrets';
};

export type SecretListErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretListError = SecretListErrors[keyof SecretListErrors];

export type SecretListResponses = {
  /**
   * Secret list response
   */
  200: Array<SecretInfoReportCompat>;
};

export type SecretListResponse = SecretListResponses[keyof SecretListResponses];

export type SecretDeleteData = {
  body?: never;
  path: {
    /**
     * the name or ID of the secret
     */
    name: string;
  };
  query?: never;
  url: '/secrets/{name}';
};

export type SecretDeleteErrors = {
  /**
   * No such secret
   */
  404: {
    /**
     * API root cause formatted for automated parsing
     */
    cause?: string;
    /**
     * human error message, formatted for a human to read
     */
    message?: string;
    /**
     * HTTP response code
     */
    response?: number;
  };
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretDeleteError = SecretDeleteErrors[keyof SecretDeleteErrors];

export type SecretDeleteResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type SecretInspectData = {
  body?: never;
  path: {
    /**
     * the name or ID of the secret
     */
    name: string;
  };
  query?: never;
  url: '/secrets/{name}';
};

export type SecretInspectErrors = {
  /**
   * No such secret
   */
  404: {
    /**
     * API root cause formatted for automated parsing
     */
    cause?: string;
    /**
     * human error message, formatted for a human to read
     */
    message?: string;
    /**
     * HTTP response code
     */
    response?: number;
  };
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretInspectError = SecretInspectErrors[keyof SecretInspectErrors];

export type SecretInspectResponses = {
  /**
   * Secret inspect compat
   */
  200: SecretInfoReportCompat;
};

export type SecretInspectResponse = SecretInspectResponses[keyof SecretInspectResponses];

export type SecretCreateData = {
  /**
   * attributes for creating a secret
   *
   */
  body?: SecretCreate;
  path?: never;
  query?: never;
  url: '/secrets/create';
};

export type SecretCreateErrors = {
  /**
   * Secret in use
   */
  409: {
    /**
     * API root cause formatted for automated parsing
     */
    cause?: string;
    /**
     * human error message, formatted for a human to read
     */
    message?: string;
    /**
     * HTTP response code
     */
    response?: number;
  };
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SecretCreateError = SecretCreateErrors[keyof SecretCreateErrors];

export type SecretCreateResponses = {
  /**
   * Secret create response
   */
  201: {
    ID?: string;
  };
};

export type SecretCreateResponse = SecretCreateResponses[keyof SecretCreateResponses];

export type SystemDataUsageData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/system/df';
};

export type SystemDataUsageErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type SystemDataUsageError = SystemDataUsageErrors[keyof SystemDataUsageErrors];

export type SystemDataUsageResponses = {
  /**
   * Disk usage
   */
  200: SystemDfReport;
};

export type SystemDataUsageResponse = SystemDataUsageResponses[keyof SystemDataUsageResponses];

export type SystemVersionData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/version';
};

export type SystemVersionResponses = {
  /**
   * Version
   */
  200: SystemComponentVersion;
};

export type SystemVersionResponse = SystemVersionResponses[keyof SystemVersionResponses];

export type VolumeListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of the filters (a map[string][]string) to process on the volumes list. Available filters:
     * - driver=<volume-driver-name> Matches volumes based on their driver.
     * - label=<key> or label=<key>:<value> Matches volumes based on the presence of a label alone or a label and a value.
     * - name=<volume-name> Matches all of volume name.
     * - `until=<timestamp>` List volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     *
     * Note:
     * The boolean `dangling` filter is not yet implemented for this endpoint.
     *
     */
    filters?: string;
  };
  url: '/volumes';
};

export type VolumeListErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeListError = VolumeListErrors[keyof VolumeListErrors];

export type VolumeListResponses = {
  /**
   * Volume List
   */
  200: ListResponse;
};

export type VolumeListResponse = VolumeListResponses[keyof VolumeListResponses];

export type VolumeDeleteData = {
  body?: never;
  path: {
    /**
     * the name or ID of the volume
     */
    name: string;
  };
  query?: {
    /**
     * Force removal of the volume. This actually only causes errors due
     * to the names volume not being found to be suppressed, which is the
     * behaviour Docker implements.
     *
     */
    force?: boolean;
  };
  url: '/volumes/{name}';
};

export type VolumeDeleteErrors = {
  /**
   * No such volume
   */
  404: ErrorModel;
  /**
   * Volume is in use and cannot be removed
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeDeleteError = VolumeDeleteErrors[keyof VolumeDeleteErrors];

export type VolumeDeleteResponses = {
  /**
   * no error
   */
  204: unknown;
};

export type VolumeInspectData = {
  body?: never;
  path: {
    /**
     * the name or ID of the volume
     */
    name: string;
  };
  query?: never;
  url: '/volumes/{name}';
};

export type VolumeInspectErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeInspectError = VolumeInspectErrors[keyof VolumeInspectErrors];

export type VolumeInspectResponses = {
  /**
   * This response definition is used for both the create and inspect endpoints
   */
  200: Volume;
};

export type VolumeInspectResponse = VolumeInspectResponses[keyof VolumeInspectResponses];

export type VolumeCreateData = {
  /**
   * attributes for creating a volume.
   * Note: If a volume by the same name exists, a 201 response with that volume's information will be generated.
   *
   */
  body?: VolumeCreate;
  path?: never;
  query?: never;
  url: '/volumes/create';
};

export type VolumeCreateErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumeCreateError = VolumeCreateErrors[keyof VolumeCreateErrors];

export type VolumeCreateResponses = {
  /**
   * This response definition is used for both the create and inspect endpoints
   */
  201: Volume;
};

export type VolumeCreateResponse = VolumeCreateResponses[keyof VolumeCreateResponses];

export type VolumePruneData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * JSON encoded value of filters (a map[string][]string) to match volumes against before pruning.
     * Available filters:
     * - `until=<timestamp>` Prune volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
     * - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
     *
     */
    filters?: string;
  };
  url: '/volumes/prune';
};

export type VolumePruneErrors = {
  /**
   * Internal server error
   */
  500: ErrorModel;
};

export type VolumePruneError = VolumePruneErrors[keyof VolumePruneErrors];

export type VolumePruneResponses = {
  /**
   * Volume prune
   */
  200: PruneReport;
};

export type VolumePruneResponse = VolumePruneResponses[keyof VolumePruneResponses];

export type ClientOptions = {
  baseUrl: 'http://podman.io/' | 'https://podman.io/' | (string & {});
};
